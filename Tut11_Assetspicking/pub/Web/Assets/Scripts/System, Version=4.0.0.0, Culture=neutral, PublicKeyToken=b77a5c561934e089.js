/* Generated by JSIL v0.8.2 build 31050. See http://jsil.org/ for more information. */ 
'use strict';
/* Generating type stubs only */ 
var $asm12 = JSIL.DeclareAssembly("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");

/* enum MatchState */ 

JSIL.MakeEnum(
  {
    FullName: "MatchState", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    HasSymbol: 1, 
    HasMatch: 2, 
    HasSymbolAndMatch: 3, 
  }
);

JSIL.DeclareNamespace("Microsoft");
JSIL.DeclareNamespace("Microsoft.VisualBasic");
JSIL.DeclareNamespace("System");
JSIL.DeclareNamespace("System.CodeDom");
JSIL.DeclareNamespace("System.CodeDom.Compiler");
JSIL.DeclareNamespace("System.ComponentModel");
/* class System.ComponentModel.Component */ 

(function Component$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.MarshalByRefObject"), 
      Name: "System.ComponentModel.Component", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_CanRaiseEvents", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_CanRaiseEventsInternal", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_DesignMode", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Site", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.ComponentModel.ISite"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetService", 
      new JSIL.MethodSignature($.Object, [$asm0F.TypeRef("System.Type")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "EventDisposed", $.Object);

    $.Field({Static:false, Public:false}, "site", $asm12.TypeRef("System.ComponentModel.ISite"));

    $.Field({Static:false, Public:false}, "events", $asm12.TypeRef("System.ComponentModel.EventHandlerList"));

    $.Property({Static:false, Public:false, Virtual:true }, "CanRaiseEvents", $.Boolean);

    $.Property({Static:false, Public:false}, "CanRaiseEventsInternal", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Site", $asm12.TypeRef("System.ComponentModel.ISite"));

    $.Property({Static:false, Public:false}, "DesignMode", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm12.TypeRef("System.ComponentModel.IComponent"), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [true]; });

})();

/* class System.CodeDom.Compiler.CodeDomProvider */ 

(function CodeDomProvider$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.ComponentModel.Component"), 
      Name: "System.CodeDom.Compiler.CodeDomProvider", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:true }, "CreateProvider", 
      new JSIL.MethodSignature($.Type, [$.String, $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String])])
    )
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

    $.ExternalMethod({Static:true , Public:false}, "get_Config", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.CodeDom.Compiler.CodeDomCompilationConfiguration"))
    );

    $.ExternalMethod({Static:true , Public:true }, "GetCompilerInfo", 
      new JSIL.MethodSignature($asm12.TypeRef("System.CodeDom.Compiler.CompilerInfo"), [$.String])
    )
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

    $.ExternalMethod({Static:true , Public:false}, "GetCompilerInfoForLanguageNoThrow", 
      new JSIL.MethodSignature($asm12.TypeRef("System.CodeDom.Compiler.CompilerInfo"), [$.String])
    );

    $.Property({Static:true , Public:false}, "Config", $asm12.TypeRef("System.CodeDom.Compiler.CodeDomCompilationConfiguration"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [true]; });

})();

/* class Microsoft.VisualBasic.VBCodeProvider */ 

(function VBCodeProvider$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.CodeDom.Compiler.CodeDomProvider"), 
      Name: "Microsoft.VisualBasic.VBCodeProvider", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]))
    );

    $.Field({Static:false, Public:false}, "generator", $asm12.TypeRef("Microsoft.VisualBasic.VBCodeGenerator"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.CodeDom.Compiler.CodeGenerator */ 

(function CodeGenerator$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.CodeDom.Compiler.CodeGenerator", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.CodeDom.Compiler.CodeCompiler */ 

(function CodeCompiler$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.CodeDom.Compiler.CodeGenerator"), 
      Name: "System.CodeDom.Compiler.CodeCompiler", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.VisualBasic.VBCodeGenerator */ 

(function VBCodeGenerator$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.CodeDom.Compiler.CodeCompiler"), 
      Name: "Microsoft.VisualBasic.VBCodeGenerator", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]))
    );

    $.Field({Static:false, Public:false}, "provOptions", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "keywords", $jsilcore.TypeRef("System.Array", [$jsilcore.TypeRef("System.Array", [$.String])]));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("Microsoft.CSharp");
/* class Microsoft.CSharp.CSharpCodeProvider */ 

(function CSharpCodeProvider$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.CodeDom.Compiler.CodeDomProvider"), 
      Name: "Microsoft.CSharp.CSharpCodeProvider", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]))
    );

    $.Field({Static:false, Public:false}, "generator", $asm12.TypeRef("Microsoft.CSharp.CSharpCodeGenerator"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.CSharp.CSharpCodeGenerator */ 

(function CSharpCodeGenerator$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.CSharp.CSharpCodeGenerator", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]))
    );

    $.Field({Static:false, Public:false}, "provOptions", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "keywords", $jsilcore.TypeRef("System.Array", [$jsilcore.TypeRef("System.Array", [$.String])]));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("Microsoft.Win32");
/* class Microsoft.Win32.NativeMethods */ 

(function NativeMethods$Members () {
  var $, $thisType;



























  JSIL.MakeStaticClass("Microsoft.Win32.NativeMethods", false, [], function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:true }, "AdjustTokenPrivileges", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $.Boolean, 
          $asm12.TypeRef("Microsoft.Win32.NativeMethods+TokenPrivileges"), $.Int32, 
          $.IntPtr, $.IntPtr
        ]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "CreateFileMapping", 
      new JSIL.MethodSignature($asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeFileMappingHandle"), [
          $.IntPtr, $asm12.TypeRef("Microsoft.Win32.NativeMethods+SECURITY_ATTRIBUTES"), 
          $.Int32, $.Int32, 
          $.Int32, $.String
        ]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "CreateToolhelp32Snapshot", 
      new JSIL.MethodSignature($.IntPtr, [$.Int32, $.Int32]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "DuplicateHandle", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), 
          $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeWaitHandle")]), 
          $.Int32, $.Boolean, 
          $.Int32
        ]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'ansi',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "EnumProcesses", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("System.Array", [$.Int32]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "psapi.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "EnumProcessModules", 
      new JSIL.MethodSignature($.Boolean, [
          $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), $.IntPtr, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "psapi.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetCurrentProcess", 
      JSIL.MethodSignature.Return($.IntPtr), 
      {
        Module: "kernel32.dll", 
        CharSet: 'ansi',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetCurrentProcessId", 
      JSIL.MethodSignature.Return($.Int32), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetExitCodeProcess", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetModuleBaseName", 
      new JSIL.MethodSignature($.Int32, [
          $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), 
          $asm0F.TypeRef("System.Text.StringBuilder"), $.Int32
        ]), 
      {
        Module: "psapi.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetModuleFileNameEx", 
      new JSIL.MethodSignature($.Int32, [
          $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), 
          $asm0F.TypeRef("System.Text.StringBuilder"), $.Int32
        ]), 
      {
        Module: "psapi.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetModuleInformation", 
      new JSIL.MethodSignature($.Boolean, [
          $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), 
          $asm12.TypeRef("Microsoft.Win32.NativeMethods+NtModuleInfo"), $.Int32
        ]), 
      {
        Module: "psapi.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetProcessTimes", 
      new JSIL.MethodSignature($.Boolean, [
          $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), $jsilcore.TypeRef("JSIL.Reference", [$.Int64]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int64]), $jsilcore.TypeRef("JSIL.Reference", [$.Int64]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int64])
        ]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "LookupPrivilegeValue", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.String, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("Microsoft.Win32.NativeMethods+LUID")])
        ]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'auto',
        Parameters: [
          {
            NativeType: "LPTStr"
          }, 
          {
            NativeType: "LPTStr"
          }, null

        ]
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "Module32First", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $.IntPtr]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "Module32Next", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $.IntPtr]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "NtQueryInformationProcess", 
      new JSIL.MethodSignature($.Int32, [
          $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), $.Int32, 
          $asm12.TypeRef("Microsoft.Win32.NativeMethods+NtProcessBasicInfo"), $.Int32, 
          $jsilcore.TypeRef("System.Array", [$.Int32])
        ]), 
      {
        Module: "ntdll.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "NtQuerySystemInformation", 
      new JSIL.MethodSignature($.Int32, [
          $.Int32, $.IntPtr, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "ntdll.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "OpenFileMapping", 
      new JSIL.MethodSignature($asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeFileMappingHandle"), [
          $.Int32, $.Boolean, 
          $.String
        ]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "OpenProcess", 
      new JSIL.MethodSignature($asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), [
          $.Int32, $.Boolean, 
          $.Int32
        ]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "OpenProcessToken", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.IntPtr])
        ]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "Process32First", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $.IntPtr]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "Process32Next", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $.IntPtr]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "Thread32First", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $asm12.TypeRef("Microsoft.Win32.NativeMethods+WinThreadEntry")]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "Thread32Next", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), $asm12.TypeRef("Microsoft.Win32.NativeMethods+WinThreadEntry")]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "VirtualQuery", 
      new JSIL.MethodSignature($.IntPtr, [
          $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeFileMapViewHandle"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("Microsoft.Win32.NativeMethods+MEMORY_BASIC_INFORMATION")]), 
          $.IntPtr
        ]), 
      {
        Module: "kernel32.dll", 
      }
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "NullHandleRef", $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"));

    $.Field({Static:true , Public:true , ReadOnly:true }, "INVALID_HANDLE_VALUE", $.IntPtr);

    $.Field({Static:true , Public:true , ReadOnly:true }, "HKEY_LOCAL_MACHINE", $.IntPtr);


    function NativeMethods__cctor () {
      $thisType.NullHandleRef = new $asm0F.System.Runtime.InteropServices.HandleRef();
      $thisType.INVALID_HANDLE_VALUE = new $asm0F.System.IntPtr();
      $thisType.HKEY_LOCAL_MACHINE = new $asm0F.System.IntPtr();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      NativeMethods__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+TEXTMETRIC */ 

(function TEXTMETRIC$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+TEXTMETRIC", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "tmHeight", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+SECURITY_ATTRIBUTES */ 

(function SECURITY_ATTRIBUTES$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+SECURITY_ATTRIBUTES", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "nLength", $.Int32);

    $.Field({Static:false, Public:true }, "lpSecurityDescriptor", $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeLocalMemHandle"));

    $.Field({Static:false, Public:true }, "bInheritHandle", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+PERF_COUNTER_BLOCK */ 

(function PERF_COUNTER_BLOCK$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+PERF_COUNTER_BLOCK", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "ByteLength", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+PERF_COUNTER_DEFINITION */ 

(function PERF_COUNTER_DEFINITION$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+PERF_COUNTER_DEFINITION", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "ByteLength", $.Int32);

    $.Field({Static:false, Public:true }, "CounterNameTitleIndex", $.Int32);

    $.Field({Static:false, Public:true }, "CounterNameTitlePtr", $.Int32);

    $.Field({Static:false, Public:true }, "CounterHelpTitleIndex", $.Int32);

    $.Field({Static:false, Public:true }, "CounterType", $.Int32);

    $.Field({Static:false, Public:true }, "CounterOffset", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+PERF_DATA_BLOCK */ 

(function PERF_DATA_BLOCK$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+PERF_DATA_BLOCK", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "TotalByteLength", $.Int32);

    $.Field({Static:false, Public:true }, "HeaderLength", $.Int32);

    $.Field({Static:false, Public:true }, "NumObjectTypes", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+PERF_INSTANCE_DEFINITION */ 

(function PERF_INSTANCE_DEFINITION$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+PERF_INSTANCE_DEFINITION", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "ByteLength", $.Int32);

    $.Field({Static:false, Public:true }, "NameOffset", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+PERF_OBJECT_TYPE */ 

(function PERF_OBJECT_TYPE$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+PERF_OBJECT_TYPE", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "TotalByteLength", $.Int32);

    $.Field({Static:false, Public:true }, "DefinitionLength", $.Int32);

    $.Field({Static:false, Public:true }, "HeaderLength", $.Int32);

    $.Field({Static:false, Public:true }, "ObjectNameTitleIndex", $.Int32);

    $.Field({Static:false, Public:true }, "ObjectHelpTitleIndex", $.Int32);

    $.Field({Static:false, Public:true }, "NumCounters", $.Int32);

    $.Field({Static:false, Public:true }, "NumInstances", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+NtModuleInfo */ 

(function NtModuleInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+NtModuleInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "BaseOfDll", $.IntPtr);

    $.Field({Static:false, Public:true }, "SizeOfImage", $.Int32);

    $.Field({Static:false, Public:true }, "EntryPoint", $.IntPtr);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+WinProcessEntry */ 

(function WinProcessEntry$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+WinProcessEntry", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "cntUsage", $.Int32);

    $.Field({Static:false, Public:true }, "th32ProcessID", $.Int32);

    $.Field({Static:false, Public:true }, "th32DefaultHeapID", $.IntPtr);

    $.Field({Static:false, Public:true }, "th32ModuleID", $.Int32);

    $.Field({Static:false, Public:true }, "pcPriClassBase", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+WinThreadEntry */ 

(function WinThreadEntry$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+WinThreadEntry", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "dwSize", $.Int32);

    $.Field({Static:false, Public:true }, "th32ThreadID", $.Int32);

    $.Field({Static:false, Public:true }, "th32OwnerProcessID", $.Int32);

    $.Field({Static:false, Public:true }, "tpBasePri", $.Int32);

    $.Field({Static:false, Public:true }, "tpDeltaPri", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+WinModuleEntry */ 

(function WinModuleEntry$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+WinModuleEntry", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "th32ModuleID", $.Int32);

    $.Field({Static:false, Public:true }, "modBaseAddr", $.IntPtr);

    $.Field({Static:false, Public:true }, "modBaseSize", $.Int32);

    $.Field({Static:false, Public:true }, "hModule", $.IntPtr);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+NtProcessBasicInfo */ 

(function NtProcessBasicInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+NtProcessBasicInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "PebBaseAddress", $.IntPtr);

    $.Field({Static:false, Public:true }, "AffinityMask", $.IntPtr);

    $.Field({Static:false, Public:true }, "UniqueProcessId", $.IntPtr);

    $.Field({Static:false, Public:true }, "InheritedFromUniqueProcessId", $.IntPtr);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Microsoft.Win32.NativeMethods+LUID */ 

(function LUID$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "Microsoft.Win32.NativeMethods+LUID", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.NativeMethods+TokenPrivileges */ 

(function TokenPrivileges$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.NativeMethods+TokenPrivileges", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "PrivilegeCount", $.Int32);

    $.Field({Static:false, Public:true }, "Luid", $asm12.TypeRef("Microsoft.Win32.NativeMethods+LUID"));

    $.Field({Static:false, Public:true }, "Attributes", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Microsoft.Win32.NativeMethods+MEMORY_BASIC_INFORMATION */ 

(function MEMORY_BASIC_INFORMATION$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "Microsoft.Win32.NativeMethods+MEMORY_BASIC_INFORMATION", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "RegionSize", $.UIntPtr);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.SafeNativeMethods */ 

(function SafeNativeMethods$Members () {
  var $, $thisType;













  JSIL.MakeStaticClass("Microsoft.Win32.SafeNativeMethods", false, [], function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:true }, "CloseHandle", 
      new JSIL.MethodSignature($.Boolean, [$.IntPtr]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "FormatMessage", 
      new JSIL.MethodSignature($.Int32, [
          $.Int32, $.IntPtr, 
          $.UInt32, $.Int32, 
          $asm0F.TypeRef("System.Text.StringBuilder"), $.Int32, 
          $jsilcore.TypeRef("System.Array", [$.IntPtr])
        ]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetComputerName", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Text.StringBuilder"), $jsilcore.TypeRef("System.Array", [$.Int32])]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetStockObject", 
      new JSIL.MethodSignature($.IntPtr, [$.Int32]), 
      {
        Module: "gdi32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetTextMetrics", 
      new JSIL.MethodSignature($.Boolean, [$.IntPtr, $asm12.TypeRef("Microsoft.Win32.NativeMethods+TEXTMETRIC")]), 
      {
        Module: "gdi32.dll", 
        CharSet: 'auto',
      }
    );

    $.ExternalMethod({Static:true , Public:true }, "InterlockedCompareExchange", 
      new JSIL.MethodSignature($.Int32, [
          $.IntPtr, $.Int32, 
          $.Int32
        ])
    );

    $.PInvokeMethod({Static:true , Public:true }, "IsWow64Process", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])]), 
      {
        Module: "kernel32.dll", 
      }
    );

    $.ExternalMethod({Static:true , Public:true }, "MessageBox", 
      new JSIL.MethodSignature($.Int32, [
          $.IntPtr, $.String, 
          $.String, $.Int32
        ])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.PInvokeMethod({Static:true , Public:false}, "MessageBoxSystem", 
      new JSIL.MethodSignature($.Int32, [
          $.IntPtr, $.String, 
          $.String, $.Int32
        ]), 
      {
        Module: "user32.dll", 
        CharSet: 'unicode',
        EntryPoint: "MessageBoxW", 
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "OutputDebugString", 
      JSIL.MethodSignature.Action($.String), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "QueryPerformanceCounter", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$.Int64])]), 
      {
        Module: "kernel32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "QueryPerformanceFrequency", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$.Int64])]), 
      {
        Module: "kernel32.dll", 
      }
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.UnsafeNativeMethods */ 

(function UnsafeNativeMethods$Members () {
  var $, $thisType;


















  JSIL.MakeStaticClass("Microsoft.Win32.UnsafeNativeMethods", false, [], function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:false}, "_AppPolicyGetClrCompat", 
      new JSIL.MethodSignature($.Int32, [$.IntPtr, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("Microsoft.Win32.UnsafeNativeMethods+AppPolicyClrCompat")])]), 
      {
        Module: "kernel32.dll", 
        EntryPoint: "AppPolicyGetClrCompat", 
        Result: {
          NativeType: "I4"
        }
      }
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.PInvokeMethod({Static:true , Public:false}, "_GetCurrentPackageId", 
      new JSIL.MethodSignature($.Int32, [$jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("System.Array", [$.Byte])]), 
      {
        Module: "kernel32.dll", 
        EntryPoint: "GetCurrentPackageId", 
        Result: {
          NativeType: "I4"
        }
      }
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "_IsPackagedProcess", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "DoesWin32MethodExist", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "GetCurrentProcessToken", 
      JSIL.MethodSignature.Return($.IntPtr)
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetDC", 
      new JSIL.MethodSignature($.IntPtr, [$.IntPtr]), 
      {
        Module: "user32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetModuleHandle", 
      new JSIL.MethodSignature($.IntPtr, [$.String]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetNumberOfEventLogRecords", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'unicode',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetOldestEventLogRecord", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'unicode',
        Result: {
          NativeType: "Boolean"
        }
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetProcAddress", 
      new JSIL.MethodSignature($.IntPtr, [$.IntPtr, $.String]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'ansi',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "GetSystemMetrics", 
      new JSIL.MethodSignature($.Int32, [$.Int32]), 
      {
        Module: "user32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "GetTokenInformation", 
      new JSIL.MethodSignature($.Boolean, [
          $.IntPtr, $.UInt32, 
          $.IntPtr, $.UInt32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.UInt32])
        ]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "NotifyChangeEventLog", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeWaitHandle")]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'unicode',
        Result: {
          NativeType: "Boolean"
        }
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "ReadEventLog", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), $.Int32, 
          $.Int32, $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'unicode',
        Result: {
          NativeType: "Boolean"
        }
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "ReleaseDC", 
      new JSIL.MethodSignature($.Int32, [$.IntPtr, $.IntPtr]), 
      {
        Module: "user32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "ReportEvent", 
      new JSIL.MethodSignature($.Boolean, [
          $asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), $.Int16, 
          $.UInt16, $.UInt32, 
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int16, 
          $.Int32, $asm0F.TypeRef("System.Runtime.InteropServices.HandleRef"), 
          $jsilcore.TypeRef("System.Array", [$.Byte])
        ]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'unicode',
      }
    );

    $.PInvokeMethod({Static:true , Public:true }, "SelectObject", 
      new JSIL.MethodSignature($.IntPtr, [$.IntPtr, $.IntPtr]), 
      {
        Module: "gdi32.dll", 
        CharSet: 'auto',
      }
    );

    $.Field({Static:true , Public:false}, "IsPackagedProcess", $asm0F.TypeRef("System.Lazy`1", [$.Boolean]))
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.UnsafeNativeMethods+<>c */ 

(function $l$gc$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.UnsafeNativeMethods+<>c", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$l.cctor$gb__152_0", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "$l$g9", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class Microsoft.Win32.InternetSecurityManager */ 

(function InternetSecurityManager$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "Microsoft.Win32.InternetSecurityManager", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.GuidAttribute"), function () { return ["7b8a2d94-0ac9-11d1-896c-00c04Fb6bfc4"]; });

})();

/* interface Microsoft.Win32.IInternetSecurityManager */ 

JSIL.MakeInterface(
  "Microsoft.Win32.IInternetSecurityManager", false, [], function ($) {
    $.Method({}, "MapUrlToZone", new JSIL.MethodSignature(null, [
          $.String, $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $.Int32
        ]));
  }, [])
  .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; })
  .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.GuidAttribute"), function () { return ["79eac9ee-baf9-11ce-8c82-00aa004ba90b"]; })
  .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.InterfaceTypeAttribute"), function () { return [$asm0F.System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown]; });

JSIL.DeclareNamespace("Microsoft.Win32.SafeHandles");
/* class Microsoft.Win32.SafeHandles.SafeEventLogReadHandle */ 

(function SafeEventLogReadHandle$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "Microsoft.Win32.SafeHandles.SafeEventLogReadHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:false}, "OpenEventLog", 
      new JSIL.MethodSignature($.Type, [$.String, $.String]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'unicode',
      }
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.SafeHandles.SafeEventLogWriteHandle */ 

(function SafeEventLogWriteHandle$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "Microsoft.Win32.SafeHandles.SafeEventLogWriteHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:false}, "RegisterEventSource", 
      new JSIL.MethodSignature($.Type, [$.String, $.String]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'unicode',
      }
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.SafeHandles.SafeFileMappingHandle */ 

(function SafeFileMappingHandle$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "Microsoft.Win32.SafeHandles.SafeFileMappingHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.SafeHandles.SafeFileMapViewHandle */ 

(function SafeFileMapViewHandle$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "Microsoft.Win32.SafeHandles.SafeFileMapViewHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:false}, "MapViewOfFile", 
      new JSIL.MethodSignature($.Type, [
          $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeFileMappingHandle"), $.Int32, 
          $.Int32, $.Int32, 
          $.UIntPtr
        ]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.SafeHandles.SafeLibraryHandle */ 

(function SafeLibraryHandle$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "Microsoft.Win32.SafeHandles.SafeLibraryHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.SafeHandles.SafeLocalMemHandle */ 

(function SafeLocalMemHandle$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "Microsoft.Win32.SafeHandles.SafeLocalMemHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.IntPtr, $.Boolean])
    );

    $.PInvokeMethod({Static:true , Public:false}, "ConvertStringSecurityDescriptorToSecurityDescriptor", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.IntPtr
        ]), 
      {
        Module: "advapi32.dll", 
        CharSet: 'auto',
      }
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Microsoft.Win32.SafeHandles.SafeProcessHandle */ 

(function SafeProcessHandle$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "Microsoft.Win32.SafeHandles.SafeProcessHandle", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.IntPtr)
    );

    $.PInvokeMethod({Static:true , Public:false}, "OpenProcess", 
      new JSIL.MethodSignature($.Type, [
          $.Int32, $.Boolean, 
          $.Int32
        ]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );

    $.Field({Static:true , Public:false}, "InvalidHandle", $.Type);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.AppContextDefaultValues */ 

(function AppContextDefaultValues$Members () {
  var $, $thisType;





  JSIL.MakeStaticClass("System.AppContextDefaultValues", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "ParseTargetFrameworkName", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.String]), $jsilcore.TypeRef("JSIL.Reference", [$.String]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:true , Public:true }, "PopulateDefaultValues", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "PopulateDefaultValuesPartial", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "TryParseFrameworkName", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $jsilcore.TypeRef("JSIL.Reference", [$.String]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.LocalAppContextSwitches */ 

(function LocalAppContextSwitches$Members () {
  var $, $thisType;




  JSIL.MakeStaticClass("System.LocalAppContextSwitches", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "get_DoNotUseNativeZipLibraryForDecompression", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_DontEnableStrictRFC3986ReservedCharacterSets", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_DontKeepUnicodeBidiFormattingCharacters", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:true , Public:false}, "_dontEnableStrictRFC3986ReservedCharacterSets", $.Int32);

    $.Field({Static:true , Public:false}, "_dontKeepUnicodeBidiFormattingCharacters", $.Int32);
    ; 
    ; 
    ; 
    ; 
    ; 

    $.Field({Static:true , Public:false}, "_doNotUseNativeZipLibraryForDecompression", $.Int32);

    $.Property({Static:true , Public:true }, "DontEnableStrictRFC3986ReservedCharacterSets", $.Boolean);

    $.Property({Static:true , Public:true }, "DontKeepUnicodeBidiFormattingCharacters", $.Boolean);

    $.Property({Static:true , Public:true }, "DoNotUseNativeZipLibraryForDecompression", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.ThrowHelper */ 

(function ThrowHelper$Members () {
  var $, $thisType;














  JSIL.MakeStaticClass("System.ThrowHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "GetArgumentName", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.ExceptionArgument")])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetResourceName", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.ExceptionResource")])
    );

    $.ExternalMethod({Static:true , Public:false}, "IfNullAndNullsAreIllegalThenThrow", 
      new JSIL.MethodSignature(null, [$.Object, $asm12.TypeRef("System.ExceptionArgument")], ["T"])
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowArgumentException", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.ExceptionResource"))
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowArgumentNullException", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.ExceptionArgument"))
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowArgumentOutOfRangeException", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.ExceptionArgument"))
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowArgumentOutOfRangeException", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.ExceptionArgument"), $asm12.TypeRef("System.ExceptionResource")])
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowInvalidOperationException", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.ExceptionResource"))
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowKeyNotFoundException", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowNotSupportedException", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.ExceptionResource"))
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowSerializationException", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.ExceptionResource"))
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowWrongKeyTypeArgumentException", 
      new JSIL.MethodSignature(null, [$.Object, $asm0F.TypeRef("System.Type")])
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowWrongValueTypeArgumentException", 
      new JSIL.MethodSignature(null, [$.Object, $asm0F.TypeRef("System.Type")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.ExceptionArgument */ 

JSIL.MakeEnum(
  {
    FullName: "System.ExceptionArgument", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    obj: 0, 
    dictionary: 1, 
    array: 2, 
    info: 3, 
    key: 4, 
    collection: 5, 
    match: 6, 
    converter: 7, 
    queue: 8, 
    stack: 9, 
    capacity: 10, 
    index: 11, 
    startIndex: 12, 
    value: 13, 
    count: 14, 
    arrayIndex: 15, 
    item: 16, 
  }
);

/* enum System.ExceptionResource */ 

JSIL.MakeEnum(
  {
    FullName: "System.ExceptionResource", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Argument_ImplementIComparable: 0, 
    ArgumentOutOfRange_NeedNonNegNum: 1, 
    ArgumentOutOfRange_NeedNonNegNumRequired: 2, 
    Arg_ArrayPlusOffTooSmall: 3, 
    Argument_AddingDuplicate: 4, 
    Serialization_InvalidOnDeser: 5, 
    Serialization_MismatchedCount: 6, 
    Serialization_MissingValues: 7, 
    Arg_RankMultiDimNotSupported: 8, 
    Arg_NonZeroLowerBound: 9, 
    Argument_InvalidArrayType: 10, 
    NotSupported_KeyCollectionSet: 11, 
    ArgumentOutOfRange_SmallCapacity: 12, 
    ArgumentOutOfRange_Index: 13, 
    Argument_InvalidOffLen: 14, 
    NotSupported_ReadOnlyCollection: 15, 
    InvalidOperation_CannotRemoveFromStackOrQueue: 16, 
    InvalidOperation_EmptyCollection: 17, 
    InvalidOperation_EmptyQueue: 18, 
    InvalidOperation_EnumOpCantHappen: 19, 
    InvalidOperation_EnumFailedVersion: 20, 
    InvalidOperation_EmptyStack: 21, 
    InvalidOperation_EnumNotStarted: 22, 
    InvalidOperation_EnumEnded: 23, 
    NotSupported_SortedListNestedWrite: 24, 
    NotSupported_ValueCollectionSet: 25, 
  }
);

/* class System.UriParser */ 

(function UriParser$Members () {
  var $, $thisType;






















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.UriParser", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.UriSyntaxFlags"))
    );

    $.ExternalMethod({Static:true , Public:false}, "FindOrFetchAsUnknownV1Syntax", 
      new JSIL.MethodSignature($.Type, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_DefaultPort", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_DontEnableStrictRFC3986ReservedCharacterSets", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_DontKeepUnicodeBidiFormattingCharacters", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Flags", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.UriSyntaxFlags"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsSimple", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_SchemeName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_ShouldUseLegacyV2Quirks", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetComponents", 
      new JSIL.MethodSignature($.String, [
          $asm12.TypeRef("System.Uri"), $asm12.TypeRef("System.UriComponents"), 
          $asm12.TypeRef("System.UriFormat")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetSyntax", 
      new JSIL.MethodSignature($.Type, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "InFact", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.UriSyntaxFlags")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "InitializeAndValidate", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Uri"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.UriFormatException")])])
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalGetComponents", 
      new JSIL.MethodSignature($.String, [
          $asm12.TypeRef("System.Uri"), $asm12.TypeRef("System.UriComponents"), 
          $asm12.TypeRef("System.UriFormat")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalOnNewUri", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalValidate", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Uri"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.UriFormatException")])])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsAllSet", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.UriSyntaxFlags")])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsFullMatch", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.UriSyntaxFlags"), $asm12.TypeRef("System.UriSyntaxFlags")])
    );

    $.ExternalMethod({Static:false, Public:false}, "NotAny", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.UriSyntaxFlags")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnNewUri", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "SetUpdatableFlags", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.UriSyntaxFlags"))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "m_Table", $asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.Type]));

    $.Field({Static:true , Public:false}, "m_TempTable", $asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.Type]));

    $.Field({Static:false, Public:false}, "m_Flags", $asm12.TypeRef("System.UriSyntaxFlags"));

    $.Field({Static:false, Public:false}, "m_UpdatableFlags", $asm12.TypeRef("System.UriSyntaxFlags"));

    $.Field({Static:false, Public:false}, "m_UpdatableFlagsUsed", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:false, Public:false}, "m_Port", $.Int32);

    $.Field({Static:false, Public:false}, "m_Scheme", $.String);

    $.Field({Static:true , Public:false}, "HttpUri", $.Type);

    $.Field({Static:true , Public:false}, "HttpsUri", $.Type);

    $.Field({Static:true , Public:false}, "WsUri", $.Type);

    $.Field({Static:true , Public:false}, "WssUri", $.Type);

    $.Field({Static:true , Public:false}, "FtpUri", $.Type);

    $.Field({Static:true , Public:false}, "FileUri", $.Type);

    $.Field({Static:true , Public:false}, "GopherUri", $.Type);

    $.Field({Static:true , Public:false}, "NntpUri", $.Type);

    $.Field({Static:true , Public:false}, "NewsUri", $.Type);

    $.Field({Static:true , Public:false}, "MailToUri", $.Type);

    $.Field({Static:true , Public:false}, "UuidUri", $.Type);

    $.Field({Static:true , Public:false}, "TelnetUri", $.Type);

    $.Field({Static:true , Public:false}, "LdapUri", $.Type);

    $.Field({Static:true , Public:false}, "NetTcpUri", $.Type);

    $.Field({Static:true , Public:false}, "NetPipeUri", $.Type);

    $.Field({Static:true , Public:false}, "VsMacrosUri", $.Type);

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_QuirksVersion", $asm12.TypeRef("System.UriParser+UriQuirksVersion"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "HttpSyntaxFlags", $asm12.TypeRef("System.UriSyntaxFlags"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "FileSyntaxFlags", $asm12.TypeRef("System.UriSyntaxFlags"));

    $.Property({Static:false, Public:false}, "SchemeName", $.String);

    $.Property({Static:false, Public:false}, "DefaultPort", $.Int32);

    $.Property({Static:true , Public:false}, "ShouldUseLegacyV2Quirks", $.Boolean);

    $.Property({Static:true , Public:false}, "DontEnableStrictRFC3986ReservedCharacterSets", $.Boolean);

    $.Property({Static:true , Public:false}, "DontKeepUnicodeBidiFormattingCharacters", $.Boolean);

    $.Property({Static:false, Public:false}, "Flags", $asm12.TypeRef("System.UriSyntaxFlags"));

    $.Property({Static:false, Public:false}, "IsSimple", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.UriParser+UriQuirksVersion */ 

JSIL.MakeEnum(
  {
    FullName: "System.UriParser+UriQuirksVersion", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    V2: 2, 
    V3: 3, 
  }
);

/* class System.UriParser+BuiltInUriParser */ 

(function BuiltInUriParser$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.UriParser"), 
      Name: "System.UriParser+BuiltInUriParser", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.Int32, 
          $asm12.TypeRef("System.UriSyntaxFlags")
        ])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Uri */ 

(function Uri$Members () {
  var $, $thisType;























































































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Uri", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Uri+Flags"), $asm12.TypeRef("System.UriParser"), 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AllowIdnStatic", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.UriParser"), $asm12.TypeRef("System.Uri+Flags")])
    );

    $.ExternalMethod({Static:true , Public:false}, "CalculateCaseInsensitiveHashCode", 
      new JSIL.MethodSignature($.Int32, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckAuthorityHelper", 
      new JSIL.MethodSignature($.UInt16, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.UInt16, 
          $.UInt16, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.ParsingError")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Uri+Flags")]), $asm12.TypeRef("System.UriParser"), 
          $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckAuthorityHelperHandleAnyHostIri", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $.Int32, $.Boolean, 
          $.Boolean, $asm12.TypeRef("System.UriParser"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Uri+Flags")]), $jsilcore.TypeRef("JSIL.Reference", [$.String]), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.ParsingError")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckAuthorityHelperHandleDnsIri", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.UInt16, 
          $.Int32, $.Int32, 
          $.Boolean, $.Boolean, 
          $asm12.TypeRef("System.UriParser"), $.String, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Uri+Flags")]), $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.String]), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.ParsingError")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckCanonical", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Uri+Check"), [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $jsilcore.TypeRef("JSIL.Reference", [$.UInt16]), 
          $.UInt16, $.Char
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckForConfigLoad", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckForEscapedUnreserved", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckForUnicode", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "CheckKnownSchemes", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Int64]), $.UInt16, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.UriParser")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "CheckSchemeSyntax", 
      new JSIL.MethodSignature($asm12.TypeRef("System.ParsingError"), [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.UInt16, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.UriParser")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Compress", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Char]), [
          $jsilcore.TypeRef("System.Array", [$.Char]), $.UInt16, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $asm12.TypeRef("System.UriParser")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateHelper", 
      new JSIL.MethodSignature($.Type, [
          $.String, $.Boolean, 
          $asm12.TypeRef("System.UriKind"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.UriFormatException")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateHostString", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateHostStringHelper", 
      new JSIL.MethodSignature($.String, [
          $.String, $.UInt16, 
          $.UInt16, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Uri+Flags")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateThis", 
      new JSIL.MethodSignature(null, [
          $.String, $.Boolean, 
          $asm12.TypeRef("System.UriKind")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateUriInfo", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Uri+Flags"))
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureHostString", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureParseRemaining", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureUriInfo", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Uri+UriInfo"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:false}, "EscapeUnescapeIri", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.Int32, $asm12.TypeRef("System.UriComponents")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "FindEndOfComponent", 
      new JSIL.MethodSignature(null, [
          $.String, $jsilcore.TypeRef("JSIL.Reference", [$.UInt16]), 
          $.UInt16, $.Char
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "FindEndOfComponent", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $jsilcore.TypeRef("JSIL.Reference", [$.UInt16]), 
          $.UInt16, $.Char
        ])
    );

    $.ExternalMethod({Static:true , Public:true }, "FromHex", 
      new JSIL.MethodSignature($.Int32, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AbsoluteUri", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_AllowIdn", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_HostType", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Uri+Flags"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_InitializeLock", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_IsAbsoluteUri", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsDosPath", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsImplicitFile", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsNotAbsoluteUri", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsUncOrDosPath", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_OriginalString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_OriginalStringSwitched", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Port", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_SecuredPathIndex", 
      JSIL.MethodSignature.Return($.UInt16)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Syntax", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.UriParser"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_UserDrivenParsing", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCanonicalPath", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Char]), [
          $jsilcore.TypeRef("System.Array", [$.Char]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $asm12.TypeRef("System.UriFormat")
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "GetComponents", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.UriComponents"), $asm12.TypeRef("System.UriFormat")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetComponentsHelper", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.UriComponents"), $asm12.TypeRef("System.UriFormat")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetEscapedParts", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.UriComponents")])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetException", 
      new JSIL.MethodSignature($asm12.TypeRef("System.UriFormatException"), [$asm12.TypeRef("System.ParsingError")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetHostViaCustomSyntax", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetParts", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.UriComponents"), $asm12.TypeRef("System.UriFormat")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetRelativeSerializationString", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.UriFormat")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetUnescapedParts", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.UriComponents"), $asm12.TypeRef("System.UriFormat")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetUriPartsFromUserString", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.UriComponents")])
    );

    $.ExternalMethod({Static:false, Public:false}, "InFact", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Uri+Flags")])
    );

    $.ExternalMethod({Static:false, Public:false}, "InitializeUri", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.ParsingError"), $asm12.TypeRef("System.UriKind"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.UriFormatException")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "InitializeUriConfig", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "IriParsingStatic", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.UriParser")])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsAsciiLetter", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsAsciiLetterOrDigit", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsBidiControlCharacter", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsGenDelim", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:true }, "IsHexDigit", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsIntranet", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsLWS", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:false}, "NotAny", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Uri+Flags")])
    );

    $.ExternalMethod({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type])
    );

    $.ExternalMethod({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type])
    );

    $.ExternalMethod({Static:false, Public:false}, "ParseMinimal", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.UriFormatException"))
    );

    $.ExternalMethod({Static:false, Public:false}, "ParseRemaining", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseScheme", 
      new JSIL.MethodSignature($asm12.TypeRef("System.ParsingError"), [
          $.String, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Uri+Flags")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.UriParser")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseSchemeCheckImplicitFile", 
      new JSIL.MethodSignature($.UInt16, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.UInt16, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.ParsingError")]), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Uri+Flags")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.UriParser")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "PrivateParseMinimal", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.ParsingError"))
    );

    $.ExternalMethod({Static:false, Public:false}, "PrivateParseMinimalIri", 
      new JSIL.MethodSignature(null, [$.String, $.UInt16])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReCreateParts", 
      new JSIL.MethodSignature($.String, [
          $asm12.TypeRef("System.UriComponents"), $.UInt16, 
          $asm12.TypeRef("System.UriFormat")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "SetEscapedDotSlashSettings", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Configuration.UriSectionInternal"), $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "SetUserDrivenParsing", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "StaticInFact", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Uri+Flags"), $asm12.TypeRef("System.Uri+Flags")])
    );

    $.ExternalMethod({Static:true , Public:false}, "StaticIsFile", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.UriParser")])
    );

    $.ExternalMethod({Static:true , Public:false}, "StaticNotAny", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Uri+Flags"), $asm12.TypeRef("System.Uri+Flags")])
    );

    $.ExternalMethod({Static:true , Public:false}, "StripBidiControlCharacter", 
      new JSIL.MethodSignature($.String, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.ISerializable.GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), "GetObjectData");

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:true }, "TryCreate", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $asm12.TypeRef("System.UriKind"), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ])
    );

    $.ExternalMethod({Static:true , Public:true }, "UnescapeDataString", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "UnescapeOnly", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Char, 
          $.Char, $.Char
        ])
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeFile", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeFtp", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeGopher", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeHttp", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeHttps", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "UriSchemeWs", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "UriSchemeWss", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeMailto", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeNews", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeNntp", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeNetTcp", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "UriSchemeNetPipe", $.String);

    $.Field({Static:true , Public:true , ReadOnly:true }, "SchemeDelimiter", $.String, "://");

    $.Field({Static:false, Public:false}, "m_String", $.String);

    $.Field({Static:false, Public:false}, "m_originalUnicodeString", $.String);

    $.Field({Static:false, Public:false}, "m_Syntax", $asm12.TypeRef("System.UriParser"));

    $.Field({Static:false, Public:false}, "m_DnsSafeHost", $.String);

    $.Field({Static:false, Public:false}, "m_Flags", $asm12.TypeRef("System.Uri+Flags"));

    $.Field({Static:false, Public:false}, "m_Info", $asm12.TypeRef("System.Uri+UriInfo"));

    $.Field({Static:false, Public:false}, "m_iriParsing", $.Boolean);

    $.Field({Static:true , Public:false}, "s_ManagerRef", $asm12.TypeRef("Microsoft.Win32.IInternetSecurityManager"), null);

    $.Field({Static:true , Public:false}, "s_IntranetLock", $.Object);

    $.Field({Static:true , Public:false}, "s_ConfigInitialized", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_ConfigInitializing", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_IdnScope", $asm12.TypeRef("System.UriIdnScope"), function ($pi) {
        return $asm12.System.UriIdnScope.None;
      });

    $.Field({Static:true , Public:false}, "s_IriParsing", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_initLock", $.Object);

    $.Field({Static:true , Public:false, ReadOnly:true }, "HexLowerChars", $jsilcore.TypeRef("System.Array", [$.Char]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_WSchars", $jsilcore.TypeRef("System.Array", [$.Char]));

    $.Property({Static:false, Public:false}, "IsImplicitFile", $.Boolean);

    $.Property({Static:false, Public:false}, "IsUncOrDosPath", $.Boolean);

    $.Property({Static:false, Public:false}, "IsDosPath", $.Boolean);

    $.Property({Static:false, Public:false}, "HostType", $asm12.TypeRef("System.Uri+Flags"));

    $.Property({Static:false, Public:false}, "Syntax", $asm12.TypeRef("System.UriParser"));

    $.Property({Static:false, Public:false}, "IsNotAbsoluteUri", $.Boolean);

    $.Property({Static:false, Public:false}, "AllowIdn", $.Boolean);

    $.Property({Static:false, Public:false}, "UserDrivenParsing", $.Boolean);

    $.Property({Static:false, Public:false}, "SecuredPathIndex", $.UInt16);

    $.Property({Static:false, Public:true }, "AbsoluteUri", $.String);

    $.Property({Static:true , Public:false}, "InitializeLock", $.Object);

    $.Property({Static:false, Public:true }, "Port", $.Int32);

    $.Property({Static:false, Public:false}, "OriginalStringSwitched", $.Boolean);

    $.Property({Static:false, Public:true }, "OriginalString", $.String);

    $.Property({Static:false, Public:true }, "IsAbsoluteUri", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Runtime.Serialization.ISerializable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Uri+Flags */ 

JSIL.MakeEnum(
  {
    FullName: "System.Uri+Flags", 
    BaseType: $asm0F.TypeRef("System.UInt64"), 
    IsPublic: false, 
    IsFlags: true, 
  }, 
  {
    HostNotParsed: 0, 
    Zero: 0, 
    SchemeNotCanonical: 1, 
    UserNotCanonical: 2, 
    HostNotCanonical: 4, 
    PortNotCanonical: 8, 
    PathNotCanonical: 16, 
    QueryNotCanonical: 32, 
    FragmentNotCanonical: 64, 
    CannotDisplayCanonical: 127, 
    E_UserNotCanonical: 128, 
    E_HostNotCanonical: 256, 
    E_PortNotCanonical: 512, 
    E_PathNotCanonical: 1024, 
    E_QueryNotCanonical: 2048, 
    E_FragmentNotCanonical: 4096, 
    E_CannotDisplayCanonical: 8064, 
    ShouldBeCompressed: 8192, 
    FirstSlashAbsent: 16384, 
    BackslashInPath: 32768, 
    IndexMask: 65535, 
    IPv6HostType: 65536, 
    IPv4HostType: 131072, 
    DnsHostType: 196608, 
    UncHostType: 262144, 
    BasicHostType: 327680, 
    UnusedHostType: 393216, 
    UnknownHostType: 458752, 
    HostTypeMask: 458752, 
    UserEscaped: 524288, 
    AuthorityFound: 1048576, 
    HasUserInfo: 2097152, 
    LoopbackHost: 4194304, 
    NotDefaultPort: 8388608, 
    UserDrivenParsing: 16777216, 
    CanonicalDnsHost: 33554432, 
    ErrorOrParsingRecursion: 67108864, 
    DosPath: 134217728, 
    UncPath: 268435456, 
    ImplicitFile: 536870912, 
    MinimalUriInfoSet: 1073741824, 
    AllUriInfoSet: 2147483648, 
    IdnHost: 4294967296, 
    HasUnicode: 8589934592, 
    HostUnicodeNormalized: 17179869184, 
    RestUnicodeNormalized: 34359738368, 
    UnicodeHost: 68719476736, 
    IntranetUri: 137438953472, 
    UseOrigUncdStrOffset: 274877906944, 
    UserIriCanonical: 549755813888, 
    PathIriCanonical: 1099511627776, 
    QueryIriCanonical: 2199023255552, 
    FragmentIriCanonical: 4398046511104, 
    IriCanonical: 8246337208320, 
  }
);

/* class System.Uri+UriInfo */ 

(function UriInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Uri+UriInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "Host", $.String);

    $.Field({Static:false, Public:true }, "ScopeId", $.String);

    $.Field({Static:false, Public:true }, "Offset", $asm12.TypeRef("System.Uri+Offset"));

    $.Field({Static:false, Public:true }, "DnsSafeHost", $.String);

    $.Field({Static:false, Public:true }, "MoreInfo", $asm12.TypeRef("System.Uri+MoreInfo"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Uri+Offset */ 

(function Offset$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Uri+Offset", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
      Pack: 1, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "Scheme", $.UInt16);

    $.Field({Static:false, Public:true }, "User", $.UInt16);

    $.Field({Static:false, Public:true }, "Host", $.UInt16);

    $.Field({Static:false, Public:true }, "PortValue", $.UInt16);

    $.Field({Static:false, Public:true }, "Path", $.UInt16);

    $.Field({Static:false, Public:true }, "Query", $.UInt16);

    $.Field({Static:false, Public:true }, "Fragment", $.UInt16);

    $.Field({Static:false, Public:true }, "End", $.UInt16);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Uri+MoreInfo */ 

(function MoreInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Uri+MoreInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );
    ; 
    ; 
    ; 

    $.Field({Static:false, Public:true }, "AbsoluteUri", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Uri+Check */ 

JSIL.MakeEnum(
  {
    FullName: "System.Uri+Check", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: true, 
  }, 
  {
    None: 0, 
    EscapedCanonical: 1, 
    DisplayCanonical: 2, 
    DotSlashAttn: 4, 
    FoundNonAscii: 8, 
    BackslashInPath: 16, 
    ReservedFound: 32, 
    NotIriCanonical: 64, 
    DotSlashEscaped: 128, 
  }
);

/* class System.UriFormatException */ 

(function UriFormatException$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.FormatException"), 
      Name: "System.UriFormatException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.ISerializable.GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), "GetObjectData");

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.DomainNameHelper */ 

(function DomainNameHelper$Members () {
  var $, $thisType;












  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.DomainNameHelper", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "IdnEquivalent", 
      new JSIL.MethodSignature($.String, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IdnEquivalent", 
      new JSIL.MethodSignature($.String, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsASCIILetterOrDigit", 
      new JSIL.MethodSignature($.Boolean, [$.Char, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsIdnAce", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsIdnAce", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsValid", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.UInt16, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsValidByIri", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.UInt16, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsValidDomainLabelCharacter", 
      new JSIL.MethodSignature($.Boolean, [$.Char, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseCanonicalName", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "UnicodeEquivalent", 
      new JSIL.MethodSignature($.String, [
          $.String, $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "UnicodeEquivalent", 
      new JSIL.MethodSignature($.String, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])
        ])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IPv4AddressHelper */ 

(function IPv4AddressHelper$Members () {
  var $, $thisType;








  JSIL.MakeStaticClass("System.IPv4AddressHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "IsValid", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Boolean, 
          $.Boolean, $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsValidCanonical", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Boolean, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Parse", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $jsilcore.TypeRef("JSIL.Pointer", [$.Byte]), 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseCanonical", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $jsilcore.TypeRef("JSIL.Pointer", [$.Byte]), 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseCanonicalName", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseHostNumber", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseNonCanonical", 
      new JSIL.MethodSignature($.Int64, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Boolean
        ])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IPv6AddressHelper */ 

(function IPv6AddressHelper$Members () {
  var $, $thisType;









  JSIL.MakeStaticClass("System.IPv6AddressHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CreateCanonicalName", 
      new JSIL.MethodSignature($.String, [$jsilcore.TypeRef("JSIL.Pointer", [$.UInt16])])
    );

    $.ExternalMethod({Static:true , Public:false}, "FindCompressionRange", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.Int32, $.Int32]), [$jsilcore.TypeRef("JSIL.Pointer", [$.UInt16])])
    );

    $.ExternalMethod({Static:true , Public:false}, "InternalIsValid", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsValid", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsValidStrict", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Parse", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $jsilcore.TypeRef("JSIL.Pointer", [$.UInt16]), 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseCanonicalName", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ShouldHaveIpv4Embedded", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Pointer", [$.UInt16])])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.UncNameHelper */ 

(function UncNameHelper$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.UncNameHelper", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "IsValid", 
      new JSIL.MethodSignature($.Boolean, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.UInt16, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseCanonicalName", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Int32, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])
        ])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.UriSyntaxFlags */ 

JSIL.MakeEnum(
  {
    FullName: "System.UriSyntaxFlags", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: true, 
  }, 
  {
    None: 0, 
    MustHaveAuthority: 1, 
    OptionalAuthority: 2, 
    MayHaveUserInfo: 4, 
    MayHavePort: 8, 
    MayHavePath: 16, 
    MayHaveQuery: 32, 
    MayHaveFragment: 64, 
    AllowEmptyHost: 128, 
    AllowUncHost: 256, 
    AllowDnsHost: 512, 
    AllowIPv4Host: 1024, 
    AllowIPv6Host: 2048, 
    AllowAnInternetHost: 3584, 
    AllowAnyOtherHost: 4096, 
    FileLikeUri: 8192, 
    MailToLikeUri: 16384, 
    V1_UnknownUri: 65536, 
    SimpleUserSyntax: 131072, 
    BuiltInSyntax: 262144, 
    ParserSchemeOnly: 524288, 
    AllowDOSPath: 1048576, 
    PathIsRooted: 2097152, 
    ConvertPathSlashes: 4194304, 
    CompressPath: 8388608, 
    CanonicalizeAsFilePath: 16777216, 
    UnEscapeDotsAndSlashes: 33554432, 
    AllowIdn: 67108864, 
    AllowIriParsing: 268435456, 
  }
);

/* enum System.UriKind */ 

JSIL.MakeEnum(
  {
    FullName: "System.UriKind", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    RelativeOrAbsolute: 0, 
    Absolute: 1, 
    Relative: 2, 
  }
);

/* enum System.UriComponents */ 

JSIL.MakeEnum(
  {
    FullName: "System.UriComponents", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    SerializationInfoString: -2147483648, 
    Scheme: 1, 
    UserInfo: 2, 
    Host: 4, 
    Port: 8, 
    SchemeAndServer: 13, 
    Path: 16, 
    Query: 32, 
    PathAndQuery: 48, 
    HttpRequestUrl: 61, 
    Fragment: 64, 
    AbsoluteUri: 127, 
    StrongPort: 128, 
    HostAndPort: 132, 
    StrongAuthority: 134, 
    NormalizedHost: 256, 
    KeepDelimiter: 1073741824, 
  }
);

/* enum System.UriFormat */ 

JSIL.MakeEnum(
  {
    FullName: "System.UriFormat", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    UriEscaped: 1, 
    Unescaped: 2, 
    SafeUnescaped: 3, 
  }
);

/* enum System.UriIdnScope */ 

JSIL.MakeEnum(
  {
    FullName: "System.UriIdnScope", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    None: 0, 
    AllExceptIntranet: 1, 
    All: 2, 
  }
);

/* enum System.ParsingError */ 

JSIL.MakeEnum(
  {
    FullName: "System.ParsingError", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    None: 0, 
    BadFormat: 1, 
    BadScheme: 2, 
    BadAuthority: 3, 
    EmptyUriString: 4, 
    LastRelativeUriOkErrIndex: 4, 
    SchemeLimit: 5, 
    SizeLimit: 6, 
    MustRootedPath: 7, 
    BadHostName: 8, 
    NonEmptyHost: 9, 
    BadPort: 10, 
    BadAuthorityTerminator: 11, 
    CannotCreateRelative: 12, 
  }
);

/* enum System.UnescapeMode */ 

JSIL.MakeEnum(
  {
    FullName: "System.UnescapeMode", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: true, 
  }, 
  {
    CopyOnly: 0, 
    Escape: 1, 
    Unescape: 2, 
    EscapeUnescape: 3, 
    V1ToStringFlag: 4, 
    UnescapeAll: 8, 
    UnescapeAllOrThrow: 24, 
  }
);

/* class System.IriHelper */ 

(function IriHelper$Members () {
  var $, $thisType;





  JSIL.MakeStaticClass("System.IriHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CheckIriUnicodeRange", 
      new JSIL.MethodSignature($.Boolean, [$.Char, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "CheckIriUnicodeRange", 
      new JSIL.MethodSignature($.Boolean, [
          $.Char, $.Char, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "CheckIsReserved", 
      new JSIL.MethodSignature($.Boolean, [$.Char, $asm12.TypeRef("System.UriComponents")])
    );

    $.ExternalMethod({Static:true , Public:false}, "EscapeUnescapeIri", 
      new JSIL.MethodSignature($.String, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.UriComponents")
        ])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.UriHelper */ 

(function UriHelper$Members () {
  var $, $thisType;












  JSIL.MakeStaticClass("System.UriHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "EnsureDestinationSize", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Char]), [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $jsilcore.TypeRef("System.Array", [$.Char]), 
          $.Int32, $.Int16, 
          $.Int16, $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "EscapeAsciiChar", 
      new JSIL.MethodSignature(null, [
          $.Char, $jsilcore.TypeRef("System.Array", [$.Char]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "EscapedAscii", 
      new JSIL.MethodSignature($.Char, [$.Char, $.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "EscapeString", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Char]), [
          $.String, $.Int32, 
          $.Int32, $jsilcore.TypeRef("System.Array", [$.Char]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Boolean, 
          $.Char, $.Char, 
          $.Char
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Is3986Unreserved", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsNotSafeForUnescape", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsReservedUnreservedOrHash", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsUnreserved", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "MatchUTF8Sequence", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $jsilcore.TypeRef("System.Array", [$.Char]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("System.Array", [$.Char]), 
          $.Int32, $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $.Int32, $.Boolean, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "UnescapeString", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Char]), [
          $.String, $.Int32, 
          $.Int32, $jsilcore.TypeRef("System.Array", [$.Char]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Char, 
          $.Char, $.Char, 
          $asm12.TypeRef("System.UnescapeMode"), $asm12.TypeRef("System.UriParser"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "UnescapeString", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Char]), [
          $jsilcore.TypeRef("JSIL.Pointer", [$.Char]), $.Int32, 
          $.Int32, $jsilcore.TypeRef("System.Array", [$.Char]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Char, 
          $.Char, $.Char, 
          $asm12.TypeRef("System.UnescapeMode"), $asm12.TypeRef("System.UriParser"), 
          $.Boolean
        ])
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "HexUpperChars", $jsilcore.TypeRef("System.Array", [$.Char]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.GenericUriParserOptions */ 

JSIL.MakeEnum(
  {
    FullName: "System.GenericUriParserOptions", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    Default: 0, 
    GenericAuthority: 1, 
    AllowEmptyAuthority: 2, 
    NoUserInfo: 4, 
    NoPort: 8, 
    NoQuery: 16, 
    NoFragment: 32, 
    DontConvertPathBackslashes: 64, 
    DontCompressPath: 128, 
    DontUnescapePathDotsAndSlashes: 256, 
    Idn: 512, 
    IriParsing: 1024, 
  }
);

/* class System.SecurityUtils */ 

(function SecurityUtils$Members () {
  var $, $thisType;






  JSIL.MakeStaticClass("System.SecurityUtils", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "ConstructorInfoInvoke", 
      new JSIL.MethodSignature($.Object, [$asm0F.TypeRef("System.Reflection.ConstructorInfo"), $jsilcore.TypeRef("System.Array", [$.Object])])
    );

    $.ExternalMethod({Static:true , Public:false}, "DemandGrantSet", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Assembly"))
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "DemandReflectionAccess", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Type"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_MemberAccessPermission", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.Permissions.ReflectionPermission"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_RestrictedMemberAccessPermission", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.Permissions.ReflectionPermission"))
    );

    $.Field({Static:true , Public:false}, "memberAccessPermission", $asm0F.TypeRef("System.Security.Permissions.ReflectionPermission"));

    $.Field({Static:true , Public:false}, "restrictedMemberAccessPermission", $asm0F.TypeRef("System.Security.Permissions.ReflectionPermission"));

    $.Property({Static:true , Public:false}, "MemberAccessPermission", $asm0F.TypeRef("System.Security.Permissions.ReflectionPermission"));

    $.Property({Static:true , Public:false}, "RestrictedMemberAccessPermission", $asm0F.TypeRef("System.Security.Permissions.ReflectionPermission"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.EnvironmentHelpers */ 

(function EnvironmentHelpers$Members () {
  var $, $thisType;



  JSIL.MakeStaticClass("System.EnvironmentHelpers", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "get_IsAppContainerProcess", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "HasAppContainerToken", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.Field({Static:true , Public:false}, "s_IsAppContainerProcess", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_IsAppContainerProcessInitalized", $asm0F.TypeRef("System.Boolean"));

    $.Property({Static:true , Public:true }, "IsAppContainerProcess", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.LocalAppContext */ 

(function LocalAppContext$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0F.System.Boolean)) ();
  };



  function LocalAppContext_get_DisableCaching () {
    return $thisType.LocalAppContext$DisableCaching$value;
  }; 





  function LocalAppContext_set_DisableCaching (value) {
    $thisType.LocalAppContext$DisableCaching$value = value;
  }; 


  JSIL.MakeStaticClass("System.LocalAppContext", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "DefineSwitchDefault", 
      new JSIL.MethodSignature(null, [$.String, $.Boolean])
    );

    $.Method({Static:true , Public:false}, "get_DisableCaching", 
      JSIL.MethodSignature.Return($.Boolean), 
      LocalAppContext_get_DisableCaching
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "GetCachedSwitchValue", 
      new JSIL.MethodSignature($.Boolean, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$.Int32])])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetCachedSwitchValueInternal", 
      new JSIL.MethodSignature($.Boolean, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$.Int32])])
    );

    $.ExternalMethod({Static:true , Public:true }, "IsSwitchEnabled", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsSwitchEnabledLocal", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.Method({Static:true , Public:false}, "set_DisableCaching", 
      JSIL.MethodSignature.Action($.Boolean), 
      LocalAppContext_set_DisableCaching
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "SetupDelegate", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:true , Public:false}, "TryGetSwitchFromCentralAppContext", $asm12.TypeRef("System.LocalAppContext+TryGetSwitchDelegate"));

    $.Field({Static:true , Public:false}, "s_canForwardCalls", $.Boolean);

    $.Field({Static:true , Public:false}, "s_switchMap", $asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.Boolean]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_syncLock", $.Object);

    $.Field({Static:true , Public:false}, "LocalAppContext$DisableCaching$value", $.Boolean)
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Property({Static:true , Public:false}, "DisableCaching", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate System.LocalAppContext+TryGetSwitchDelegate */ 

JSIL.MakeDelegate("System.LocalAppContext+TryGetSwitchDelegate", false, [], 
  new JSIL.MethodSignature($asm0F.TypeRef("System.Boolean"), [$asm0F.TypeRef("System.String"), $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Boolean")])]));

/* class System.SR */ 

(function SR$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.SR", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "get_Culture", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Globalization.CultureInfo"))
    );

    $.ExternalMethod({Static:true , Public:false}, "GetLoader", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:true , Public:true }, "GetString", 
      new JSIL.MethodSignature($.String, [$.String, $jsilcore.TypeRef("System.Array", [$.Object])])
    )
      .Parameter(1, "args", function (_) {
          _.Attribute($asm0F.TypeRef("System.ParamArrayAttribute"))
        });

    $.ExternalMethod({Static:true , Public:true }, "GetString", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.Field({Static:true , Public:false}, "loader", $.Type);

    $.Field({Static:false, Public:false}, "resources", $asm0F.TypeRef("System.Resources.ResourceManager"));

    $.Property({Static:true , Public:false}, "Culture", $asm0F.TypeRef("System.Globalization.CultureInfo"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Configuration");
/* class System.Configuration.SchemeSettingElement */ 

(function SchemeSettingElement$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Configuration.SchemeSettingElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_GenericUriParserOptions", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.GenericUriParserOptions"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "$name", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "genericUriParserOptions", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "Name", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["name"]; });

    $.Property({Static:false, Public:true }, "GenericUriParserOptions", $asm12.TypeRef("System.GenericUriParserOptions"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["genericUriParserOptions"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.SchemeSettingInternal */ 

(function SchemeSettingInternal$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Configuration.SchemeSettingInternal", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm12.TypeRef("System.GenericUriParserOptions")])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Options", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.GenericUriParserOptions"))
    );

    $.Field({Static:false, Public:false}, "$name", $.String);

    $.Field({Static:false, Public:false}, "options", $asm12.TypeRef("System.GenericUriParserOptions"));

    $.Property({Static:false, Public:true }, "Name", $.String);

    $.Property({Static:false, Public:true }, "Options", $asm12.TypeRef("System.GenericUriParserOptions"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.SchemeSettingElementCollection */ 

(function SchemeSettingElementCollection$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElementCollection"), 
      Name: "System.Configuration.SchemeSettingElementCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "CreateNewElement", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CollectionType", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetElementKey", 
      new JSIL.MethodSignature($.Object, [$asm14.TypeRef("System.Configuration.ConfigurationElement")])
    );

    $.Property({Static:false, Public:true , Virtual:true }, "CollectionType", $asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm14.TypeRef("System.Configuration.ConfigurationCollectionAttribute"), function () { return [$asm12.System.Configuration.SchemeSettingElement.__Type__]; });

})();

/* class System.Configuration.UriSectionData */ 

(function UriSectionData$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Configuration.UriSectionData", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_IdnScope", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Nullable`1", [$asm12.TypeRef("System.UriIdnScope")]))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_IriParsing", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Nullable`1", [$.Boolean]))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SchemeSettings", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $asm12.TypeRef("System.Configuration.SchemeSettingInternal")]))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_IdnScope", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Nullable`1", [$asm12.TypeRef("System.UriIdnScope")]))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_IriParsing", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Nullable`1", [$.Boolean]))
    );

    $.Field({Static:false, Public:false}, "idnScope", $asm0F.TypeRef("System.Nullable`1", [$asm12.TypeRef("System.UriIdnScope")]));

    $.Field({Static:false, Public:false}, "iriParsing", $asm0F.TypeRef("System.Nullable`1", [$.Boolean]));

    $.Field({Static:false, Public:false}, "schemeSettings", $asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $asm12.TypeRef("System.Configuration.SchemeSettingInternal")]));

    $.Property({Static:false, Public:true }, "IdnScope", $asm0F.TypeRef("System.Nullable`1", [$asm12.TypeRef("System.UriIdnScope")]));

    $.Property({Static:false, Public:true }, "IriParsing", $asm0F.TypeRef("System.Nullable`1", [$.Boolean]));

    $.Property({Static:false, Public:true }, "SchemeSettings", $asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $asm12.TypeRef("System.Configuration.SchemeSettingInternal")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.UriSectionReader */ 

(function UriSectionReader$Members () {
  var $, $thisType;















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Configuration.UriSectionReader", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm12.TypeRef("System.Configuration.UriSectionData")])
    );

    $.ExternalMethod({Static:true , Public:false}, "AreEqual", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "ClearSchemeSetting", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GetSectionData", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Configuration.UriSectionData"))
    );

    $.ExternalMethod({Static:false, Public:false}, "IsEndElement", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:true }, "Read", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Configuration.UriSectionData"), [$.String])
    );

    $.ExternalMethod({Static:true , Public:true }, "Read", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Configuration.UriSectionData"), [$.String, $asm12.TypeRef("System.Configuration.UriSectionData")])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadAddSchemeSetting", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadConfiguration", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadIdnScope", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadIriParsing", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadRemoveSchemeSetting", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadSchemeSettings", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadToUriSection", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:false, Public:false}, "configFilePath", $.String);

    $.Field({Static:false, Public:false}, "reader", $asm24.TypeRef("System.Xml.XmlReader"));

    $.Field({Static:false, Public:false}, "sectionData", $asm12.TypeRef("System.Configuration.UriSectionData"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.UriSection */ 

(function UriSection$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationSection"), 
      Name: "System.Configuration.UriSection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_Idn", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Configuration.IdnElement"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_IriParsing", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Configuration.IriParsingElement"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SchemeSettings", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Configuration.SchemeSettingElementCollection"))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "idn", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "iriParsing", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "schemeSettings", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "Idn", $asm12.TypeRef("System.Configuration.IdnElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["idn"]; });

    $.Property({Static:false, Public:true }, "IriParsing", $asm12.TypeRef("System.Configuration.IriParsingElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["iriParsing"]; });

    $.Property({Static:false, Public:true }, "SchemeSettings", $asm12.TypeRef("System.Configuration.SchemeSettingElementCollection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["schemeSettings"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.UriSectionInternal */ 

(function UriSectionInternal$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Configuration.UriSectionInternal", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Configuration.UriSection"))
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.UriIdnScope"), $.Boolean, 
          $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm12.TypeRef("System.Configuration.SchemeSettingInternal")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IdnScope", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.UriIdnScope"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IriParsing", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetSchemeSetting", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Configuration.SchemeSettingInternal"), [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetSection", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:true , Public:false}, "IsWebConfig", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "LoadUsingCustomParser", 
      new JSIL.MethodSignature($.Type, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "LoadUsingSystemConfiguration", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "classSyncObject", $.Object);

    $.Field({Static:false, Public:false}, "idnScope", $asm12.TypeRef("System.UriIdnScope"));

    $.Field({Static:false, Public:false}, "iriParsing", $.Boolean);

    $.Field({Static:false, Public:false}, "schemeSettings", $asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $asm12.TypeRef("System.Configuration.SchemeSettingInternal")]));

    $.Property({Static:false, Public:false}, "IdnScope", $asm12.TypeRef("System.UriIdnScope"));

    $.Property({Static:false, Public:false}, "IriParsing", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.IriParsingElement */ 

(function IriParsingElement$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Configuration.IriParsingElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_Enabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "enabled", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true }, "Enabled", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["enabled"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.IdnElement */ 

(function IdnElement$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Configuration.IdnElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_Enabled", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.UriIdnScope"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "enabled", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true }, "Enabled", $asm12.TypeRef("System.UriIdnScope"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["enabled"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.ConfigurationManagerInternalFactory */ 

(function ConfigurationManagerInternalFactory$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.Configuration.ConfigurationManagerInternalFactory", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "get_Instance", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.Internal.IConfigurationManagerInternal"))
    );

    $.Field({Static:true , Public:false}, "s_instance", $asm14.TypeRef("System.Configuration.Internal.IConfigurationManagerInternal"));

    $.Property({Static:true , Public:false}, "Instance", $asm14.TypeRef("System.Configuration.Internal.IConfigurationManagerInternal"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.TypeUtil */ 

(function TypeUtil$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.Configuration.TypeUtil", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CreateInstanceWithReflectionPermission", 
      new JSIL.MethodSignature($.Object, [$.String])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Configuration.PrivilegedConfigurationManager */ 

(function PrivilegedConfigurationManager$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.Configuration.PrivilegedConfigurationManager", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "GetSection", 
      new JSIL.MethodSignature($.Object, [$.String])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Net");
/* class System.Net.CertPolicyValidationCallback */ 

(function CertPolicyValidationCallback$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.CertPolicyValidationCallback", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.ServerCertValidationCallback */ 

(function ServerCertValidationCallback$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.ServerCertValidationCallback", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Dns */ 

(function Dns$Members () {
  var $, $thisType;













  JSIL.MakeStaticClass("System.Net.Dns", true, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CompareHosts", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetAddrInfo", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.IPHostEntry"), [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetUnresolveAnswer", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.IPHostEntry"), [$asm12.TypeRef("System.Net.IPAddress")])
    );

    $.ExternalMethod({Static:true , Public:false}, "InternalGetHostByAddress", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.IPHostEntry"), [$asm12.TypeRef("System.Net.IPAddress"), $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "InternalGetHostByName", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.IPHostEntry"), [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "NativeToHostEntry", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.IPHostEntry"), [$.IntPtr])
    );

    $.ExternalMethod({Static:true , Public:false}, "ResolveCallback", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:true , Public:false}, "TryGetAddrInfo", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [$.String, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.IPHostEntry")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "TryGetAddrInfo", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $.String, $asm12.TypeRef("System.Net.AddressInfoHints"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.IPHostEntry")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "TryGetNameInfo", 
      new JSIL.MethodSignature($.String, [$asm12.TypeRef("System.Net.IPAddress"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketError")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "TryInternalResolve", 
      new JSIL.MethodSignature($.Boolean, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.IPHostEntry")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "TryNormalizeHost", 
      new JSIL.MethodSignature($.Boolean, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$.String])])
    );

    $.Field({Static:true , Public:false}, "s_DnsPermission", $asm12.TypeRef("System.Net.DnsPermission"));

    $.Field({Static:true , Public:false}, "resolveCallback", $asm0F.TypeRef("System.Threading.WaitCallback"), function ($pi) {
        return $asm0F.System.Threading.WaitCallback.New(null, null, new JSIL.MethodPointerInfo($thisType, "ResolveCallback", JSIL.MethodSignature.Action($.Object), true, false));
      });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.LazyAsyncResult */ 

(function LazyAsyncResult$Members () {
  var $, $thisType;

























  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.LazyAsyncResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $asm0F.TypeRef("System.AsyncCallback")
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Cleanup", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Complete", 
      JSIL.MethodSignature.Action($.IntPtr)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_AsyncCallback", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.AsyncCallback"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_AsyncObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_AsyncState", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_AsyncWaitHandle", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Threading.WaitHandle"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CompletedSynchronously", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_CurrentThreadContext", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.LazyAsyncResult+ThreadContext"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_EndCalled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_ErrorCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_InternalPeekCompleted", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsCompleted", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalWaitForCompletion", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "InvokeCallback", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "InvokeCallback", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "LazilyCreateEvent", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Threading.ManualResetEvent")])])
    );

    $.ExternalMethod({Static:false, Public:false}, "ProtectedInvokeCallback", 
      new JSIL.MethodSignature(null, [$.Object, $.IntPtr])
    );

    $.ExternalMethod({Static:false, Public:false}, "set_AsyncCallback", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.AsyncCallback"))
    );

    $.ExternalMethod({Static:false, Public:false}, "set_EndCalled", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_ErrorCode", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Result", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "WaitForCompletion", 
      new JSIL.MethodSignature($.Object, [$.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "WorkerThreadComplete", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.Field({Static:true , Public:false}, "t_ThreadContext", $asm12.TypeRef("System.Net.LazyAsyncResult+ThreadContext"));

    $.Field({Static:false, Public:false}, "m_AsyncObject", $.Object);

    $.Field({Static:false, Public:false}, "m_AsyncState", $.Object);

    $.Field({Static:false, Public:false}, "m_AsyncCallback", $asm0F.TypeRef("System.AsyncCallback"));

    $.Field({Static:false, Public:false}, "m_Result", $.Object);

    $.Field({Static:false, Public:false}, "m_ErrorCode", $.Int32);

    $.Field({Static:false, Public:false}, "m_IntCompleted", $.Int32);

    $.Field({Static:false, Public:false}, "m_EndCalled", $.Boolean);

    $.Field({Static:false, Public:false}, "m_UserEvent", $.Boolean);

    $.Field({Static:false, Public:false}, "m_Event", $.Object);

    $.Property({Static:true , Public:false}, "CurrentThreadContext", $asm12.TypeRef("System.Net.LazyAsyncResult+ThreadContext"));

    $.Property({Static:false, Public:false}, "AsyncObject", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "AsyncState", $.Object);

    $.Property({Static:false, Public:false}, "AsyncCallback", $asm0F.TypeRef("System.AsyncCallback"));

    $.Property({Static:false, Public:true , Virtual:true }, "AsyncWaitHandle", $asm0F.TypeRef("System.Threading.WaitHandle"));

    $.Property({Static:false, Public:true , Virtual:true }, "CompletedSynchronously", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "IsCompleted", $.Boolean);

    $.Property({Static:false, Public:false}, "InternalPeekCompleted", $.Boolean);

    $.Property({Static:false, Public:false}, "Result", $.Object);

    $.Property({Static:false, Public:false}, "EndCalled", $.Boolean);

    $.Property({Static:false, Public:false}, "ErrorCode", $.Int32);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IAsyncResult")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.LazyAsyncResult+ThreadContext */ 

(function ThreadContext$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.LazyAsyncResult+ThreadContext", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "m_NestedIOCount", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.ContextAwareResult */ 

(function ContextAwareResult$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.LazyAsyncResult"), 
      Name: "System.Net.ContextAwareResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 6, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $asm0F.TypeRef("System.AsyncCallback")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.Boolean, 
          $.Object, $.Object, 
          $asm0F.TypeRef("System.AsyncCallback")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.Boolean, 
          $.Boolean, $.Object, 
          $.Object, $asm0F.TypeRef("System.AsyncCallback")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CaptureOrComplete", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Threading.ExecutionContext")]), $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Cleanup", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Complete", 
      JSIL.MethodSignature.Action($.IntPtr)
    );

    $.ExternalMethod({Static:false, Public:false}, "CompleteCallback", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "FinishPostingAsyncOp", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.CallbackClosure")])])
    );

    $.ExternalMethod({Static:false, Public:false}, "SafeCaptureIdenity", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "StartPostingAsyncOp", 
      new JSIL.MethodSignature($.Object, [$.Boolean])
    );

    $.Field({Static:false, Public:false}, "_Context", $asm0F.TypeRef("System.Threading.ExecutionContext"));

    $.Field({Static:false, Public:false}, "_Lock", $.Object);

    $.Field({Static:false, Public:false}, "_Flags", $asm12.TypeRef("System.Net.ContextAwareResult+StateFlags"));

    $.Field({Static:false, Public:false}, "_Wi", $asm0F.TypeRef("System.Security.Principal.WindowsIdentity"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.ContextAwareResult+StateFlags */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.ContextAwareResult+StateFlags", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: true, 
  }, 
  {
    None: 0, 
    CaptureIdentity: 1, 
    CaptureContext: 2, 
    ThreadSafeContextCopy: 4, 
    PostBlockStarted: 8, 
    PostBlockFinished: 16, 
  }
);

/* class System.Net.Dns+ResolveAsyncResult */ 

(function ResolveAsyncResult$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.ContextAwareResult"), 
      Name: "System.Net.Dns+ResolveAsyncResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 5, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false, ReadOnly:true }, "hostName", $.String);

    $.Field({Static:false, Public:false}, "includeIPv6", $.Boolean);

    $.Field({Static:false, Public:false}, "address", $asm12.TypeRef("System.Net.IPAddress"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.DnsPermission */ 

(function DnsPermission$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Security.CodeAccessPermission"), 
      Name: "System.Net.DnsPermission", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Security.Permissions.PermissionState"))
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Copy", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.IPermission"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "FromXml", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Security.SecurityElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Intersect", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Security.IPermission"), [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IsSubsetOf", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IsUnrestricted", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ToXml", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.SecurityElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Union", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Security.IPermission"), [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.Field({Static:false, Public:false}, "m_noRestriction", $.Boolean);

    $.ImplementInterfaces(
      /* 3 */ $asm0F.TypeRef("System.Security.Permissions.IUnrestrictedPermission")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.EndPoint */ 

(function EndPoint$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.EndPoint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Create", 
      new JSIL.MethodSignature($.Type, [$asm12.TypeRef("System.Net.SocketAddress")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_AddressFamily", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.AddressFamily"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Serialize", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.SocketAddress"))
    );

    $.Property({Static:false, Public:true , Virtual:true }, "AddressFamily", $asm12.TypeRef("System.Net.Sockets.AddressFamily"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.IntPtrHelper */ 

(function IntPtrHelper$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.Net.IntPtrHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "Add", 
      new JSIL.MethodSignature($.IntPtr, [$.IntPtr, $.Int32])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.NclUtilities */ 

(function NclUtilities$Members () {
  var $, $thisType;



  JSIL.MakeStaticClass("System.Net.NclUtilities", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "get_HasShutdownStarted", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "IsFatal", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Exception")])
    );

    $.Property({Static:true , Public:false}, "HasShutdownStarted", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.NclConstants */ 

(function NclConstants$Members () {
  var $, $thisType;

  JSIL.MakeStaticClass("System.Net.NclConstants", false, [], function ($ib) {
    $ = $ib;

    $.Field({Static:true , Public:false, ReadOnly:true }, "Sentinel", $.Object);

    $.Field({Static:true , Public:false, ReadOnly:true }, "EmptyObjectArray", $jsilcore.TypeRef("System.Array", [$.Object]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Object, 0);
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "EmptyUriArray", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Uri")]), function ($pi) {
        return JSIL.Array.New($asm12.System.Uri, 0);
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "CRLF", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "ChunkTerminator", $jsilcore.TypeRef("System.Array", [$.Byte]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.NetworkAddressChangePolled */ 

(function NetworkAddressChangePolled$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.NetworkAddressChangePolled", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "disposed", $.Boolean);

    $.Field({Static:false, Public:false}, "ipv4Socket", $asm12.TypeRef("System.Net.SafeCloseSocketAndEvent"));

    $.Field({Static:false, Public:false}, "ipv6Socket", $asm12.TypeRef("System.Net.SafeCloseSocketAndEvent"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.ComNetOS */ 

(function ComNetOS$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.Net.ComNetOS", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "GetWindowsInstallType", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.WindowsInstallationType"))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "IsAspNetServer", $.Boolean);

    $.Field({Static:true , Public:false, ReadOnly:true }, "IsWin7orLater", $.Boolean);

    $.Field({Static:true , Public:false, ReadOnly:true }, "IsWin7Sp1orLater", $.Boolean);

    $.Field({Static:true , Public:false, ReadOnly:true }, "IsWin8orLater", $.Boolean);

    $.Field({Static:true , Public:false, ReadOnly:true }, "InstallationType", $asm12.TypeRef("System.Net.WindowsInstallationType"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.ValidationHelper */ 

(function ValidationHelper$Members () {
  var $, $thisType;




  JSIL.MakeStaticClass("System.Net.ValidationHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "HashString", 
      new JSIL.MethodSignature($.String, [$.Object])
    );

    $.ExternalMethod({Static:true , Public:true }, "IsBlankString", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:true }, "ValidateTcpPort", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.Field({Static:true , Public:true }, "EmptyArray", $jsilcore.TypeRef("System.Array", [$.String]), function ($pi) {
        return JSIL.Array.New($asm0F.System.String, 0);
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "InvalidMethodChars", $jsilcore.TypeRef("System.Array", [$.Char]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "InvalidParamChars", $jsilcore.TypeRef("System.Array", [$.Char]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.ExceptionHelper */ 

(function ExceptionHelper$Members () {
  var $, $thisType;



  JSIL.MakeStaticClass("System.Net.ExceptionHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "get_MethodNotImplementedException", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.NotImplementedException"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_PropertyNotImplementedException", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.NotImplementedException"))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "KeyContainerPermissionOpen", $asm0F.TypeRef("System.Security.Permissions.KeyContainerPermission"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "WebPermissionUnrestricted", $asm12.TypeRef("System.Net.WebPermission"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "UnmanagedPermission", $asm0F.TypeRef("System.Security.Permissions.SecurityPermission"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "UnrestrictedSocketPermission", $asm12.TypeRef("System.Net.SocketPermission"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "InfrastructurePermission", $asm0F.TypeRef("System.Security.Permissions.SecurityPermission"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "ControlPolicyPermission", $asm0F.TypeRef("System.Security.Permissions.SecurityPermission"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "ControlPrincipalPermission", $asm0F.TypeRef("System.Security.Permissions.SecurityPermission"));

    $.Property({Static:true , Public:false}, "MethodNotImplementedException", $asm0F.TypeRef("System.NotImplementedException"));

    $.Property({Static:true , Public:false}, "PropertyNotImplementedException", $asm0F.TypeRef("System.NotImplementedException"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.WindowsInstallationType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.WindowsInstallationType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Unknown: 0, 
    Client: 1, 
    Server: 2, 
    ServerCore: 3, 
    Embedded: 4, 
  }
);

/* struct System.Net.SSL_EXTRA_CERT_CHAIN_POLICY_PARA */ 

(function SSL_EXTRA_CERT_CHAIN_POLICY_PARA$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.SSL_EXTRA_CERT_CHAIN_POLICY_PARA", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 1, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:true , Public:false, ReadOnly:true }, "StructSize", $.UInt32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.hostent */ 

(function hostent$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.hostent", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "h_name", $.IntPtr);

    $.Field({Static:false, Public:true }, "h_aliases", $.IntPtr);

    $.Field({Static:false, Public:true }, "h_addr_list", $.IntPtr);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.IPAddress */ 

(function IPAddress$Members () {
  var $, $thisType;















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.IPAddress", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.Byte]), $.Int64])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.UInt16]), $.UInt32])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AddressFamily", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.AddressFamily"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ScopeId", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true }, "GetAddressBytes", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "InternalParse", 
      new JSIL.MethodSignature($.Type, [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:true }, "TryParse", 
      new JSIL.MethodSignature($.Boolean, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$.Type])])
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "Any", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "Loopback", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "Broadcast", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "None", $.Type, function ($pi) {
        return $pi.Broadcast;
      });

    $.Field({Static:false, Public:false}, "m_Address", $.Int64);

    $.Field({Static:true , Public:true , ReadOnly:true }, "IPv6Any", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "IPv6Loopback", $.Type);

    $.Field({Static:true , Public:true , ReadOnly:true }, "IPv6None", $.Type);

    $.Field({Static:false, Public:false}, "m_Family", $asm12.TypeRef("System.Net.Sockets.AddressFamily"));

    $.Field({Static:false, Public:false}, "m_Numbers", $jsilcore.TypeRef("System.Array", [$.UInt16]));

    $.Field({Static:false, Public:false}, "m_ScopeId", $.Int64);

    $.Property({Static:false, Public:true }, "AddressFamily", $asm12.TypeRef("System.Net.Sockets.AddressFamily"));

    $.Property({Static:false, Public:true }, "ScopeId", $.Int64);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.IPEndPoint */ 

(function IPEndPoint$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.EndPoint"), 
      Name: "System.Net.IPEndPoint", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.IPAddress"), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Create", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.EndPoint"), [$asm12.TypeRef("System.Net.SocketAddress")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Address", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.IPAddress"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_AddressFamily", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.AddressFamily"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Port", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Serialize", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.SocketAddress"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "m_Address", $asm12.TypeRef("System.Net.IPAddress"));

    $.Field({Static:false, Public:false}, "m_Port", $.Int32);

    $.Field({Static:true , Public:false}, "Any", $.Type);

    $.Field({Static:true , Public:false}, "IPv6Any", $.Type);

    $.Property({Static:false, Public:true , Virtual:true }, "AddressFamily", $asm12.TypeRef("System.Net.Sockets.AddressFamily"));

    $.Property({Static:false, Public:true }, "Address", $asm12.TypeRef("System.Net.IPAddress"));

    $.Property({Static:false, Public:true }, "Port", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.IPHostEntry */ 

(function IPHostEntry$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.IPHostEntry", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AddressList", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Net.IPAddress")]))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Aliases", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_HostName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_AddressList", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Net.IPAddress")]))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Aliases", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_HostName", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:false, Public:false}, "hostName", $.String);

    $.Field({Static:false, Public:false}, "aliases", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "addressList", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Net.IPAddress")]));

    $.Field({Static:false, Public:false}, "isTrustedHost", $.Boolean);

    $.Property({Static:false, Public:true }, "HostName", $.String);

    $.Property({Static:false, Public:true }, "Aliases", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Property({Static:false, Public:true }, "AddressList", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Net.IPAddress")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface System.Net.IWebProxy */ 

JSIL.MakeInterface(
  "System.Net.IWebProxy", true, [], function ($) {
  }, []);

/* class System.Net.Logging */ 

(function Logging$Members () {
  var $, $thisType;


































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Logging", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "AppDomainUnloadEvent", 
      new JSIL.MethodSignature(null, [$.Object, $asm0F.TypeRef("System.EventArgs")])
    );

    $.ExternalMethod({Static:true , Public:false}, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "Dump", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.Object, 
          $.String, $.IntPtr, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Dump", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.Object, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Enter", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.Object, 
          $.String, $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Enter", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.Object, 
          $.String, $.Object
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Enter", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.String, 
          $.String, $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Enter", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.String, 
          $.String, $.Object
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Enter", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.TraceSource"), $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "Exception", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.Object, 
          $.String, $asm0F.TypeRef("System.Exception")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Exit", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.Object, 
          $.String, $.Object
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Exit", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.String, 
          $.String, $.Object
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Exit", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.Object, 
          $.String, $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Exit", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.String, 
          $.String, $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Exit", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.TraceSource"), $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "get_InternalSyncObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_On", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_Sockets", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceSource"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_Web", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceSource"))
    );

    $.ExternalMethod({Static:true , Public:false}, "GetMaxDumpSizeSetting", 
      new JSIL.MethodSignature($.Int32, [$asm12.TypeRef("System.Diagnostics.TraceSource")])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetObjectLogHash", 
      new JSIL.MethodSignature($.String, [$.Object])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetObjectName", 
      new JSIL.MethodSignature($.String, [$.Object])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetThreadId", 
      JSIL.MethodSignature.Return($.UInt32)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetUseProtocolTextSetting", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Diagnostics.TraceSource")])
    );

    $.ExternalMethod({Static:true , Public:false}, "InitializeLogging", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "PrintError", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.TraceSource"), $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "PrintError", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $.Object, 
          $.String, $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "PrintInfo", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.TraceSource"), $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "PrintLine", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceSource"), $asm12.TypeRef("System.Diagnostics.TraceEventType"), 
          $.Int32, $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "PrintWarning", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.TraceSource"), $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "ProcessExitEvent", 
      new JSIL.MethodSignature(null, [$.Object, $asm0F.TypeRef("System.EventArgs")])
    );

    $.ExternalMethod({Static:true , Public:false}, "UnhandledExceptionHandler", 
      new JSIL.MethodSignature(null, [$.Object, $asm0F.TypeRef("System.UnhandledExceptionEventArgs")])
    );

    $.ExternalMethod({Static:true , Public:false}, "ValidateSettings", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Diagnostics.TraceSource"), $asm12.TypeRef("System.Diagnostics.TraceEventType")])
    );

    $.Field({Static:true , Public:false}, "s_LoggingEnabled", $asm0F.TypeRef("System.Boolean"), true);

    $.Field({Static:true , Public:false}, "s_LoggingInitialized", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_AppDomainShutdown", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "SupportedAttributes", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:true , Public:false}, "s_WebTraceSource", $asm12.TypeRef("System.Diagnostics.TraceSource"));

    $.Field({Static:true , Public:false}, "s_HttpListenerTraceSource", $asm12.TypeRef("System.Diagnostics.TraceSource"));

    $.Field({Static:true , Public:false}, "s_SocketsTraceSource", $asm12.TypeRef("System.Diagnostics.TraceSource"));

    $.Field({Static:true , Public:false}, "s_WebSocketsTraceSource", $asm12.TypeRef("System.Diagnostics.TraceSource"));

    $.Field({Static:true , Public:false}, "s_CacheTraceSource", $asm12.TypeRef("System.Diagnostics.TraceSource"));

    $.Field({Static:true , Public:false}, "s_TraceSourceHttpName", $asm12.TypeRef("System.Diagnostics.TraceSource"));

    $.Field({Static:true , Public:false}, "s_InternalSyncObject", $.Object);

    $.Property({Static:true , Public:false}, "InternalSyncObject", $.Object);

    $.Property({Static:true , Public:false}, "On", $.Boolean);

    $.Property({Static:true , Public:false}, "Web", $asm12.TypeRef("System.Diagnostics.TraceSource"));

    $.Property({Static:true , Public:false}, "Sockets", $asm12.TypeRef("System.Diagnostics.TraceSource"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Diagnostics");
/* class System.Diagnostics.TraceSource */ 

(function TraceSource$Members () {
  var $, $thisType;













  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.TraceSource", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm12.TypeRef("System.Diagnostics.SourceLevels")])
    );

    $.ExternalMethod({Static:true , Public:false}, "_pruneCachedTraceSources", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateSwitch", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Attributes", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Collections.Specialized.StringDictionary"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Switch", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SourceSwitch"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetSupportedAttributes", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:false}, "Initialize", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "NoConfigInit", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "TraceEvent", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceEventType"), $.Int32, 
          $.String
        ])
    );

    $.Field({Static:true , Public:false}, "tracesources", $asm0F.TypeRef("System.Collections.Generic.List`1", [$asm0F.TypeRef("System.WeakReference")]));

    $.Field({Static:true , Public:false}, "s_LastCollectionCount", $.Int32);

    $.Field({Static:false, Public:false}, "internalSwitch", $asm12.TypeRef("System.Diagnostics.SourceSwitch"));

    $.Field({Static:false, Public:false}, "listeners", $asm12.TypeRef("System.Diagnostics.TraceListenerCollection"));

    $.Field({Static:false, Public:false}, "attributes", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Field({Static:false, Public:false}, "switchLevel", $asm12.TypeRef("System.Diagnostics.SourceLevels"));

    $.Field({Static:false, Public:false}, "sourceName", $asm0F.TypeRef("System.String"));

    $.Field({Static:false, Public:false}, "_initCalled", $asm0F.TypeRef("System.Boolean"));

    $.Property({Static:false, Public:true }, "Attributes", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Property({Static:false, Public:true }, "Name", $.String);

    $.Property({Static:false, Public:true }, "Switch", $asm12.TypeRef("System.Diagnostics.SourceSwitch"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Logging+NclTraceSource */ 

(function NclTraceSource$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.TraceSource"), 
      Name: "System.Net.Logging+NclTraceSource", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetSupportedAttributes", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.String]))
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.NetworkAccess */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.NetworkAccess", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    Connect: 64, 
    Accept: 128, 
  }
);

/* class System.Net.SocketAddress */ 

(function SocketAddress$Members () {
  var $, $thisType;














  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.SocketAddress", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.Sockets.AddressFamily"), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.IPAddress"))
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.IPAddress"), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "CopyAddressSizeIntoBuffer", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Family", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.AddressFamily"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($.Byte, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Size", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetIPAddress", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.IPAddress"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetIPEndPoint", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.IPEndPoint"))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.Int32, $.Byte])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "m_Size", $.Int32);

    $.Field({Static:false, Public:false}, "m_Buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "m_changed", $.Boolean);

    $.Field({Static:false, Public:false}, "m_hash", $.Int32);

    $.Property({Static:false, Public:true }, "Family", $asm12.TypeRef("System.Net.Sockets.AddressFamily"));

    $.Property({Static:false, Public:true }, "Size", $.Int32);

    $.Property({Static:false, Public:true }, "Item", $.Byte);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.SocketPermission */ 

(function SocketPermission$Members () {
  var $, $thisType;
















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Security.CodeAccessPermission"), 
      Name: "System.Net.SocketPermission", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Security.Permissions.PermissionState"))
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddPermission", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.NetworkAccess"), $asm12.TypeRef("System.Net.EndpointPermission")])
    );

    $.ExternalMethod({Static:false, Public:false}, "CleanupDNS", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Copy", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.IPermission"))
    );

    $.ExternalMethod({Static:false, Public:false}, "FindSubset", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Collections.ArrayList"), $asm0F.TypeRef("System.Collections.ArrayList")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "FromXml", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Security.SecurityElement"))
    );

    $.ExternalMethod({Static:false, Public:false}, "initialize", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Intersect", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Security.IPermission"), [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:true , Public:false}, "intersectLists", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.Collections.ArrayList"), $asm0F.TypeRef("System.Collections.ArrayList"), 
          $asm0F.TypeRef("System.Collections.ArrayList")
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IsSubsetOf", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IsUnrestricted", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseAddXmlElement", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.Security.SecurityElement"), $asm0F.TypeRef("System.Collections.ArrayList"), 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ToXml", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.SecurityElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Union", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Security.IPermission"), [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.Field({Static:false, Public:false}, "m_connectList", $asm0F.TypeRef("System.Collections.ArrayList"));

    $.Field({Static:false, Public:false}, "m_acceptList", $asm0F.TypeRef("System.Collections.ArrayList"));

    $.Field({Static:false, Public:false}, "m_noRestriction", $.Boolean);

    $.ImplementInterfaces(
      /* 3 */ $asm0F.TypeRef("System.Security.Permissions.IUnrestrictedPermission")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.EndpointPermission */ 

(function EndpointPermission$Members () {
  var $, $thisType;
















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.EndpointPermission", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.Int32, 
          $asm12.TypeRef("System.Net.TransportType")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "CheckEndPointName", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.EndpointPermission+EndPointType"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Hostname", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsDns", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsValidWildcard", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Port", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Transport", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.TransportType"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Intersect", 
      new JSIL.MethodSignature($.Type, [$.Type])
    );

    $.ExternalMethod({Static:false, Public:false}, "MatchAddress", 
      new JSIL.MethodSignature($.Boolean, [$.Type])
    );

    $.ExternalMethod({Static:false, Public:false}, "MatchWildcard", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "Resolve", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "SubsetMatch", 
      new JSIL.MethodSignature($.Boolean, [$.Type])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "hostname", $.String);

    $.Field({Static:false, Public:false}, "port", $.Int32);

    $.Field({Static:false, Public:false}, "transport", $asm12.TypeRef("System.Net.TransportType"));

    $.Field({Static:false, Public:false}, "wildcard", $.Boolean);

    $.Field({Static:false, Public:false}, "address", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Net.IPAddress")]));

    $.Field({Static:false, Public:false}, "cached", $.Boolean);

    $.Field({Static:true , Public:false}, "DotSeparator", $jsilcore.TypeRef("System.Array", [$.Char]));

    $.Property({Static:false, Public:true }, "Hostname", $.String);

    $.Property({Static:false, Public:true }, "Transport", $asm12.TypeRef("System.Net.TransportType"));

    $.Property({Static:false, Public:true }, "Port", $.Int32);

    $.Property({Static:false, Public:false}, "IsDns", $.Boolean);

    $.Property({Static:false, Public:false}, "IsValidWildcard", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.EndpointPermission+EndPointType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.EndpointPermission+EndPointType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Invalid: 0, 
    IPv6: 1, 
    DnsOrWildcard: 2, 
    IPv4: 3, 
  }
);

/* enum System.Net.TransportType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.TransportType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Connectionless: 1, 
    Udp: 1, 
    ConnectionOriented: 2, 
    Tcp: 2, 
    All: 3, 
  }
);

/* class System.Net.UnsafeNclNativeMethods */ 

(function UnsafeNclNativeMethods$Members () {
  var $, $thisType;



  JSIL.MakeStaticClass("System.Net.UnsafeNclNativeMethods", false, [], function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:true }, "CoCreateInstance", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Guid")]), $.IntPtr, 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Guid")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Object])
        ]), 
      {
        Module: "ole32.dll", 
        Parameters: [
          {
            NativeType: "IUnknown", 
            Out: true
          }
        ]
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "GetCurrentThreadId", 
      JSIL.MethodSignature.Return($.UInt32), 
      {
        Module: "kernel32.dll", 
      }
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.UnsafeNclNativeMethods+RasHelper */ 

(function RasHelper$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.UnsafeNclNativeMethods+RasHelper", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_RasSupported", $.Boolean, true);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.UnsafeNclNativeMethods+SafeNetHandlesSafeOverlappedFree */ 

(function SafeNetHandlesSafeOverlappedFree$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.Net.UnsafeNclNativeMethods+SafeNetHandlesSafeOverlappedFree", false, [], function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:false}, "LocalAlloc", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.SafeOverlappedFree"), [$.Int32, $.UIntPtr]), 
      {
        Module: "kernel32.dll", 
      }
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.UnsafeNclNativeMethods+SafeNetHandlesXPOrLater */ 

(function SafeNetHandlesXPOrLater$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.Net.UnsafeNclNativeMethods+SafeNetHandlesXPOrLater", false, [], function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:false}, "GetAddrInfoW", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.String, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.AddressInfo")]), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.SafeFreeAddrInfo")])
        ]), 
      {
        Module: "ws2_32.dll", 
        CharSet: 'unicode',
      }
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.UnsafeNclNativeMethods+OSSOCK */ 

(function OSSOCK$Members () {
  var $, $thisType;





















  JSIL.MakeStaticClass("System.Net.UnsafeNclNativeMethods+OSSOCK", false, [], function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:false}, "gethostbyaddr", 
      new JSIL.MethodSignature($.IntPtr, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $.Int32, 
          $asm12.TypeRef("System.Net.Sockets.ProtocolFamily")
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "gethostbyname", 
      new JSIL.MethodSignature($.IntPtr, [$.String]), 
      {
        Module: "ws2_32.dll", 
        CharSet: 'ansi',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "GetNameInfoW", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $asm0F.TypeRef("System.Text.StringBuilder"), $.Int32, 
          $asm0F.TypeRef("System.Text.StringBuilder"), $.Int32, 
          $.Int32
        ]), 
      {
        Module: "ws2_32.dll", 
        CharSet: 'unicode',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "getsockopt", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $asm12.TypeRef("System.Net.Sockets.SocketOptionLevel"), 
          $asm12.TypeRef("System.Net.Sockets.SocketOptionName"), $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "getsockopt", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $asm12.TypeRef("System.Net.Sockets.SocketOptionLevel"), 
          $asm12.TypeRef("System.Net.Sockets.SocketOptionName"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Linger")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "getsockopt", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $asm12.TypeRef("System.Net.Sockets.SocketOptionLevel"), 
          $asm12.TypeRef("System.Net.Sockets.SocketOptionName"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.IPMulticastRequest")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "getsockopt", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $asm12.TypeRef("System.Net.Sockets.SocketOptionLevel"), 
          $asm12.TypeRef("System.Net.Sockets.SocketOptionName"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.IPv6MulticastRequest")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "ioctlsocket", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "recv", 
      new JSIL.MethodSignature($.Int32, [
          $.IntPtr, $jsilcore.TypeRef("JSIL.Pointer", [$.Byte]), 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags")
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "send", 
      new JSIL.MethodSignature($.Int32, [
          $.IntPtr, $jsilcore.TypeRef("JSIL.Pointer", [$.Byte]), 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags")
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "setsockopt", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $asm12.TypeRef("System.Net.Sockets.SocketOptionLevel"), 
          $asm12.TypeRef("System.Net.Sockets.SocketOptionName"), $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $.Int32
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "shutdown", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [$asm12.TypeRef("System.Net.SafeCloseSocket"), $.Int32]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "WSAAddressToString", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.IntPtr, $asm0F.TypeRef("System.Text.StringBuilder"), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "ws2_32.dll", 
        CharSet: 'ansi',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "WSAEventSelect", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $.IntPtr, 
          $asm12.TypeRef("System.Net.Sockets.AsyncEventBits")
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "WSAGetOverlappedResult", 
      new JSIL.MethodSignature($.Boolean, [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), 
          $jsilcore.TypeRef("JSIL.Reference", [$.UInt32]), $.Boolean, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketFlags")])
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "WSARecv", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.WSABuffer")]), 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketFlags")]), $asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), 
          $.IntPtr
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "WSASend", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $asm12.TypeRef("System.Net.SafeCloseSocket"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.WSABuffer")]), 
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $asm12.TypeRef("System.Net.Sockets.SocketFlags"), $asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), 
          $.IntPtr
        ]), 
      {
        Module: "ws2_32.dll", 
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "WSASocket", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.SafeCloseSocket+InnerSafeCloseSocket"), [
          $asm12.TypeRef("System.Net.Sockets.AddressFamily"), $asm12.TypeRef("System.Net.Sockets.SocketType"), 
          $asm12.TypeRef("System.Net.Sockets.ProtocolType"), $.IntPtr, 
          $.UInt32, $asm12.TypeRef("System.Net.SocketConstructorFlags")
        ]), 
      {
        Module: "ws2_32.dll", 
        CharSet: 'auto',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "WSAStartup", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [$.Int16, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.WSAData")])]), 
      {
        Module: "ws2_32.dll", 
        CharSet: 'ansi',
      }
    );

    $.PInvokeMethod({Static:true , Public:false}, "WSAStringToAddress", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $.String, $asm12.TypeRef("System.Net.Sockets.AddressFamily"), 
          $.IntPtr, $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ]), 
      {
        Module: "ws2_32.dll", 
        CharSet: 'unicode',
      }
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.UnsafeNclNativeMethods+OSSOCK+WSAPROTOCOL_INFO */ 

(function WSAPROTOCOL_INFO$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.UnsafeNclNativeMethods+OSSOCK+WSAPROTOCOL_INFO", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.UnsafeNclNativeMethods+OSSOCK+ControlData */ 

(function ControlData$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.UnsafeNclNativeMethods+OSSOCK+ControlData", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.UnsafeNclNativeMethods+OSSOCK+ControlDataIPv6 */ 

(function ControlDataIPv6$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.UnsafeNclNativeMethods+OSSOCK+ControlDataIPv6", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.UnsafeNclNativeMethods+OSSOCK+WSAMsg */ 

(function WSAMsg$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.UnsafeNclNativeMethods+OSSOCK+WSAMsg", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.WebHeaderCollection+HeaderEncoding */ 

(function HeaderEncoding$Members () {
  var $, $thisType;



  JSIL.MakeStaticClass("System.Net.WebHeaderCollection+HeaderEncoding", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "GetString", 
      new JSIL.MethodSignature($.String, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetString", 
      new JSIL.MethodSignature($.String, [$jsilcore.TypeRef("JSIL.Pointer", [$.Byte]), $.Int32])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.DelayedRegex */ 

(function DelayedRegex$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.DelayedRegex", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_AsRegex", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.Regex"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "_AsRegex", $asm12.TypeRef("System.Text.RegularExpressions.Regex"));

    $.Field({Static:false, Public:false}, "_AsString", $.String);

    $.Property({Static:false, Public:false}, "AsRegex", $asm12.TypeRef("System.Text.RegularExpressions.Regex"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.WebPermission */ 

(function WebPermission$Members () {
  var $, $thisType;


















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Security.CodeAccessPermission"), 
      Name: "System.Net.WebPermission", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.NetworkAccess"))
    );

    $.ExternalMethod({Static:false, Public:false}, "AddAsPattern", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.NetworkAccess"), $asm12.TypeRef("System.Net.DelayedRegex")])
    );

    $.ExternalMethod({Static:false, Public:true }, "AddPermission", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.NetworkAccess"), $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddPermission", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.NetworkAccess"), $asm12.TypeRef("System.Uri")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Copy", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.IPermission"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "FromXml", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Security.SecurityElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Intersect", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Security.IPermission"), [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:true , Public:false}, "intersectList", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.Collections.ArrayList"), $asm0F.TypeRef("System.Collections.ArrayList"), 
          $asm0F.TypeRef("System.Collections.ArrayList")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "intersectPair", 
      new JSIL.MethodSignature($.Object, [
          $.Object, $.Object, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "isMatchedURI", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $asm0F.TypeRef("System.Collections.ArrayList")])
    );

    $.ExternalMethod({Static:true , Public:false}, "isSpecialSubsetCase", 
      new JSIL.MethodSignature($.Boolean, [$.String, $asm0F.TypeRef("System.Collections.ArrayList")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IsSubsetOf", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IsUnrestricted", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ToXml", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.SecurityElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Union", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Security.IPermission"), [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.Field({Static:false, Public:false}, "m_noRestriction", $.Boolean);

    $.Field({Static:false, Public:false}, "m_UnrestrictedConnect", $.Boolean)
      .Attribute($asm0F.TypeRef("System.Runtime.Serialization.OptionalFieldAttribute"));

    $.Field({Static:false, Public:false}, "m_UnrestrictedAccept", $.Boolean)
      .Attribute($asm0F.TypeRef("System.Runtime.Serialization.OptionalFieldAttribute"));

    $.Field({Static:false, Public:false}, "m_connectList", $asm0F.TypeRef("System.Collections.ArrayList"));

    $.Field({Static:false, Public:false}, "m_acceptList", $asm0F.TypeRef("System.Collections.ArrayList"));

    $.ImplementInterfaces(
      /* 3 */ $asm0F.TypeRef("System.Security.Permissions.IUnrestrictedPermission")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.AutoWebProxyScriptEngine+AutoDetector */ 

(function AutoDetector$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.AutoWebProxyScriptEngine+AutoDetector", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:true , Public:false}, "s_LockObject", $.Object);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.CallbackClosure */ 

(function CallbackClosure$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.CallbackClosure", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Threading.ExecutionContext"), $asm0F.TypeRef("System.AsyncCallback")])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_AsyncCallback", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.AsyncCallback"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Context", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Threading.ExecutionContext"))
    );

    $.ExternalMethod({Static:false, Public:false}, "IsCompatible", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.AsyncCallback")])
    );

    $.Field({Static:false, Public:false}, "savedCallback", $asm0F.TypeRef("System.AsyncCallback"));

    $.Field({Static:false, Public:false}, "savedContext", $asm0F.TypeRef("System.Threading.ExecutionContext"));

    $.Property({Static:false, Public:false}, "AsyncCallback", $asm0F.TypeRef("System.AsyncCallback"));

    $.Property({Static:false, Public:false}, "Context", $asm0F.TypeRef("System.Threading.ExecutionContext"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.NetworkingPerfCounterName */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.NetworkingPerfCounterName", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    SocketConnectionsEstablished: 0, 
    SocketBytesReceived: 1, 
    SocketBytesSent: 2, 
    SocketDatagramsReceived: 3, 
    SocketDatagramsSent: 4, 
    HttpWebRequestCreated: 5, 
    HttpWebRequestAvgLifeTime: 6, 
    HttpWebRequestAvgLifeTimeBase: 7, 
    HttpWebRequestQueued: 8, 
    HttpWebRequestAvgQueueTime: 9, 
    HttpWebRequestAvgQueueTimeBase: 10, 
    HttpWebRequestAborted: 11, 
    HttpWebRequestFailed: 12, 
  }
);

/* class System.Net.NetworkingPerfCounters */ 

(function NetworkingPerfCounters$Members () {
  var $, $thisType;
















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.NetworkingPerfCounters", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Cleanup", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "CounterAvailable", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateCounterPair", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.NetworkingPerfCounters+CounterPair"), [$.String, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateInstance", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ExceptionEventHandler", 
      new JSIL.MethodSignature(null, [$.Object, $asm0F.TypeRef("System.UnhandledExceptionEventArgs")])
    );

    $.ExternalMethod({Static:false, Public:false}, "ExitEventHandler", 
      new JSIL.MethodSignature(null, [$.Object, $asm0F.TypeRef("System.EventArgs")])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Enabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_Instance", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetInstanceName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "Increment", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.NetworkingPerfCounterName"))
    );

    $.ExternalMethod({Static:false, Public:true }, "Increment", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.NetworkingPerfCounterName"), $.Int64])
    );

    $.ExternalMethod({Static:false, Public:false}, "Initialize", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:true , Public:false}, "ReplaceInvalidChars", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "UnloadEventHandler", 
      new JSIL.MethodSignature(null, [$.Object, $asm0F.TypeRef("System.EventArgs")])
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "counterNames", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:true , Public:false}, "instance", $asm12.TypeRef("System.Net.NetworkingPerfCounters"));

    $.Field({Static:true , Public:false}, "lockObject", $.Object);

    $.Field({Static:false, Public:false}, "initDone", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:false, Public:false}, "initSuccessful", $.Boolean);

    $.Field({Static:false, Public:false}, "counters", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Net.NetworkingPerfCounters+CounterPair")]));

    $.Field({Static:false, Public:false}, "enabled", $.Boolean);

    $.Field({Static:false, Public:false}, "cleanupCalled", $asm0F.TypeRef("System.Boolean"));

    $.Property({Static:true , Public:true }, "Instance", $.Type);

    $.Property({Static:false, Public:true }, "Enabled", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.NetworkingPerfCounters+CounterPair */ 

(function CounterPair$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.NetworkingPerfCounters+CounterPair", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.PerformanceCounter"), $asm12.TypeRef("System.Diagnostics.PerformanceCounter")])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_GlobalCounter", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.PerformanceCounter"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_InstanceCounter", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.PerformanceCounter"))
    );

    $.Field({Static:false, Public:false}, "instanceCounter", $asm12.TypeRef("System.Diagnostics.PerformanceCounter"));

    $.Field({Static:false, Public:false}, "globalCounter", $asm12.TypeRef("System.Diagnostics.PerformanceCounter"));

    $.Property({Static:false, Public:true }, "InstanceCounter", $asm12.TypeRef("System.Diagnostics.PerformanceCounter"));

    $.Property({Static:false, Public:true }, "GlobalCounter", $asm12.TypeRef("System.Diagnostics.PerformanceCounter"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.IPMulticastRequest */ 

(function IPMulticastRequest$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.IPMulticastRequest", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "MulticastAddress", $.Int32);

    $.Field({Static:false, Public:false}, "InterfaceAddress", $.Int32);

    $.Field({Static:true , Public:false, ReadOnly:true }, "Size", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.Linger */ 

(function Linger$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.Linger", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "OnOff", $.UInt16);

    $.Field({Static:false, Public:false}, "Time", $.UInt16);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.WSABuffer */ 

(function WSABuffer$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.WSABuffer", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "Length", $.Int32);

    $.Field({Static:false, Public:false}, "Pointer", $.IntPtr);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.WSAData */ 

(function WSAData$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.WSAData", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Net.AddressInfo */ 

(function AddressInfo$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.AddressInfo", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "ai_flags", $asm12.TypeRef("System.Net.AddressInfoHints"));

    $.Field({Static:false, Public:false}, "ai_family", $asm12.TypeRef("System.Net.Sockets.AddressFamily"));

    $.Field({Static:false, Public:false}, "ai_addrlen", $.Int32);

    $.Field({Static:false, Public:false}, "ai_canonname", $jsilcore.TypeRef("JSIL.Pointer", [$.SByte]));

    $.Field({Static:false, Public:false}, "ai_addr", $jsilcore.TypeRef("JSIL.Pointer", [$.Byte]));

    $.Field({Static:false, Public:false}, "ai_next", $jsilcore.TypeRef("JSIL.Pointer", [$.Type]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.AddressInfoHints */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.AddressInfoHints", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: true, 
  }, 
  {
    AI_PASSIVE: 1, 
    AI_CANONNAME: 2, 
    AI_NUMERICHOST: 4, 
    AI_FQDN: 131072, 
  }
);

/* struct System.Net.IPv6MulticastRequest */ 

(function IPv6MulticastRequest$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Net.IPv6MulticastRequest", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "MulticastAddress", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "InterfaceIndex", $.Int32);

    $.Field({Static:true , Public:false, ReadOnly:true }, "Size", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.SocketConstructorFlags */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.SocketConstructorFlags", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: true, 
  }, 
  {
    WSA_FLAG_OVERLAPPED: 1, 
    WSA_FLAG_MULTIPOINT_C_ROOT: 2, 
    WSA_FLAG_MULTIPOINT_C_LEAF: 4, 
    WSA_FLAG_MULTIPOINT_D_ROOT: 8, 
    WSA_FLAG_MULTIPOINT_D_LEAF: 16, 
  }
);

/* class System.Net.SafeFreeAddrInfo */ 

(function SafeFreeAddrInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "System.Net.SafeFreeAddrInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "GetAddrInfo", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.String, 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.AddressInfo")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ])
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.SafeOverlappedFree */ 

(function SafeOverlappedFree$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "System.Net.SafeOverlappedFree", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "Alloc", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:true , Public:true }, "Alloc", 
      new JSIL.MethodSignature($.Type, [$asm12.TypeRef("System.Net.SafeCloseSocket")])
    );

    $.ExternalMethod({Static:false, Public:true }, "Close", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "Zero", $.Type);

    $.Field({Static:false, Public:false}, "_socketHandle", $asm12.TypeRef("System.Net.SafeCloseSocket"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

})();

/* class System.Net.SafeNativeOverlapped */ 

(function SafeNativeOverlapped$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"), 
      Name: "System.Net.SafeNativeOverlapped", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Pointer", [$asm0F.TypeRef("System.Threading.NativeOverlapped")]))
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.IntPtr)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsInvalid", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "Zero", $.Type);

    $.Property({Static:false, Public:true , Virtual:true }, "IsInvalid", $.Boolean);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.SafeCloseSocket */ 

(function SafeCloseSocket$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid"), 
      Name: "System.Net.SafeCloseSocket", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, "CloseAsIs", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsInvalid", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:false, Public:false}, "m_InnerSocket", $asm12.TypeRef("System.Net.SafeCloseSocket+InnerSafeCloseSocket"));

    $.Field({Static:false, Public:false}, "m_Released", $asm0F.TypeRef("System.Boolean"));

    $.Property({Static:false, Public:true , Virtual:true }, "IsInvalid", $.Boolean);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.SafeCloseSocket+InnerSafeCloseSocket */ 

(function InnerSafeCloseSocket$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid"), 
      Name: "System.Net.SafeCloseSocket+InnerSafeCloseSocket", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, "BlockingRelease", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsInvalid", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "tempBuffer", $jsilcore.TypeRef("System.Array", [$.Byte]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Byte, 1);
      });

    $.Field({Static:false, Public:false}, "m_Blockable", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "IsInvalid", $.Boolean);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.SafeCloseSocketAndEvent */ 

(function SafeCloseSocketAndEvent$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.SafeCloseSocket"), 
      Name: "System.Net.SafeCloseSocketAndEvent", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.TimerThread+Queue */ 

(function Queue$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.TimerThread+Queue", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Win32 */ 

(function Win32$Members () {
  var $, $thisType;

  JSIL.MakeStaticClass("System.Net.Win32", false, [], function ($ib) {
    $ = $ib;

    $.Field({Static:true , Public:false}, "OverlappedInternalHighOffset", $.Int32);

    $.Field({Static:true , Public:false}, "OverlappedOffsetOffset", $.Int32);

    $.Field({Static:true , Public:false}, "OverlappedOffsetHighOffset", $.Int32);

    $.Field({Static:true , Public:false}, "OverlappedhEventOffset", $.Int32);

    $.Field({Static:true , Public:false}, "OverlappedSize", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.DelegatedStream */ 

(function DelegatedStream$Members () {
  var $, $thisType;


















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.IO.Stream"), 
      Name: "System.Net.DelegatedStream", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginRead", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginWrite", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndRead", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Flush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_BaseStream", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.IO.Stream"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanRead", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanSeek", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanWrite", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Position", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Read", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Seek", 
      new JSIL.MethodSignature($.Int64, [$.Int64, $asm0F.TypeRef("System.IO.SeekOrigin")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Position", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.Field({Static:false, Public:false}, "stream", $asm0F.TypeRef("System.IO.Stream"));

    $.Field({Static:false, Public:false}, "netStream", $asm12.TypeRef("System.Net.Sockets.NetworkStream"));

    $.Property({Static:false, Public:false}, "BaseStream", $asm0F.TypeRef("System.IO.Stream"));

    $.Property({Static:false, Public:true , Virtual:true }, "CanRead", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanSeek", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanWrite", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Length", $.Int64);

    $.Property({Static:false, Public:true , Virtual:true }, "Position", $.Int64);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Base64Stream */ 

(function Base64Stream$Members () {
  var $, $thisType;


















  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.DelegatedStream"), 
      Name: "System.Net.Base64Stream", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Mime.Base64WriteStateInfo"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginRead", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginWrite", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "DecodeBytes", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EncodeBytes", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "EncodeBytes", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $.Boolean, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndRead", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Flush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "FlushInternal", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanWrite", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_ReadState", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Base64Stream+ReadStateInfo"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_WriteState", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Mime.Base64WriteStateInfo"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetEncodedString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Read", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.Field({Static:true , Public:false}, "base64DecodeMap", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false}, "base64EncodeMap", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "lineLength", $.Int32);

    $.Field({Static:false, Public:false}, "readState", $asm12.TypeRef("System.Net.Base64Stream+ReadStateInfo"));

    $.Field({Static:false, Public:false}, "writeState", $asm12.TypeRef("System.Net.Mime.Base64WriteStateInfo"));

    $.Property({Static:false, Public:true , Virtual:true }, "CanWrite", $.Boolean);

    $.Property({Static:false, Public:false}, "ReadState", $asm12.TypeRef("System.Net.Base64Stream+ReadStateInfo"));

    $.Property({Static:false, Public:false}, "WriteState", $asm12.TypeRef("System.Net.Mime.Base64WriteStateInfo"));

    $.ImplementInterfaces(
      /* 1 */ $asm12.TypeRef("System.Net.Mime.IEncodableStream")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Base64Stream+ReadAsyncResult */ 

(function ReadAsyncResult$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.LazyAsyncResult"), 
      Name: "System.Net.Base64Stream+ReadAsyncResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 6, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Net.Base64Stream"), $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $.Int32, $.Int32, 
          $asm0F.TypeRef("System.AsyncCallback"), $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CompleteRead", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:true , Public:false}, "End", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:true , Public:false}, "OnRead", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Read", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "parent", $asm12.TypeRef("System.Net.Base64Stream"));

    $.Field({Static:false, Public:false}, "buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "offset", $.Int32);

    $.Field({Static:false, Public:false}, "count", $.Int32);

    $.Field({Static:false, Public:false}, "read", $.Int32);

    $.Field({Static:true , Public:false}, "onRead", $asm0F.TypeRef("System.AsyncCallback"), function ($pi) {
        return $asm0F.System.AsyncCallback.New(null, null, new JSIL.MethodPointerInfo($thisType, "OnRead", JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult")), true, false));
      });

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Base64Stream+WriteAsyncResult */ 

(function WriteAsyncResult$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.LazyAsyncResult"), 
      Name: "System.Net.Base64Stream+WriteAsyncResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 6, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Net.Base64Stream"), $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $.Int32, $.Int32, 
          $asm0F.TypeRef("System.AsyncCallback"), $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CompleteWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:true , Public:false}, "End", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:true , Public:false}, "OnWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Write", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "parent", $asm12.TypeRef("System.Net.Base64Stream"));

    $.Field({Static:false, Public:false}, "buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "offset", $.Int32);

    $.Field({Static:false, Public:false}, "count", $.Int32);

    $.Field({Static:true , Public:false}, "onWrite", $asm0F.TypeRef("System.AsyncCallback"), function ($pi) {
        return $asm0F.System.AsyncCallback.New(null, null, new JSIL.MethodPointerInfo($thisType, "OnWrite", JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult")), true, false));
      });

    $.Field({Static:false, Public:false}, "written", $.Int32);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Base64Stream+ReadStateInfo */ 

(function ReadStateInfo$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Base64Stream+ReadStateInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Pos", 
      JSIL.MethodSignature.Return($.Byte)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Val", 
      JSIL.MethodSignature.Return($.Byte)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Pos", 
      JSIL.MethodSignature.Action($.Byte)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Val", 
      JSIL.MethodSignature.Action($.Byte)
    );

    $.Field({Static:false, Public:false}, "val", $.Byte);

    $.Field({Static:false, Public:false}, "pos", $.Byte);

    $.Property({Static:false, Public:false}, "Val", $.Byte);

    $.Property({Static:false, Public:false}, "Pos", $.Byte);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Collections");
JSIL.DeclareNamespace("System.Collections.Specialized");
/* class System.Collections.Specialized.StringDictionary */ 

(function StringDictionary$Members () {
  var $, $thisType;















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Specialized.StringDictionary", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "AsGenericDictionary", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ContainsKey", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ContainsValue", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Item", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Keys", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.ICollection"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Values", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.ICollection"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Remove", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReplaceHashtable", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Hashtable"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.Field({Static:false, Public:false}, "contents", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "Item", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "Keys", $asm0F.TypeRef("System.Collections.ICollection"));

    $.Property({Static:false, Public:true , Virtual:true }, "Values", $asm0F.TypeRef("System.Collections.ICollection"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.IEnumerable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Specialized.StringDictionary+GenericAdapter */ 

(function GenericAdapter$Members () {
  var $, $thisType;


















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Specialized.StringDictionary+GenericAdapter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Collections.Specialized.StringDictionary"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ContainsKey", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Item", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Keys", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Values", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String])]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Remove", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lSystem.String$cmSystem.String$g$g.Add", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String]))
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$asm0F.TypeRef("System.String"), $asm0F.TypeRef("System.String")])]), "Add");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lSystem.String$cmSystem.String$g$g.Contains", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String])])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$asm0F.TypeRef("System.String"), $asm0F.TypeRef("System.String")])]), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lSystem.String$cmSystem.String$g$g.CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String])]), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$asm0F.TypeRef("System.String"), $asm0F.TypeRef("System.String")])]), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lSystem.String$cmSystem.String$g$g.get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$asm0F.TypeRef("System.String"), $asm0F.TypeRef("System.String")])]), "get_IsReadOnly");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "TryGetValue", 
      new JSIL.MethodSignature($.Boolean, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$.String])])
    );

    $.Field({Static:false, Public:false}, "m_stringDictionary", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Field({Static:false, Public:false}, "_values", $asm12.TypeRef("System.Collections.Specialized.StringDictionary+GenericAdapter+ICollectionToGenericCollectionAdapter"));

    $.Field({Static:false, Public:false}, "_keys", $asm12.TypeRef("System.Collections.Specialized.StringDictionary+GenericAdapter+ICollectionToGenericCollectionAdapter"));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "Item", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "Keys", $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.String]));

    $.Property({Static:false, Public:true , Virtual:true }, "Values", $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.String]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lSystem.String$cmSystem.String$g$g.IsReadOnly", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String])]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String])]), 
      /* 3 */ $asm0F.TypeRef("System.Collections.IEnumerable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Collections.Specialized.StringDictionary+GenericAdapter+KeyOrValue */ 

JSIL.MakeEnum(
  {
    FullName: "System.Collections.Specialized.StringDictionary+GenericAdapter+KeyOrValue", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Key: 0, 
    Value: 1, 
  }
);

/* class System.Collections.Specialized.StringDictionary+GenericAdapter+ICollectionToGenericCollectionAdapter */ 

(function ICollectionToGenericCollectionAdapter$Members () {
  var $, $thisType;












  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Specialized.StringDictionary+GenericAdapter+ICollectionToGenericCollectionAdapter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Specialized.StringDictionary"), $asm12.TypeRef("System.Collections.Specialized.StringDictionary+GenericAdapter+KeyOrValue")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Contains", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.String]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetUnderlyingCollection", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.ICollection"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:true }, "ThrowNotSupportedException", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "_internal", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Field({Static:false, Public:false}, "_keyOrValue", $asm12.TypeRef("System.Collections.Specialized.StringDictionary+GenericAdapter+KeyOrValue"));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "IsReadOnly", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.String]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.String]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Specialized.StringDictionary+GenericAdapter+ICollectionToGenericCollectionAdapter+<GetEnumerator>d__14 */ 

(function $lGetEnumerator$gd__14$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Specialized.StringDictionary+GenericAdapter+ICollectionToGenericCollectionAdapter+<GetEnumerator>d__14", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lSystem.String$g.get_Current", 
      JSIL.MethodSignature.Return($.String)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm0F.TypeRef("System.String")]), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.IDisposable"), "Dispose");

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $.String);

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm12.TypeRef("System.Collections.Specialized.StringDictionary+GenericAdapter+ICollectionToGenericCollectionAdapter"));

    $.Field({Static:false, Public:false}, "$l$g7__wrap1", $asm0F.TypeRef("System.Collections.IEnumerator"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lSystem.String$g.Current", $.String);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.String]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Specialized.StringDictionary+GenericAdapter+<GetEnumerator>d__25 */ 

(function $lGetEnumerator$gd__25$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Specialized.StringDictionary+GenericAdapter+<GetEnumerator>d__25", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "$l$gm__Finally1", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "MoveNext");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lSystem.Collections.Generic.KeyValuePair$lSystem.String$cmSystem.String$g$g.get_Current", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String]))
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$asm0F.TypeRef("System.String"), $asm0F.TypeRef("System.String")])]), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.IDisposable"), "Dispose");

    $.Field({Static:false, Public:false}, "$l$g1__state", $.Int32);

    $.Field({Static:false, Public:false}, "$l$g2__current", $asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String]));

    $.Field({Static:false, Public:true }, "$l$g4__this", $asm12.TypeRef("System.Collections.Specialized.StringDictionary+GenericAdapter"));

    $.Field({Static:false, Public:false}, "$l$g7__wrap1", $asm0F.TypeRef("System.Collections.IEnumerator"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerator$lSystem.Collections.Generic.KeyValuePair$lSystem.String$cmSystem.String$g$g.Current", $asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.String, $.String])]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Net.TrackingValidationObjectDictionary */ 

(function TrackingValidationObjectDictionary$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0F.System.Boolean)) ();
  };





  function TrackingValidationObjectDictionary_get_IsChanged () {
    return this.TrackingValidationObjectDictionary$IsChanged$value;
  }; 




  function TrackingValidationObjectDictionary_set_IsChanged (value) {
    this.TrackingValidationObjectDictionary$IsChanged$value = value;
  }; 


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Collections.Specialized.StringDictionary"), 
      Name: "System.Net.TrackingValidationObjectDictionary", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $asm12.TypeRef("System.Net.TrackingValidationObjectDictionary+ValidateAndParseValue")]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.Method({Static:false, Public:false}, "get_IsChanged", 
      JSIL.MethodSignature.Return($.Boolean), 
      TrackingValidationObjectDictionary_get_IsChanged
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Item", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "PersistValue", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Remove", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Method({Static:false, Public:false}, "set_IsChanged", 
      JSIL.MethodSignature.Action($.Boolean), 
      TrackingValidationObjectDictionary_set_IsChanged
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.Field({Static:false, Public:false}, "internalObjects", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.Object]));

    $.Field({Static:false, Public:false, ReadOnly:true }, "validators", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $asm12.TypeRef("System.Net.TrackingValidationObjectDictionary+ValidateAndParseValue")]));

    $.Field({Static:false, Public:false}, "TrackingValidationObjectDictionary$IsChanged$value", $.Boolean)
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Property({Static:false, Public:false}, "IsChanged", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Item", $.String);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate System.Net.TrackingValidationObjectDictionary+ValidateAndParseValue */ 

JSIL.MakeDelegate("System.Net.TrackingValidationObjectDictionary+ValidateAndParseValue", false, [], 
  new JSIL.MethodSignature($asm0F.TypeRef("System.Object"), [$asm0F.TypeRef("System.Object")]));

JSIL.DeclareNamespace("System.Net.Mime");
/* class System.Net.Mime.WriteStateInfoBase */ 

(function WriteStateInfoBase$Members () {
  var $, $thisType;
















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Mime.WriteStateInfoBase", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 5, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Append", 
      JSIL.MethodSignature.Action($.Byte)
    );

    $.ExternalMethod({Static:false, Public:false}, "Append", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Byte]))
    )
      .Parameter(0, "bytes", function (_) {
          _.Attribute($asm0F.TypeRef("System.ParamArrayAttribute"))
        });

    $.ExternalMethod({Static:false, Public:false}, "AppendCRLF", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "AppendFooter", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "AppendHeader", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureSpaceInBuffer", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Buffer", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_CurrentLineLength", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Footer", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_FooterLength", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Header", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Length", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_MaxLineLength", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Reset", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "_header", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "_footer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "_maxLineLength", $.Int32);

    $.Field({Static:false, Public:false}, "buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "_currentLineLength", $.Int32);

    $.Field({Static:false, Public:false}, "_currentBufferUsed", $.Int32);

    $.Property({Static:false, Public:false}, "FooterLength", $.Int32);

    $.Property({Static:false, Public:false}, "Footer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Property({Static:false, Public:false}, "Header", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Property({Static:false, Public:false}, "Buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Property({Static:false, Public:false}, "Length", $.Int32);

    $.Property({Static:false, Public:false}, "CurrentLineLength", $.Int32);

    $.Property({Static:false, Public:false}, "MaxLineLength", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Mime.Base64WriteStateInfo */ 

(function Base64WriteStateInfo$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0F.System.Byte)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm0F.System.Int32)) ();
  };



  function Base64WriteStateInfo_get_LastBits () {
    return this.Base64WriteStateInfo$LastBits$value;
  }; 

  function Base64WriteStateInfo_get_Padding () {
    return this.Base64WriteStateInfo$Padding$value;
  }; 

  function Base64WriteStateInfo_set_LastBits (value) {
    this.Base64WriteStateInfo$LastBits$value = (value | 0);
  }; 

  function Base64WriteStateInfo_set_Padding (value) {
    this.Base64WriteStateInfo$Padding$value = (value | 0);
  }; 

  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.Mime.WriteStateInfoBase"), 
      Name: "System.Net.Mime.Base64WriteStateInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 5, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.Method({Static:false, Public:false}, "get_LastBits", 
      JSIL.MethodSignature.Return($.Byte), 
      Base64WriteStateInfo_get_LastBits
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "get_Padding", 
      JSIL.MethodSignature.Return($.Int32), 
      Base64WriteStateInfo_get_Padding
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "set_LastBits", 
      JSIL.MethodSignature.Action($.Byte), 
      Base64WriteStateInfo_set_LastBits
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "set_Padding", 
      JSIL.MethodSignature.Action($.Int32), 
      Base64WriteStateInfo_set_Padding
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:false, Public:false}, "Base64WriteStateInfo$Padding$value", $.Int32)
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:false, Public:false}, "Base64WriteStateInfo$LastBits$value", $.Byte)
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Property({Static:false, Public:false}, "Padding", $.Int32);

    $.Property({Static:false, Public:false}, "LastBits", $.Byte);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Mime.ContentDisposition */ 

(function ContentDisposition$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Mime.ContentDisposition", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, "Encode", 
      new JSIL.MethodSignature($.String, [$.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "EncodeToBuffer", 
      new JSIL.MethodSignature(null, [
          $.String, $asm0F.TypeRef("System.Text.StringBuilder"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Parameters", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Collections.Specialized.StringDictionary"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "dispositionType", $.String);

    $.Field({Static:false, Public:false}, "parameters", $asm12.TypeRef("System.Net.TrackingValidationObjectDictionary"));

    $.Field({Static:false, Public:false}, "isChanged", $.Boolean);

    $.Field({Static:false, Public:false}, "isPersisted", $.Boolean);

    $.Field({Static:false, Public:false}, "disposition", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "dateParser", $asm12.TypeRef("System.Net.TrackingValidationObjectDictionary+ValidateAndParseValue"), function ($pi) {
        return $asm12.System.Net.TrackingValidationObjectDictionary_ValidateAndParseValue.New($asm12.System.Net.Mime.ContentDisposition_$l$gc.$l$g9, null, new JSIL.MethodPointerInfo($asm12.System.Net.Mime.ContentDisposition_$l$gc, "$l_cctor$gb__13_0", new JSIL.MethodSignature($.Object, [$.Object]), false, false));
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "longParser", $asm12.TypeRef("System.Net.TrackingValidationObjectDictionary+ValidateAndParseValue"), function ($pi) {
        return $asm12.System.Net.TrackingValidationObjectDictionary_ValidateAndParseValue.New($asm12.System.Net.Mime.ContentDisposition_$l$gc.$l$g9, null, new JSIL.MethodPointerInfo($asm12.System.Net.Mime.ContentDisposition_$l$gc, "$l_cctor$gb__13_1", new JSIL.MethodSignature($.Object, [$.Object]), false, false));
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "validators", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $asm12.TypeRef("System.Net.TrackingValidationObjectDictionary+ValidateAndParseValue")]));

    $.Property({Static:false, Public:true }, "Parameters", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Mime.ContentDisposition+<>c */ 

(function $l$gc$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Mime.ContentDisposition+<>c", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$l.cctor$gb__13_0", 
      new JSIL.MethodSignature($.Object, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:false}, "$l.cctor$gb__13_1", 
      new JSIL.MethodSignature($.Object, [$.Object])
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "$l$g9", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Net.Mime.EncodedStreamFactory */ 

(function EncodedStreamFactory$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Mime.EncodedStreamFactory", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateFooter", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateHeader", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Byte]), [$asm0F.TypeRef("System.Text.Encoding"), $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "get_DefaultMaxLineLength", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetEncoderForHeader", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Mime.IEncodableStream"), [
          $asm0F.TypeRef("System.Text.Encoding"), $.Boolean, 
          $.Int32
        ])
    );

    $.Property({Static:true , Public:false}, "DefaultMaxLineLength", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface System.Net.Mime.IEncodableStream */ 

JSIL.MakeInterface(
  "System.Net.Mime.IEncodableStream", false, [], function ($) {
    $.Method({}, "EncodeBytes", new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ]));
    $.Method({}, "GetEncodedString", JSIL.MethodSignature.Return($.String));
  }, []);

/* class System.Net.Mime.MailBnfHelper */ 

(function MailBnfHelper$Members () {
  var $, $thisType;





  JSIL.MakeStaticClass("System.Net.Mime.MailBnfHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CheckForUnicode", 
      new JSIL.MethodSignature($.Boolean, [$.Char, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetTokenOrQuotedString", 
      new JSIL.MethodSignature(null, [
          $.String, $asm0F.TypeRef("System.Text.StringBuilder"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "HasCROrLF", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsFWSAt", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.Int32])
    );

    $.Field({Static:true , Public:false}, "Atext", $jsilcore.TypeRef("System.Array", [$.Boolean]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Boolean, 128);
      });

    $.Field({Static:true , Public:false}, "Qtext", $jsilcore.TypeRef("System.Array", [$.Boolean]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Boolean, 128);
      });

    $.Field({Static:true , Public:false}, "Dtext", $jsilcore.TypeRef("System.Array", [$.Boolean]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Boolean, 128);
      });

    $.Field({Static:true , Public:false}, "Ftext", $jsilcore.TypeRef("System.Array", [$.Boolean]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Boolean, 128);
      });

    $.Field({Static:true , Public:false}, "Ttext", $jsilcore.TypeRef("System.Array", [$.Boolean]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Boolean, 128);
      });

    $.Field({Static:true , Public:false}, "Ctext", $jsilcore.TypeRef("System.Array", [$.Boolean]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Boolean, 128);
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "Ascii7bitMaxValue", $.Int32, 127);

    $.Field({Static:true , Public:false, ReadOnly:true }, "Quote", $.Char, "\"");

    $.Field({Static:true , Public:false, ReadOnly:true }, "Space", $.Char, " ");

    $.Field({Static:true , Public:false, ReadOnly:true }, "Tab", $.Char, "\t");

    $.Field({Static:true , Public:false, ReadOnly:true }, "CR", $.Char, "\r");

    $.Field({Static:true , Public:false, ReadOnly:true }, "LF", $.Char, "\n");

    $.Field({Static:true , Public:false, ReadOnly:true }, "StartComment", $.Char, "(");

    $.Field({Static:true , Public:false, ReadOnly:true }, "EndComment", $.Char, ")");

    $.Field({Static:true , Public:false, ReadOnly:true }, "Backslash", $.Char, "\\");

    $.Field({Static:true , Public:false, ReadOnly:true }, "At", $.Char, "@");

    $.Field({Static:true , Public:false, ReadOnly:true }, "EndAngleBracket", $.Char, ">");

    $.Field({Static:true , Public:false, ReadOnly:true }, "StartAngleBracket", $.Char, "<");

    $.Field({Static:true , Public:false, ReadOnly:true }, "StartSquareBracket", $.Char, "[");

    $.Field({Static:true , Public:false, ReadOnly:true }, "EndSquareBracket", $.Char, "]");

    $.Field({Static:true , Public:false, ReadOnly:true }, "Comma", $.Char, ",");

    $.Field({Static:true , Public:false, ReadOnly:true }, "Dot", $.Char, ".");

    $.Field({Static:true , Public:false, ReadOnly:true }, "Whitespace", $asm0F.TypeRef("System.Collections.Generic.IList`1", [$.Char]));

    $.Field({Static:true , Public:false}, "s_months", $jsilcore.TypeRef("System.Array", [$.String]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Mime.MimeBasePart */ 

(function MimeBasePart$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Mime.MimeBasePart", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "DecodeEncoding", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Text.Encoding"), [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "EncodeHeaderValue", 
      new JSIL.MethodSignature($.String, [
          $.String, $asm0F.TypeRef("System.Text.Encoding"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "EncodeHeaderValue", 
      new JSIL.MethodSignature($.String, [
          $.String, $asm0F.TypeRef("System.Text.Encoding"), 
          $.Boolean, $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsAscii", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "ShouldUseBase64Encoding", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Text.Encoding")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Mime.QEncodedStream */ 

(function QEncodedStream$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.DelegatedStream"), 
      Name: "System.Net.Mime.QEncodedStream", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Mime.WriteStateInfoBase"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginWrite", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EncodeBytes", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Flush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "FlushInternal", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_WriteState", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Mime.WriteStateInfoBase"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetEncodedString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.Field({Static:true , Public:false}, "hexDecodeMap", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false}, "hexEncodeMap", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "writeState", $asm12.TypeRef("System.Net.Mime.WriteStateInfoBase"));

    $.Property({Static:false, Public:false}, "WriteState", $asm12.TypeRef("System.Net.Mime.WriteStateInfoBase"));

    $.ImplementInterfaces(
      /* 1 */ $asm12.TypeRef("System.Net.Mime.IEncodableStream")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Mime.QEncodedStream+WriteAsyncResult */ 

(function WriteAsyncResult$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.LazyAsyncResult"), 
      Name: "System.Net.Mime.QEncodedStream+WriteAsyncResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 6, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Net.Mime.QEncodedStream"), $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $.Int32, $.Int32, 
          $asm0F.TypeRef("System.AsyncCallback"), $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CompleteWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:true , Public:false}, "End", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:true , Public:false}, "OnWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Write", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "parent", $asm12.TypeRef("System.Net.Mime.QEncodedStream"));

    $.Field({Static:false, Public:false}, "buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "offset", $.Int32);

    $.Field({Static:false, Public:false}, "count", $.Int32);

    $.Field({Static:true , Public:false}, "onWrite", $asm0F.TypeRef("System.AsyncCallback"), function ($pi) {
        return $asm0F.System.AsyncCallback.New(null, null, new JSIL.MethodPointerInfo($thisType, "OnWrite", JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult")), true, false));
      });

    $.Field({Static:false, Public:false}, "written", $.Int32);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Mime.SmtpDateTime */ 

(function SmtpDateTime$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Mime.SmtpDateTime", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "FormatDate", 
      new JSIL.MethodSignature($.String, [$asm0F.TypeRef("System.DateTime")])
    );

    $.ExternalMethod({Static:true , Public:false}, "InitializeShortHandLookups", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $asm0F.TypeRef("System.TimeSpan")]))
    );

    $.ExternalMethod({Static:false, Public:false}, "ParseValue", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.DateTime"), [$.String, $jsilcore.TypeRef("JSIL.Reference", [$.String])])
    );

    $.ExternalMethod({Static:false, Public:false}, "TimeSpanToOffset", 
      new JSIL.MethodSignature($.String, [$asm0F.TypeRef("System.TimeSpan")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "TryParseTimeZoneString", 
      new JSIL.MethodSignature($.Boolean, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.TimeSpan")])])
    );

    $.ExternalMethod({Static:false, Public:false}, "ValidateAndGetTimeZoneOffsetValues", 
      new JSIL.MethodSignature(null, [
          $.String, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "ValidateTimeZoneShortHandValue", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "validDateTimeFormats", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "allowedWhiteSpaceChars", $jsilcore.TypeRef("System.Array", [$.Char]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "timeZoneOffsetLookup", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $asm0F.TypeRef("System.TimeSpan")]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "timeSpanMaxTicks", $.Int64, 3599400000000);

    $.Field({Static:true , Public:false, ReadOnly:true }, "offsetMaxValue", $.Int32, 9959);

    $.Field({Static:false, Public:false, ReadOnly:true }, "date", $asm0F.TypeRef("System.DateTime"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "timeZone", $asm0F.TypeRef("System.TimeSpan"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "unknownTimeZone", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Net.Cache");
/* class System.Net.Cache.RequestCacheBinding */ 

(function RequestCacheBinding$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Cache.RequestCacheBinding", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Net.Configuration");
/* enum System.Net.Configuration.UnicodeDecodingConformance */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Configuration.UnicodeDecodingConformance", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Auto: 0, 
    Strict: 1, 
    Compat: 2, 
    Loose: 3, 
  }
);

/* enum System.Net.Configuration.UnicodeEncodingConformance */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Configuration.UnicodeEncodingConformance", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Auto: 0, 
    Strict: 1, 
    Compat: 2, 
  }
);

/* class System.Net.Configuration.ConfigurationStrings */ 

(function ConfigurationStrings$Members () {
  var $, $thisType;



  JSIL.MakeStaticClass("System.Net.Configuration.ConfigurationStrings", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "get_SettingsSectionPath", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetSectionPath", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.Property({Static:true , Public:false}, "SettingsSectionPath", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.HttpWebRequestElement */ 

(function HttpWebRequestElement$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.HttpWebRequestElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_MaximumErrorResponseLength", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MaximumResponseHeadersLength", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MaximumUnauthorizedUploadLength", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_UseUnsafeHeaderParsing", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "PostDeserialize", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "maximumResponseHeadersLength", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "maximumErrorResponseLength", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "maximumUnauthorizedUploadLength", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "useUnsafeHeaderParsing", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true }, "MaximumUnauthorizedUploadLength", $.Int32)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["maximumUnauthorizedUploadLength"]; });

    $.Property({Static:false, Public:true }, "MaximumErrorResponseLength", $.Int32)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["maximumErrorResponseLength"]; });

    $.Property({Static:false, Public:true }, "MaximumResponseHeadersLength", $.Int32)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["maximumResponseHeadersLength"]; });

    $.Property({Static:false, Public:true }, "UseUnsafeHeaderParsing", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["useUnsafeHeaderParsing"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.HttpListenerElement */ 

(function HttpListenerElement$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.HttpListenerElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Timeouts", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.HttpListenerTimeoutsElement"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_UnescapeRequestUrl", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:true , Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "unescapeRequestUrl", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "timeouts", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "UnescapeRequestUrl", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["unescapeRequestUrl"]; });

    $.Property({Static:false, Public:true }, "Timeouts", $asm12.TypeRef("System.Net.Configuration.HttpListenerTimeoutsElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["timeouts"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.HttpListenerTimeoutsElement */ 

(function HttpListenerTimeoutsElement$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.HttpListenerTimeoutsElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CreateTimeSpanProperty", 
      new JSIL.MethodSignature($asm14.TypeRef("System.Configuration.ConfigurationProperty"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_DrainEntityBody", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.TimeSpan"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_EntityBody", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.TimeSpan"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_HeaderWait", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.TimeSpan"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_IdleConnection", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.TimeSpan"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MinSendBytesPerSecond", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_RequestQueue", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.TimeSpan"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetTimeouts", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Int64]))
    );

    $.Field({Static:true , Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "entityBody", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "drainEntityBody", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "requestQueue", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "idleConnection", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "headerWait", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "minSendBytesPerSecond", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "EntityBody", $asm0F.TypeRef("System.TimeSpan"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["entityBody"]; });

    $.Property({Static:false, Public:true }, "DrainEntityBody", $asm0F.TypeRef("System.TimeSpan"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["drainEntityBody"]; });

    $.Property({Static:false, Public:true }, "RequestQueue", $asm0F.TypeRef("System.TimeSpan"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["requestQueue"]; });

    $.Property({Static:false, Public:true }, "IdleConnection", $asm0F.TypeRef("System.TimeSpan"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["idleConnection"]; });

    $.Property({Static:false, Public:true }, "HeaderWait", $asm0F.TypeRef("System.TimeSpan"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["headerWait"]; });

    $.Property({Static:false, Public:true }, "MinSendBytesPerSecond", $.Int64)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["minSendBytesPerSecond"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.HttpListenerTimeoutsElement+TimeSpanValidator */ 

(function TimeSpanValidator$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationValidatorBase"), 
      Name: "System.Net.Configuration.HttpListenerTimeoutsElement+TimeSpanValidator", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CanValidate", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Type")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Validate", 
      JSIL.MethodSignature.Action($.Object)
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.HttpListenerTimeoutsElement+LongValidator */ 

(function LongValidator$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationValidatorBase"), 
      Name: "System.Net.Configuration.HttpListenerTimeoutsElement+LongValidator", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CanValidate", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Type")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Validate", 
      JSIL.MethodSignature.Action($.Object)
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.Ipv6Element */ 

(function Ipv6Element$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.Ipv6Element", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_Enabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.Field({Static:false, Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "enabled", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true }, "Enabled", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["enabled"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.PerformanceCountersElement */ 

(function PerformanceCountersElement$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.PerformanceCountersElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_Enabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.Field({Static:false, Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "enabled", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "Enabled", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["enabled"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.RequestCachingSectionInternal */ 

(function RequestCachingSectionInternal$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Configuration.RequestCachingSectionInternal", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.SettingsSection */ 

(function SettingsSection$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationSection"), 
      Name: "System.Net.Configuration.SettingsSection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_HttpListener", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.HttpListenerElement"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_HttpWebRequest", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.HttpWebRequestElement"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Ipv6", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.Ipv6Element"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_PerformanceCounters", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.PerformanceCountersElement"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ServicePointManager", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.ServicePointManagerElement"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Socket", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.SocketElement"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_WebProxyScript", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.WebProxyScriptElement"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_WebUtility", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.WebUtilityElement"))
    );

    $.Field({Static:false, Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "httpWebRequest", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "ipv6", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "servicePointManager", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "socket", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "webProxyScript", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "performanceCounters", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "httpListener", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "webUtility", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "HttpWebRequest", $asm12.TypeRef("System.Net.Configuration.HttpWebRequestElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["httpWebRequest"]; });

    $.Property({Static:false, Public:true }, "Ipv6", $asm12.TypeRef("System.Net.Configuration.Ipv6Element"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["ipv6"]; });

    $.Property({Static:false, Public:true }, "ServicePointManager", $asm12.TypeRef("System.Net.Configuration.ServicePointManagerElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["servicePointManager"]; });

    $.Property({Static:false, Public:true }, "Socket", $asm12.TypeRef("System.Net.Configuration.SocketElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["socket"]; });

    $.Property({Static:false, Public:true }, "WebProxyScript", $asm12.TypeRef("System.Net.Configuration.WebProxyScriptElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["webProxyScript"]; });

    $.Property({Static:false, Public:true }, "PerformanceCounters", $asm12.TypeRef("System.Net.Configuration.PerformanceCountersElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["performanceCounters"]; });

    $.Property({Static:false, Public:true }, "HttpListener", $asm12.TypeRef("System.Net.Configuration.HttpListenerElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["httpListener"]; });

    $.Property({Static:false, Public:true }, "WebUtility", $asm12.TypeRef("System.Net.Configuration.WebUtilityElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["webUtility"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.SettingsSectionInternal */ 

(function SettingsSectionInternal$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm12.System.Net.Configuration.UnicodeDecodingConformance)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm12.System.Net.Configuration.UnicodeEncodingConformance)) ();
  };







  function SettingsSectionInternal_set_WebUtilityUnicodeDecodingConformance (value) {
    this.SettingsSectionInternal$WebUtilityUnicodeDecodingConformance$value = value;
  }; 

  function SettingsSectionInternal_set_WebUtilityUnicodeEncodingConformance (value) {
    this.SettingsSectionInternal$WebUtilityUnicodeEncodingConformance$value = value;
  }; 

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Configuration.SettingsSectionInternal", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Configuration.SettingsSection"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_InternalSyncObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Ipv6Enabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_PerformanceCountersEnabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_Section", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.Method({Static:false, Public:false}, "set_WebUtilityUnicodeDecodingConformance", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Configuration.UnicodeDecodingConformance")), 
      SettingsSectionInternal_set_WebUtilityUnicodeDecodingConformance
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false}, "set_WebUtilityUnicodeEncodingConformance", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Configuration.UnicodeEncodingConformance")), 
      SettingsSectionInternal_set_WebUtilityUnicodeEncodingConformance
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:true , Public:false}, "s_InternalSyncObject", $.Object);

    $.Field({Static:false, Public:false}, "SettingsSectionInternal$WebUtilityUnicodeDecodingConformance$value", $asm12.TypeRef("System.Net.Configuration.UnicodeDecodingConformance"))
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:false, Public:false}, "SettingsSectionInternal$WebUtilityUnicodeEncodingConformance$value", $asm12.TypeRef("System.Net.Configuration.UnicodeEncodingConformance"))
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:true , Public:false}, "s_settings", $asm12.TypeRef("System.Net.Configuration.SettingsSectionInternal"));

    $.Field({Static:false, Public:false}, "alwaysUseCompletionPortsForAccept", $.Boolean);

    $.Field({Static:false, Public:false}, "alwaysUseCompletionPortsForConnect", $.Boolean);

    $.Field({Static:false, Public:false}, "checkCertificateName", $.Boolean);

    $.Field({Static:false, Public:false}, "checkCertificateRevocationList", $.Boolean);

    $.Field({Static:false, Public:false}, "downloadTimeout", $.Int32);

    $.Field({Static:false, Public:false}, "dnsRefreshTimeout", $.Int32);

    $.Field({Static:false, Public:false}, "enableDnsRoundRobin", $.Boolean);

    $.Field({Static:false, Public:false}, "encryptionPolicy", $asm12.TypeRef("System.Net.Security.EncryptionPolicy"));

    $.Field({Static:false, Public:false}, "expect100Continue", $.Boolean);

    $.Field({Static:false, Public:false}, "ipProtectionLevel", $asm12.TypeRef("System.Net.Sockets.IPProtectionLevel"));

    $.Field({Static:false, Public:false}, "ipv6Enabled", $.Boolean);

    $.Field({Static:false, Public:false}, "maximumResponseHeadersLength", $.Int32);

    $.Field({Static:false, Public:false}, "maximumErrorResponseLength", $.Int32);

    $.Field({Static:false, Public:false}, "maximumUnauthorizedUploadLength", $.Int32);

    $.Field({Static:false, Public:false}, "useUnsafeHeaderParsing", $.Boolean);

    $.Field({Static:false, Public:false}, "useNagleAlgorithm", $.Boolean);

    $.Field({Static:false, Public:false}, "performanceCountersEnabled", $.Boolean);

    $.Field({Static:false, Public:false}, "httpListenerUnescapeRequestUrl", $.Boolean);

    $.Field({Static:false, Public:false}, "httpListenerTimeouts", $jsilcore.TypeRef("System.Array", [$.Int64]));

    $.Property({Static:true , Public:false}, "Section", $.Type);

    $.Property({Static:true , Public:false}, "InternalSyncObject", $.Object);

    $.Property({Static:false, Public:false}, "Ipv6Enabled", $.Boolean);

    $.Property({Static:false, Public:false}, "PerformanceCountersEnabled", $.Boolean);

    $.Property({Static:false, Public:false}, "WebUtilityUnicodeDecodingConformance", $asm12.TypeRef("System.Net.Configuration.UnicodeDecodingConformance"));

    $.Property({Static:false, Public:false}, "WebUtilityUnicodeEncodingConformance", $asm12.TypeRef("System.Net.Configuration.UnicodeEncodingConformance"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.ServicePointManagerElement */ 

(function ServicePointManagerElement$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.ServicePointManagerElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_CheckCertificateName", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_CheckCertificateRevocationList", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_DnsRefreshTimeout", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_EnableDnsRoundRobin", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_EncryptionPolicy", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Security.EncryptionPolicy"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Expect100Continue", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_UseNagleAlgorithm", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "PostDeserialize", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "checkCertificateName", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "checkCertificateRevocationList", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "dnsRefreshTimeout", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "enableDnsRoundRobin", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "encryptionPolicy", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "expect100Continue", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "useNagleAlgorithm", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "CheckCertificateName", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["checkCertificateName"]; });

    $.Property({Static:false, Public:true }, "CheckCertificateRevocationList", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["checkCertificateRevocationList"]; });

    $.Property({Static:false, Public:true }, "DnsRefreshTimeout", $.Int32)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["dnsRefreshTimeout"]; });

    $.Property({Static:false, Public:true }, "EnableDnsRoundRobin", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["enableDnsRoundRobin"]; });

    $.Property({Static:false, Public:true }, "EncryptionPolicy", $asm12.TypeRef("System.Net.Security.EncryptionPolicy"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["encryptionPolicy"]; });

    $.Property({Static:false, Public:true }, "Expect100Continue", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["expect100Continue"]; });

    $.Property({Static:false, Public:true }, "UseNagleAlgorithm", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["useNagleAlgorithm"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.SocketElement */ 

(function SocketElement$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.SocketElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_AlwaysUseCompletionPortsForAccept", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AlwaysUseCompletionPortsForConnect", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_IPProtectionLevel", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.IPProtectionLevel"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "PostDeserialize", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "alwaysUseCompletionPortsForConnect", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "alwaysUseCompletionPortsForAccept", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "ipProtectionLevel", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "AlwaysUseCompletionPortsForAccept", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["alwaysUseCompletionPortsForAccept"]; });

    $.Property({Static:false, Public:true }, "AlwaysUseCompletionPortsForConnect", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["alwaysUseCompletionPortsForConnect"]; });

    $.Property({Static:false, Public:true }, "IPProtectionLevel", $asm12.TypeRef("System.Net.Sockets.IPProtectionLevel"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["ipProtectionLevel"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.WebProxyScriptElement */ 

(function WebProxyScriptElement$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.WebProxyScriptElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_DownloadTimeout", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.TimeSpan"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "PostDeserialize", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "downloadTimeout", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "DownloadTimeout", $asm0F.TypeRef("System.TimeSpan"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["downloadTimeout"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Configuration.WebUtilityElement */ 

(function WebUtilityElement$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Net.Configuration.WebUtilityElement", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_UnicodeDecodingConformance", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.UnicodeDecodingConformance"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_UnicodeEncodingConformance", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Configuration.UnicodeEncodingConformance"))
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "unicodeDecodingConformance", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "unicodeEncodingConformance", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true }, "UnicodeDecodingConformance", $asm12.TypeRef("System.Net.Configuration.UnicodeDecodingConformance"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["unicodeDecodingConformance"]; });

    $.Property({Static:false, Public:true }, "UnicodeEncodingConformance", $asm12.TypeRef("System.Net.Configuration.UnicodeEncodingConformance"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["unicodeEncodingConformance"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Net.Security");
/* enum System.Net.Security.EncryptionPolicy */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Security.EncryptionPolicy", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    RequireEncryption: 0, 
    AllowNoEncryption: 1, 
    NoEncryption: 2, 
  }
);

JSIL.DeclareNamespace("System.Net.Sockets");
/* class System.ComponentModel.Win32Exception */ 

(function Win32Exception$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Runtime.InteropServices.ExternalException"), 
      Name: "System.ComponentModel.Win32Exception", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Int32, $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_NativeErrorCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetErrorMessage", 
      new JSIL.MethodSignature($.String, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    );

    $.ExternalMethod({Static:true , Public:false}, "TryGetErrorMessage", 
      new JSIL.MethodSignature($.Boolean, [
          $.Int32, $asm0F.TypeRef("System.Text.StringBuilder"), 
          $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "nativeErrorCode", $.Int32);

    $.Property({Static:false, Public:true }, "NativeErrorCode", $.Int32);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.SocketException */ 

(function SocketException$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.ComponentModel.Win32Exception"), 
      Name: "System.Net.Sockets.SocketException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Sockets.SocketError"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_ErrorCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Message", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "m_EndPoint", $asm12.TypeRef("System.Net.EndPoint"));

    $.Property({Static:false, Public:true , Virtual:true }, "ErrorCode", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "Message", $.String);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.Sockets.AddressFamily */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.AddressFamily", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Unknown: -1, 
    Unspecified: 0, 
    Unix: 1, 
    InterNetwork: 2, 
    ImpLink: 3, 
    Pup: 4, 
    Chaos: 5, 
    NS: 6, 
    Ipx: 6, 
    Osi: 7, 
    Iso: 7, 
    Ecma: 8, 
    DataKit: 9, 
    Ccitt: 10, 
    Sna: 11, 
    DecNet: 12, 
    DataLink: 13, 
    Lat: 14, 
    HyperChannel: 15, 
    AppleTalk: 16, 
    NetBios: 17, 
    VoiceView: 18, 
    FireFox: 19, 
    Banyan: 21, 
    Atm: 22, 
    InterNetworkV6: 23, 
    Cluster: 24, 
    Ieee12844: 25, 
    Irda: 26, 
    NetworkDesigners: 28, 
    Max: 29, 
  }
);

/* enum System.Net.Sockets.AsyncEventBits */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.AsyncEventBits", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: true, 
  }, 
  {
    FdNone: 0, 
    FdRead: 1, 
    FdWrite: 2, 
    FdOob: 4, 
    FdAccept: 8, 
    FdConnect: 16, 
    FdClose: 32, 
    FdQos: 64, 
    FdGroupQos: 128, 
    FdRoutingInterfaceChange: 256, 
    FdAddressListChange: 512, 
    FdAllEvents: 1023, 
  }
);

/* enum System.Net.Sockets.IPProtectionLevel */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.IPProtectionLevel", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Unspecified: -1, 
    Unrestricted: 10, 
    EdgeRestricted: 20, 
    Restricted: 30, 
  }
);

/* class System.Net.Sockets.LingerOption */ 

(function LingerOption$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Sockets.LingerOption", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Boolean, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Enabled", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_LingerTime", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.Field({Static:false, Public:false}, "enabled", $.Boolean);

    $.Field({Static:false, Public:false}, "lingerTime", $.Int32);

    $.Property({Static:false, Public:true }, "Enabled", $.Boolean);

    $.Property({Static:false, Public:true }, "LingerTime", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.MulticastOption */ 

(function MulticastOption$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Sockets.MulticastOption", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.IPAddress"), $asm12.TypeRef("System.Net.IPAddress")])
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Group", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.IPAddress"))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_LocalAddress", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.IPAddress"))
    );

    $.Field({Static:false, Public:false}, "group", $asm12.TypeRef("System.Net.IPAddress"));

    $.Field({Static:false, Public:false}, "localAddress", $asm12.TypeRef("System.Net.IPAddress"));

    $.Field({Static:false, Public:false}, "ifIndex", $.Int32);

    $.Property({Static:false, Public:true }, "Group", $asm12.TypeRef("System.Net.IPAddress"));

    $.Property({Static:false, Public:true }, "LocalAddress", $asm12.TypeRef("System.Net.IPAddress"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.IPv6MulticastOption */ 

(function IPv6MulticastOption$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Sockets.IPv6MulticastOption", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.IPAddress"), $.Int64])
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Group", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.IPAddress"))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_InterfaceIndex", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.Field({Static:false, Public:false}, "m_Group", $asm12.TypeRef("System.Net.IPAddress"));

    $.Field({Static:false, Public:false}, "m_Interface", $.Int64);

    $.Property({Static:false, Public:true }, "Group", $asm12.TypeRef("System.Net.IPAddress"));

    $.Property({Static:false, Public:true }, "InterfaceIndex", $.Int64);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.NetworkStream */ 

(function NetworkStream$Members () {
  var $, $thisType;
























  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.IO.Stream"), 
      Name: "System.Net.Sockets.NetworkStream", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginRead", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginWrite", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndRead", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Flush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanRead", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanSeek", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanTimeout", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanWrite", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Position", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_ReadTimeout", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_WriteTimeout", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Read", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Seek", 
      new JSIL.MethodSignature($.Int64, [$.Int64, $asm0F.TypeRef("System.IO.SeekOrigin")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Position", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_ReadTimeout", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_WriteTimeout", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "SetSocketTimeoutOption", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Net.Sockets.SocketShutdown"), $.Int32, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "UnsafeBeginRead", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "UnsafeBeginWrite", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.Field({Static:false, Public:false}, "m_StreamSocket", $asm12.TypeRef("System.Net.Sockets.Socket"));

    $.Field({Static:false, Public:false}, "m_Readable", $.Boolean);

    $.Field({Static:false, Public:false}, "m_Writeable", $.Boolean);

    $.Field({Static:false, Public:false}, "m_OwnsSocket", $.Boolean);

    $.Field({Static:false, Public:false}, "m_CloseTimeout", $.Int32);

    $.Field({Static:false, Public:false}, "m_CleanedUp", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:false, Public:false}, "m_CurrentReadTimeout", $.Int32);

    $.Field({Static:false, Public:false}, "m_CurrentWriteTimeout", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "CanRead", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanSeek", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanWrite", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanTimeout", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "ReadTimeout", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "WriteTimeout", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "Length", $.Int64);

    $.Property({Static:false, Public:true , Virtual:true }, "Position", $.Int64);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.Sockets.ProtocolFamily */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.ProtocolFamily", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Unknown: -1, 
    Unspecified: 0, 
    Unix: 1, 
    InterNetwork: 2, 
    ImpLink: 3, 
    Pup: 4, 
    Chaos: 5, 
    NS: 6, 
    Ipx: 6, 
    Osi: 7, 
    Iso: 7, 
    Ecma: 8, 
    DataKit: 9, 
    Ccitt: 10, 
    Sna: 11, 
    DecNet: 12, 
    DataLink: 13, 
    Lat: 14, 
    HyperChannel: 15, 
    AppleTalk: 16, 
    NetBios: 17, 
    VoiceView: 18, 
    FireFox: 19, 
    Banyan: 21, 
    Atm: 22, 
    InterNetworkV6: 23, 
    Cluster: 24, 
    Ieee12844: 25, 
    Irda: 26, 
    NetworkDesigners: 28, 
    Max: 29, 
  }
);

/* enum System.Net.Sockets.ProtocolType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.ProtocolType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Unknown: -1, 
    IPv6HopByHopOptions: 0, 
    Unspecified: 0, 
    IP: 0, 
    Icmp: 1, 
    Igmp: 2, 
    Ggp: 3, 
    IPv4: 4, 
    Tcp: 6, 
    Pup: 12, 
    Udp: 17, 
    Idp: 22, 
    IPv6: 41, 
    IPv6RoutingHeader: 43, 
    IPv6FragmentHeader: 44, 
    IPSecEncapsulatingSecurityPayload: 50, 
    IPSecAuthenticationHeader: 51, 
    IcmpV6: 58, 
    IPv6NoNextHeader: 59, 
    IPv6DestinationOptions: 60, 
    ND: 77, 
    Raw: 255, 
    Ipx: 1000, 
    Spx: 1256, 
    SpxII: 1257, 
  }
);

/* class System.Net.Sockets.Socket */ 

(function Socket$Members () {
  var $, $thisType;


















































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Sockets.Socket", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "BeginReceive", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $asm0F.TypeRef("System.AsyncCallback"), $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "BeginReceive", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketError")]), $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "BeginSend", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $asm0F.TypeRef("System.AsyncCallback"), $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "BeginSend", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketError")]), $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "BindToCompletionPort", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "Close", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "CompleteAccept", 
      new JSIL.MethodSignature(null, [$.Type, $asm12.TypeRef("System.Net.Sockets.Socket+TaskSocketAsyncEventArgs`1", [$.Type])])
    );

    $.ExternalMethod({Static:false, Public:false}, "CompleteAcceptResults", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:true , Public:false}, "CompleteSendReceive", 
      new JSIL.MethodSignature(null, [
          $.Type, $asm12.TypeRef("System.Net.Sockets.Socket+Int32TaskSocketAsyncEventArgs"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "DoBeginReceive", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $asm12.TypeRef("System.Net.Sockets.OverlappedAsyncResult")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "DoBeginSend", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $asm12.TypeRef("System.Net.Sockets.OverlappedAsyncResult")
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "EndReceive", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:false, Public:true }, "EndReceive", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketError")])])
    );

    $.ExternalMethod({Static:false, Public:true }, "EndSend", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:false, Public:true }, "EndSend", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult"), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketError")])])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Caches", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.Socket+CacheSet"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_CleanedUp", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_InternalSyncObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_LegacySupportsIPv6", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_OSSupportsIPv6", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_SafeHandle", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.SafeCloseSocket"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Transport", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.TransportType"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_UseOnlyOverlappedIO", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetAcceptQueue", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Queue"))
    );

    $.ExternalMethod({Static:true , Public:false}, "GetException", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Exception"), [$asm12.TypeRef("System.Net.Sockets.SocketError"), $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "getIPv6MulticastOpt", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.IPv6MulticastOption"), [$asm12.TypeRef("System.Net.Sockets.SocketOptionName")])
    );

    $.ExternalMethod({Static:false, Public:false}, "getLingerOpt", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.LingerOption"))
    );

    $.ExternalMethod({Static:false, Public:false}, "getMulticastOpt", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.MulticastOption"), [$asm12.TypeRef("System.Net.Sockets.SocketOptionName")])
    );

    $.ExternalMethod({Static:false, Public:true }, "GetSocketOption", 
      new JSIL.MethodSignature($.Object, [$asm12.TypeRef("System.Net.Sockets.SocketOptionLevel"), $asm12.TypeRef("System.Net.Sockets.SocketOptionName")])
    );

    $.ExternalMethod({Static:true , Public:false}, "InitializeSockets", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalSetBlocking", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [$.Boolean, $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])])
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalSetBlocking", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalShutdown", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Sockets.SocketShutdown"))
    );

    $.ExternalMethod({Static:false, Public:true }, "Receive", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags")
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "Receive", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketError")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReturnSocketAsyncEventArgs", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Net.Sockets.Socket+Int32TaskSocketAsyncEventArgs"), $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReturnSocketAsyncEventArgs", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Sockets.Socket+TaskSocketAsyncEventArgs`1", [$.Type]))
    );

    $.ExternalMethod({Static:false, Public:true }, "Send", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags")
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "Send", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.SocketError")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "SetSocketOption", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Net.Sockets.SocketOptionLevel"), $asm12.TypeRef("System.Net.Sockets.SocketOptionName"), 
          $.Int32, $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "SetToDisconnected", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "UnsafeBeginReceive", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $asm0F.TypeRef("System.AsyncCallback"), $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "UnsafeBeginSend", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.Sockets.SocketFlags"), 
          $asm0F.TypeRef("System.AsyncCallback"), $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "UnsetAsyncEventSelect", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "UpdateStatusAfterSocketError", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Sockets.SocketException"))
    );

    $.ExternalMethod({Static:false, Public:false}, "UpdateStatusAfterSocketError", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Sockets.SocketError"))
    );

    $.ExternalMethod({Static:false, Public:false}, "ValidateBlockingMode", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "m_AcceptQueueOrConnectResult", $.Object);

    $.Field({Static:false, Public:false}, "m_Handle", $asm12.TypeRef("System.Net.SafeCloseSocket"));

    $.Field({Static:false, Public:false}, "m_IsConnected", $.Boolean);

    $.Field({Static:false, Public:false}, "m_IsDisconnected", $.Boolean);

    $.Field({Static:false, Public:false}, "willBlock", $.Boolean);

    $.Field({Static:false, Public:false}, "willBlockInternal", $.Boolean);

    $.Field({Static:false, Public:false}, "protocolType", $asm12.TypeRef("System.Net.Sockets.ProtocolType"));

    $.Field({Static:false, Public:false}, "m_Caches", $asm12.TypeRef("System.Net.Sockets.Socket+CacheSet"));

    $.Field({Static:true , Public:false}, "UseOverlappedIO", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:false, Public:false}, "useOverlappedIO", $.Boolean);

    $.Field({Static:false, Public:false}, "m_BoundToThreadPool", $.Boolean);

    $.Field({Static:false, Public:false}, "m_ReceivingPacketInformation", $.Boolean);

    $.Field({Static:false, Public:false}, "m_AsyncEvent", $asm0F.TypeRef("System.Threading.ManualResetEvent"));

    $.Field({Static:false, Public:false}, "m_RegisteredWait", $asm0F.TypeRef("System.Threading.RegisteredWaitHandle"));

    $.Field({Static:false, Public:false}, "m_BlockEventBits", $asm12.TypeRef("System.Net.Sockets.AsyncEventBits"));

    $.Field({Static:true , Public:false}, "s_InternalSyncObject", $.Object);

    $.Field({Static:false, Public:false}, "m_CloseTimeout", $.Int32);

    $.Field({Static:false, Public:false}, "m_IntCleanedUp", $.Int32);

    $.Field({Static:true , Public:false, ReadOnly:true }, "protocolInformationSize", $.Int32);

    $.Field({Static:true , Public:false}, "s_SupportsIPv4", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_SupportsIPv6", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_OSSupportsIPv6", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_Initialized", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_LoggingEnabled", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_PerfCountersEnabled", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "AcceptCompletedHandler", $asm0F.TypeRef("System.EventHandler`1", [$asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")]), function ($pi) {
        return $asm0F.System.EventHandler$b1.Of($asm12.System.Net.Sockets.SocketAsyncEventArgs).New($asm12.System.Net.Sockets.Socket_$l$gc.$l$g9, null, new JSIL.MethodPointerInfo($asm12.System.Net.Sockets.Socket_$l$gc, "$l_cctor$gb__346_0", new JSIL.MethodSignature(null, [$.Object, $asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")]), false, false));
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "ReceiveCompletedHandler", $asm0F.TypeRef("System.EventHandler`1", [$asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")]), function ($pi) {
        return $asm0F.System.EventHandler$b1.Of($asm12.System.Net.Sockets.SocketAsyncEventArgs).New($asm12.System.Net.Sockets.Socket_$l$gc.$l$g9, null, new JSIL.MethodPointerInfo($asm12.System.Net.Sockets.Socket_$l$gc, "$l_cctor$gb__346_1", new JSIL.MethodSignature(null, [$.Object, $asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")]), false, false));
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "SendCompletedHandler", $asm0F.TypeRef("System.EventHandler`1", [$asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")]), function ($pi) {
        return $asm0F.System.EventHandler$b1.Of($asm12.System.Net.Sockets.SocketAsyncEventArgs).New($asm12.System.Net.Sockets.Socket_$l$gc.$l$g9, null, new JSIL.MethodPointerInfo($asm12.System.Net.Sockets.Socket_$l$gc, "$l_cctor$gb__346_2", new JSIL.MethodSignature(null, [$.Object, $asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")]), false, false));
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_rentedSocketSentinel", $asm12.TypeRef("System.Net.Sockets.Socket+TaskSocketAsyncEventArgs`1", [$.Type]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_rentedInt32Sentinel", $asm12.TypeRef("System.Net.Sockets.Socket+Int32TaskSocketAsyncEventArgs"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_zeroTask", $asm0F.TypeRef("System.Threading.Tasks.Task`1", [$.Int32]));

    $.Field({Static:false, Public:false}, "_cachedTaskEventArgs", $asm12.TypeRef("System.Net.Sockets.Socket+CachedTaskEventArgs"));

    $.Property({Static:true , Public:false}, "LegacySupportsIPv6", $.Boolean);

    $.Property({Static:true , Public:true }, "OSSupportsIPv6", $.Boolean);

    $.Property({Static:false, Public:false}, "SafeHandle", $asm12.TypeRef("System.Net.SafeCloseSocket"));

    $.Property({Static:false, Public:true }, "UseOnlyOverlappedIO", $.Boolean);

    $.Property({Static:true , Public:false}, "InternalSyncObject", $.Object);

    $.Property({Static:false, Public:false}, "Caches", $asm12.TypeRef("System.Net.Sockets.Socket+CacheSet"));

    $.Property({Static:false, Public:false}, "CleanedUp", $.Boolean);

    $.Property({Static:false, Public:false}, "Transport", $asm12.TypeRef("System.Net.TransportType"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.Socket+CacheSet */ 

(function CacheSet$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Sockets.Socket+CacheSet", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "SendClosureCache", $asm12.TypeRef("System.Net.CallbackClosure"));

    $.Field({Static:false, Public:false}, "ReceiveClosureCache", $asm12.TypeRef("System.Net.CallbackClosure"));

    $.Field({Static:false, Public:false}, "SendOverlappedCache", $asm12.TypeRef("System.Net.Sockets.OverlappedCache"));

    $.Field({Static:false, Public:false}, "ReceiveOverlappedCache", $asm12.TypeRef("System.Net.Sockets.OverlappedCache"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.Socket+CachedTaskEventArgs */ 

(function CachedTaskEventArgs$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Sockets.Socket+CachedTaskEventArgs", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "Accept", $asm12.TypeRef("System.Net.Sockets.Socket+TaskSocketAsyncEventArgs`1", [$asm12.TypeRef("System.Net.Sockets.Socket")]));

    $.Field({Static:false, Public:true }, "Receive", $asm12.TypeRef("System.Net.Sockets.Socket+Int32TaskSocketAsyncEventArgs"));

    $.Field({Static:false, Public:true }, "Send", $asm12.TypeRef("System.Net.Sockets.Socket+Int32TaskSocketAsyncEventArgs"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.SocketAsyncEventArgs */ 

(function SocketAsyncEventArgs$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.EventArgs"), 
      Name: "System.Net.Sockets.SocketAsyncEventArgs", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ExecutionCallback", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "FreeOverlapped", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AcceptSocket", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.Socket"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_BytesTransferred", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SocketError", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.Sockets.SocketError"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnCompleted", 
      JSIL.MethodSignature.Action($.Type)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_AcceptSocket", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Net.Sockets.Socket"))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_ControlDataSize", $.Int32);

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_ControlDataIPv6Size", $.Int32);

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_WSAMsgSize", $.Int32);

    $.Field({Static:false, Public:false}, "m_AcceptSocket", $asm12.TypeRef("System.Net.Sockets.Socket"));

    $.Field({Static:false, Public:false}, "m_BytesTransferred", $.Int32);

    $.Field({Static:false, Public:false}, "m_Completed", $asm0F.TypeRef("System.EventHandler`1", [$.Type]))
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:false, Public:false}, "m_SendPacketsSendSize", $.Int32);

    $.Field({Static:false, Public:false}, "m_SocketError", $asm12.TypeRef("System.Net.Sockets.SocketError"));

    $.Field({Static:false, Public:false}, "m_SocketAddressGCHandle", $asm0F.TypeRef("System.Runtime.InteropServices.GCHandle"));

    $.Field({Static:false, Public:false}, "m_WSAMessageBufferGCHandle", $asm0F.TypeRef("System.Runtime.InteropServices.GCHandle"));

    $.Field({Static:false, Public:false}, "m_ControlBufferGCHandle", $asm0F.TypeRef("System.Runtime.InteropServices.GCHandle"));

    $.Field({Static:false, Public:false}, "m_WSARecvMsgWSABufferArrayGCHandle", $asm0F.TypeRef("System.Runtime.InteropServices.GCHandle"));

    $.Field({Static:false, Public:false}, "m_ExecutionCallback", $asm0F.TypeRef("System.Threading.ContextCallback"));

    $.Field({Static:false, Public:false}, "m_CurrentSocket", $asm12.TypeRef("System.Net.Sockets.Socket"));

    $.Field({Static:false, Public:false}, "m_DisposeCalled", $.Boolean);

    $.Field({Static:false, Public:false}, "m_Operating", $.Int32);

    $.Field({Static:false, Public:false}, "m_PtrNativeOverlapped", $asm12.TypeRef("System.Net.SafeNativeOverlapped"));

    $.Field({Static:false, Public:false}, "m_Overlapped", $asm0F.TypeRef("System.Threading.Overlapped"));

    $.Field({Static:false, Public:false}, "m_PinState", $asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs+PinState"));

    $.Field({Static:false, Public:false}, "m_PinnedAcceptBuffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "m_PinnedSingleBuffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "m_PinnedSingleBufferOffset", $.Int32);

    $.Field({Static:false, Public:false}, "m_PinnedSingleBufferCount", $.Int32);

    $.Field({Static:true , Public:false}, "s_LoggingEnabled", $.Boolean);

    $.Property({Static:false, Public:true }, "AcceptSocket", $asm12.TypeRef("System.Net.Sockets.Socket"));

    $.Property({Static:false, Public:true }, "BytesTransferred", $.Int32);

    $.Property({Static:false, Public:true }, "SocketError", $asm12.TypeRef("System.Net.Sockets.SocketError"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Net.Sockets.SocketAsyncEventArgs+PinState */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.SocketAsyncEventArgs+PinState", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    None: 0, 
    NoBuffer: 1, 
    SingleAcceptBuffer: 2, 
    SingleBuffer: 3, 
    MultipleBuffer: 4, 
    SendPackets: 5, 
  }
);

/* class System.Net.Sockets.Socket+TaskSocketAsyncEventArgs`1 */ 

(function TaskSocketAsyncEventArgs$b1$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs"), 
      Name: "System.Net.Sockets.Socket+TaskSocketAsyncEventArgs`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TResult"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCompletionResponsibility", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1", [$.GenericParameter("TResult")]), [$jsilcore.TypeRef("JSIL.Reference", [$.Boolean])])
    );

    $.Field({Static:false, Public:false}, "_builder", $asm0F.TypeRef("System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1", [$.GenericParameter("TResult")]));

    $.Field({Static:false, Public:false}, "_accessed", $.Boolean);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.Socket+Int32TaskSocketAsyncEventArgs */ 

(function Int32TaskSocketAsyncEventArgs$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.Sockets.Socket+TaskSocketAsyncEventArgs`1", [$asm0F.TypeRef("System.Int32")]), 
      Name: "System.Net.Sockets.Socket+Int32TaskSocketAsyncEventArgs", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "_wrapExceptionsInIOExceptions", $.Boolean);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.Socket+<>c */ 

(function $l$gc$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Sockets.Socket+<>c", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$l.cctor$gb__346_0", 
      new JSIL.MethodSignature(null, [$.Object, $asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")])
    );

    $.ExternalMethod({Static:false, Public:false}, "$l.cctor$gb__346_1", 
      new JSIL.MethodSignature(null, [$.Object, $asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")])
    );

    $.ExternalMethod({Static:false, Public:false}, "$l.cctor$gb__346_2", 
      new JSIL.MethodSignature(null, [$.Object, $asm12.TypeRef("System.Net.Sockets.SocketAsyncEventArgs")])
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "$l$g9", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* enum System.Net.Sockets.SocketError */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.SocketError", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    SocketError: -1, 
    Success: 0, 
    OperationAborted: 995, 
    IOPending: 997, 
    Interrupted: 10004, 
    AccessDenied: 10013, 
    Fault: 10014, 
    InvalidArgument: 10022, 
    TooManyOpenSockets: 10024, 
    WouldBlock: 10035, 
    InProgress: 10036, 
    AlreadyInProgress: 10037, 
    NotSocket: 10038, 
    DestinationAddressRequired: 10039, 
    MessageSize: 10040, 
    ProtocolType: 10041, 
    ProtocolOption: 10042, 
    ProtocolNotSupported: 10043, 
    SocketNotSupported: 10044, 
    OperationNotSupported: 10045, 
    ProtocolFamilyNotSupported: 10046, 
    AddressFamilyNotSupported: 10047, 
    AddressAlreadyInUse: 10048, 
    AddressNotAvailable: 10049, 
    NetworkDown: 10050, 
    NetworkUnreachable: 10051, 
    NetworkReset: 10052, 
    ConnectionAborted: 10053, 
    ConnectionReset: 10054, 
    NoBufferSpaceAvailable: 10055, 
    IsConnected: 10056, 
    NotConnected: 10057, 
    Shutdown: 10058, 
    TimedOut: 10060, 
    ConnectionRefused: 10061, 
    HostDown: 10064, 
    HostUnreachable: 10065, 
    ProcessLimit: 10067, 
    SystemNotReady: 10091, 
    VersionNotSupported: 10092, 
    NotInitialized: 10093, 
    Disconnecting: 10101, 
    TypeNotFound: 10109, 
    HostNotFound: 11001, 
    TryAgain: 11002, 
    NoRecovery: 11003, 
    NoData: 11004, 
  }
);

/* enum System.Net.Sockets.SocketFlags */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.SocketFlags", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    None: 0, 
    OutOfBand: 1, 
    Peek: 2, 
    DontRoute: 4, 
    MaxIOVectorLength: 16, 
    Truncated: 256, 
    ControlDataTruncated: 512, 
    Broadcast: 1024, 
    Multicast: 2048, 
    Partial: 32768, 
  }
);

/* enum System.Net.Sockets.SocketOptionLevel */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.SocketOptionLevel", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    IP: 0, 
    Tcp: 6, 
    Udp: 17, 
    IPv6: 41, 
    Socket: 65535, 
  }
);

/* enum System.Net.Sockets.SocketOptionName */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.SocketOptionName", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    DontLinger: -129, 
    ExclusiveAddressUse: -5, 
    Debug: 1, 
    IPOptions: 1, 
    NoChecksum: 1, 
    NoDelay: 1, 
    AcceptConnection: 2, 
    HeaderIncluded: 2, 
    BsdUrgent: 2, 
    Expedited: 2, 
    TypeOfService: 3, 
    ReuseAddress: 4, 
    IpTimeToLive: 4, 
    KeepAlive: 8, 
    MulticastInterface: 9, 
    MulticastTimeToLive: 10, 
    MulticastLoopback: 11, 
    AddMembership: 12, 
    DropMembership: 13, 
    DontFragment: 14, 
    AddSourceMembership: 15, 
    DontRoute: 16, 
    DropSourceMembership: 16, 
    BlockSource: 17, 
    UnblockSource: 18, 
    PacketInformation: 19, 
    ChecksumCoverage: 20, 
    HopLimit: 21, 
    IPProtectionLevel: 23, 
    IPv6Only: 27, 
    Broadcast: 32, 
    UseLoopback: 64, 
    Linger: 128, 
    OutOfBandInline: 256, 
    SendBuffer: 4097, 
    ReceiveBuffer: 4098, 
    SendLowWater: 4099, 
    ReceiveLowWater: 4100, 
    SendTimeout: 4101, 
    ReceiveTimeout: 4102, 
    Error: 4103, 
    Type: 4104, 
    ReuseUnicastPort: 12295, 
    UpdateAcceptContext: 28683, 
    UpdateConnectContext: 28688, 
    MaxConnections: 2147483647, 
  }
);

/* enum System.Net.Sockets.SocketShutdown */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.SocketShutdown", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Receive: 0, 
    Send: 1, 
    Both: 2, 
  }
);

/* enum System.Net.Sockets.SocketType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Net.Sockets.SocketType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Unknown: -1, 
    Stream: 1, 
    Dgram: 2, 
    Raw: 3, 
    Rdm: 4, 
    Seqpacket: 5, 
  }
);

/* class System.Net.Sockets.BaseOverlappedAsyncResult */ 

(function BaseOverlappedAsyncResult$Members () {
  var $, $thisType;















  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.ContextAwareResult"), 
      Name: "System.Net.Sockets.BaseOverlappedAsyncResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Net.Sockets.Socket"), $.Object, 
          $asm0F.TypeRef("System.AsyncCallback")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckAsyncCallOverlappedResult", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Net.Sockets.SocketError"), [$asm12.TypeRef("System.Net.Sockets.SocketError")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Cleanup", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "CompletionPortCallback", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt32, 
          $jsilcore.TypeRef("JSIL.Pointer", [$asm0F.TypeRef("System.Threading.NativeOverlapped")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "ExtractCache", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.OverlappedCache")]))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "ForceReleaseUnmanagedStructures", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_OverlappedHandle", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"))
    );

    $.ExternalMethod({Static:false, Public:false}, "OverlappedCallback", 
      new JSIL.MethodSignature(null, [$.Object, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "PinUnmanagedObjects", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "PostCompletion", 
      new JSIL.MethodSignature($.Object, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReleaseGCHandles", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ReleaseUnmanagedStructures", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "SetUnmanagedStructures", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "SetupCache", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.OverlappedCache")]))
    );

    $.Field({Static:false, Public:false}, "m_UnmanagedBlob", $asm12.TypeRef("System.Net.SafeOverlappedFree"));

    $.Field({Static:false, Public:false}, "m_OverlappedEvent", $asm0F.TypeRef("System.Threading.AutoResetEvent"));

    $.Field({Static:false, Public:false}, "m_CleanupCount", $.Int32);

    $.Field({Static:false, Public:false}, "m_DisableOverlapped", $.Boolean);

    $.Field({Static:false, Public:false}, "m_UseOverlappedIO", $.Boolean);

    $.Field({Static:false, Public:false}, "m_GCHandles", $jsilcore.TypeRef("System.Array", [$asm0F.TypeRef("System.Runtime.InteropServices.GCHandle")]));

    $.Field({Static:false, Public:false}, "m_Cache", $asm12.TypeRef("System.Net.Sockets.OverlappedCache"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_IOCallback", $asm0F.TypeRef("System.Threading.IOCompletionCallback"), function ($pi) {
        return $asm0F.System.Threading.IOCompletionCallback.New(null, null, new JSIL.MethodPointerInfo($thisType, "CompletionPortCallback", new JSIL.MethodSignature(null, [
                $.UInt32, $.UInt32, 
                $jsilcore.TypeRef("JSIL.Pointer", [$asm0F.TypeRef("System.Threading.NativeOverlapped")])
              ]), true, false));
      });

    $.Property({Static:false, Public:false}, "OverlappedHandle", $asm0F.TypeRef("System.Runtime.InteropServices.SafeHandle"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.OverlappedCache */ 

(function OverlappedCache$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Net.Sockets.OverlappedCache", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.Threading.Overlapped"), $jsilcore.TypeRef("System.Array", [$.Object]), 
          $asm0F.TypeRef("System.Threading.IOCompletionCallback")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.Threading.Overlapped"), $.Object, 
          $asm0F.TypeRef("System.Threading.IOCompletionCallback"), $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Free", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_NativeOverlapped", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Net.SafeNativeOverlapped"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Overlapped", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Threading.Overlapped"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_PinnedObjects", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_PinnedObjectsArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Object]))
    );

    $.ExternalMethod({Static:true , Public:false}, "InterlockedFree", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type]))
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalFree", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "m_Overlapped", $asm0F.TypeRef("System.Threading.Overlapped"));

    $.Field({Static:false, Public:false}, "m_NativeOverlapped", $asm12.TypeRef("System.Net.SafeNativeOverlapped"));

    $.Field({Static:false, Public:false}, "m_PinnedObjects", $.Object);

    $.Field({Static:false, Public:false}, "m_PinnedObjectsArray", $jsilcore.TypeRef("System.Array", [$.Object]));

    $.Property({Static:false, Public:false}, "Overlapped", $asm0F.TypeRef("System.Threading.Overlapped"));

    $.Property({Static:false, Public:false}, "NativeOverlapped", $asm12.TypeRef("System.Net.SafeNativeOverlapped"));

    $.Property({Static:false, Public:false}, "PinnedObjects", $.Object);

    $.Property({Static:false, Public:false}, "PinnedObjectsArray", $jsilcore.TypeRef("System.Array", [$.Object]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Net.Sockets.OverlappedAsyncResult */ 

(function OverlappedAsyncResult$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Net.Sockets.BaseOverlappedAsyncResult"), 
      Name: "System.Net.Sockets.OverlappedAsyncResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Net.Sockets.Socket"), $.Object, 
          $asm0F.TypeRef("System.AsyncCallback")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "LogBuffer", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "PostCompletion", 
      new JSIL.MethodSignature($.Object, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "SetUnmanagedStructures", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.SocketAddress"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "SetUnmanagedStructures", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.Net.SocketAddress"), 
          $.Boolean, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Net.Sockets.OverlappedCache")])
        ])
    );

    $.Field({Static:false, Public:false}, "m_SocketAddress", $asm12.TypeRef("System.Net.SocketAddress"));

    $.Field({Static:false, Public:false}, "m_SingleBuffer", $asm12.TypeRef("System.Net.WSABuffer"));

    $.Field({Static:false, Public:false}, "m_WSABuffers", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Net.WSABuffer")]));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Collections.Specialized.BitVector32 */ 

(function BitVector32$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Collections.Specialized.BitVector32", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 1, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.Int32, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:true }, "ToString", 
      new JSIL.MethodSignature($.String, [$.Type])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "data", $.UInt32);

    $.Property({Static:false, Public:true }, "Item", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Specialized.StringCollection */ 

(function StringCollection$Members () {
  var $, $thisType;



















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Specialized.StringCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature($.Int32, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "AddRange", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "Contains", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($.String, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:true }, "Remove", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.Int32, $.String])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.Add", 
      new JSIL.MethodSignature($.Int32, [$.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "Add");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.Contains", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "get_IsReadOnly");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.get_Item", 
      new JSIL.MethodSignature($.Object, [$.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "get_Item");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.Remove", 
      JSIL.MethodSignature.Action($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "Remove");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.set_Item", 
      new JSIL.MethodSignature(null, [$.Int32, $.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "set_Item");

    $.Field({Static:false, Public:false}, "data", $asm0F.TypeRef("System.Collections.ArrayList"));

    $.Property({Static:false, Public:true }, "Item", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IList.IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "SyncRoot", $.Object);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IList.Item", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.IList"), 
      /* 1 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Specialized.StringDictionaryWithComparer */ 

(function StringDictionaryWithComparer$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Collections.Specialized.StringDictionary"), 
      Name: "System.Collections.Specialized.StringDictionaryWithComparer", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.IEqualityComparer"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ContainsKey", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Item", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Remove", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.Property({Static:false, Public:true , Virtual:true }, "Item", $.String);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Collections.Generic");
/* class System.Collections.Generic.System_DictionaryDebugView`2 */ 

(function System_DictionaryDebugView$b2$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.System_DictionaryDebugView`2", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["K", "V"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("K"), $.GenericParameter("V")])])
    );

    $.Field({Static:false, Public:false}, "dict", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("K"), $.GenericParameter("V")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.Queue`1 */ 

(function Queue$b1$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.Queue`1", 
      IsPublic: true, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "Dequeue", 
      new JSIL.MethodSignature($.GenericParameter("T"), null)
    );

    $.ExternalMethod({Static:false, Public:true }, "Enqueue", 
      new JSIL.MethodSignature(null, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetElement", 
      new JSIL.MethodSignature($.GenericParameter("T"), [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "SetCapacity", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lT$g.GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("T")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("T")]), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.Field({Static:false, Public:false}, "_array", $jsilcore.TypeRef("System.Array", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:false}, "_head", $.Int32);

    $.Field({Static:false, Public:false}, "_tail", $.Int32);

    $.Field({Static:false, Public:false}, "_size", $.Int32);

    $.Field({Static:false, Public:false}, "_version", $.Int32);

    $.Field({Static:false, Public:false}, "_syncRoot", $.Object);

    $.Field({Static:true , Public:false}, "_emptyArray", $jsilcore.TypeRef("System.Array", [$.GenericParameter("T")]));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("T")]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 3 */ $asm0F.TypeRef("System.Collections.Generic.IReadOnlyCollection`1", [$.GenericParameter("T")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

})();

/* struct System.Collections.Generic.Queue`1+Enumerator */ 

(function Enumerator$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Collections.Generic.Queue`1+Enumerator", 
      IsPublic: false, 
      IsReferenceType: false, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.Queue`1", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($.GenericParameter("T"), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.Field({Static:false, Public:false}, "_q", $asm12.TypeRef("System.Collections.Generic.Queue`1", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:false}, "_index", $.Int32);

    $.Field({Static:false, Public:false}, "_version", $.Int32);

    $.Field({Static:false, Public:false}, "_currentElement", $.GenericParameter("T"));

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $.GenericParameter("T"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("T")]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedList`2 */ 

(function SortedList$b2$Members () {
  var $, $thisType;










































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedList`2", 
      IsPublic: true, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("TKey")])])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Int32, $asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("TKey")])])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), $asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("TKey")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature(null, [$.GenericParameter("TKey"), $.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ContainsKey", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true }, "ContainsValue", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureCapacity", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Item", 
      new JSIL.MethodSignature($.GenericParameter("TValue"), [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetByIndex", 
      new JSIL.MethodSignature($.GenericParameter("TValue"), [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetKey", 
      new JSIL.MethodSignature($.GenericParameter("TKey"), [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetKeyListHelper", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedList`2+KeyList", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), null)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetValueListHelper", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedList`2+ValueList", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), null)
    );

    $.ExternalMethod({Static:false, Public:true }, "IndexOfKey", 
      new JSIL.MethodSignature($.Int32, [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true }, "IndexOfValue", 
      new JSIL.MethodSignature($.Int32, [$.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:false}, "Insert", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.GenericParameter("TKey"), 
          $.GenericParameter("TValue")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsCompatibleKey", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Remove", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true }, "RemoveAt", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Capacity", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.GenericParameter("TKey"), $.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.Add", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "Add");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.Contains", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "get_IsReadOnly");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IDictionary$lTKey$cmTValue$g.get_Keys", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), "get_Keys");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IDictionary$lTKey$cmTValue$g.get_Values", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), "get_Values");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.Contains", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.get_Item", 
      new JSIL.MethodSignature($.Object, [$.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "get_Item");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.get_Keys", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.ICollection"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "get_Keys");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IDictionaryEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.Remove", 
      JSIL.MethodSignature.Action($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "Remove");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.set_Item", 
      new JSIL.MethodSignature(null, [$.Object, $.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "set_Item");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "TryGetValue", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TKey"), $jsilcore.TypeRef("JSIL.Reference", [$.GenericParameter("TValue")])])
    );

    $.Field({Static:false, Public:false}, "keys", $jsilcore.TypeRef("System.Array", [$.GenericParameter("TKey")]));

    $.Field({Static:false, Public:false}, "values", $jsilcore.TypeRef("System.Array", [$.GenericParameter("TValue")]));

    $.Field({Static:false, Public:false}, "_size", $.Int32);

    $.Field({Static:false, Public:false}, "version", $.Int32);

    $.Field({Static:false, Public:false}, "comparer", $asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("TKey")]));

    $.Field({Static:false, Public:false}, "keyList", $asm12.TypeRef("System.Collections.Generic.SortedList`2+KeyList", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Field({Static:false, Public:false}, "valueList", $asm12.TypeRef("System.Collections.Generic.SortedList`2+ValueList", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Field({Static:false, Public:false}, "_syncRoot", $.Object);

    $.Field({Static:true , Public:false}, "emptyKeys", $jsilcore.TypeRef("System.Array", [$.GenericParameter("TKey")]));

    $.Field({Static:true , Public:false}, "emptyValues", $jsilcore.TypeRef("System.Array", [$.GenericParameter("TValue")]));

    $.Property({Static:false, Public:true }, "Capacity", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IDictionary$lTKey$cmTValue$g.Keys", $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.Keys", $asm0F.TypeRef("System.Collections.ICollection"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IDictionary$lTKey$cmTValue$g.Values", $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "Item", $.GenericParameter("TValue"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.Item", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), 
      /* 3 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 4 */ $asm0F.TypeRef("System.Collections.IDictionary"), 
      /* 5 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 7 */ $asm0F.TypeRef("System.Collections.Generic.IReadOnlyCollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

})();

/* struct System.Collections.Generic.SortedList`2+Enumerator */ 

(function Enumerator$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Collections.Generic.SortedList`2+Enumerator", 
      IsPublic: false, 
      IsReferenceType: false, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 2, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.get_Entry", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.DictionaryEntry"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionaryEnumerator"), "get_Entry");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.get_Key", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionaryEnumerator"), "get_Key");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.get_Value", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionaryEnumerator"), "get_Value");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.Field({Static:false, Public:false}, "_sortedList", $asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Field({Static:false, Public:false}, "key", $.GenericParameter("TKey"));

    $.Field({Static:false, Public:false}, "value", $.GenericParameter("TValue"));

    $.Field({Static:false, Public:false}, "index", $.Int32);

    $.Field({Static:false, Public:false}, "version", $.Int32);

    $.Field({Static:false, Public:false}, "getEnumeratorRetType", $.Int32);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.Key", $.Object);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.Entry", $asm0F.TypeRef("System.Collections.DictionaryEntry"));

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.Value", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator"), 
      /* 3 */ $asm0F.TypeRef("System.Collections.IDictionaryEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedList`2+SortedListKeyEnumerator */ 

(function SortedListKeyEnumerator$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedList`2+SortedListKeyEnumerator", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($.GenericParameter("TKey"), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.Field({Static:false, Public:false}, "_sortedList", $asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Field({Static:false, Public:false}, "index", $.Int32);

    $.Field({Static:false, Public:false}, "version", $.Int32);

    $.Field({Static:false, Public:false}, "currentKey", $.GenericParameter("TKey"));

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $.GenericParameter("TKey"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("TKey")]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedList`2+SortedListValueEnumerator */ 

(function SortedListValueEnumerator$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedList`2+SortedListValueEnumerator", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($.GenericParameter("TValue"), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.Field({Static:false, Public:false}, "_sortedList", $asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Field({Static:false, Public:false}, "index", $.Int32);

    $.Field({Static:false, Public:false}, "version", $.Int32);

    $.Field({Static:false, Public:false}, "currentValue", $.GenericParameter("TValue"));

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $.GenericParameter("TValue"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("TValue")]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedList`2+KeyList */ 

(function KeyList$Members () {
  var $, $thisType;

















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedList`2+KeyList", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature(null, [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Contains", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.GenericParameter("TKey")]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Item", 
      new JSIL.MethodSignature($.GenericParameter("TKey"), [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("TKey")]), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IndexOf", 
      new JSIL.MethodSignature($.Int32, [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Insert", 
      new JSIL.MethodSignature(null, [$.Int32, $.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "RemoveAt", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.Int32, $.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.Field({Static:false, Public:false}, "_dict", $asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "Item", $.GenericParameter("TKey"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IList`1", [$.GenericParameter("TKey")]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("TKey")]), 
      /* 3 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 4 */ $asm0F.TypeRef("System.Collections.ICollection")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedList`2+ValueList */ 

(function ValueList$Members () {
  var $, $thisType;

















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedList`2+ValueList", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature(null, [$.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Contains", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.GenericParameter("TValue")]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Item", 
      new JSIL.MethodSignature($.GenericParameter("TValue"), [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("TValue")]), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IndexOf", 
      new JSIL.MethodSignature($.Int32, [$.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Insert", 
      new JSIL.MethodSignature(null, [$.Int32, $.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "RemoveAt", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.Int32, $.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.Field({Static:false, Public:false}, "_dict", $asm12.TypeRef("System.Collections.Generic.SortedList`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "Item", $.GenericParameter("TValue"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IList`1", [$.GenericParameter("TValue")]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("TValue")]), 
      /* 3 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 4 */ $asm0F.TypeRef("System.Collections.ICollection")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.Stack`1 */ 

(function Stack$b1$Members () {
  var $, $thisType;












  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.Stack`1", 
      IsPublic: true, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "Peek", 
      new JSIL.MethodSignature($.GenericParameter("T"), null)
    );

    $.ExternalMethod({Static:false, Public:true }, "Pop", 
      new JSIL.MethodSignature($.GenericParameter("T"), null)
    );

    $.ExternalMethod({Static:false, Public:true }, "Push", 
      new JSIL.MethodSignature(null, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lT$g.GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("T")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("T")]), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.Field({Static:false, Public:false}, "_array", $jsilcore.TypeRef("System.Array", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:false}, "_size", $.Int32);

    $.Field({Static:false, Public:false}, "_version", $.Int32);

    $.Field({Static:false, Public:false}, "_syncRoot", $.Object);

    $.Field({Static:true , Public:false}, "_emptyArray", $jsilcore.TypeRef("System.Array", [$.GenericParameter("T")]));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("T")]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 3 */ $asm0F.TypeRef("System.Collections.Generic.IReadOnlyCollection`1", [$.GenericParameter("T")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

})();

/* struct System.Collections.Generic.Stack`1+Enumerator */ 

(function Enumerator$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Collections.Generic.Stack`1+Enumerator", 
      IsPublic: false, 
      IsReferenceType: false, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 1, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.Stack`1", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($.GenericParameter("T"), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.Field({Static:false, Public:false}, "_stack", $asm12.TypeRef("System.Collections.Generic.Stack`1", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:false}, "_index", $.Int32);

    $.Field({Static:false, Public:false}, "_version", $.Int32);

    $.Field({Static:false, Public:false}, "currentElement", $.GenericParameter("T"));

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $.GenericParameter("T"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("T")]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedDictionary`2 */ 

(function SortedDictionary$b2$Members () {
  var $, $thisType;
































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2", 
      IsPublic: true, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), $asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("TKey")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature(null, [$.GenericParameter("TKey"), $.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ContainsKey", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true }, "ContainsValue", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Item", 
      new JSIL.MethodSignature($.GenericParameter("TValue"), [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Keys", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+KeyCollection", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), null)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Values", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+ValueCollection", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), null)
    );

    $.ExternalMethod({Static:false, Public:true }, "GetEnumerator", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+Enumerator", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), null)
    );

    $.ExternalMethod({Static:true , Public:false}, "IsCompatibleKey", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Remove", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TKey")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Item", 
      new JSIL.MethodSignature(null, [$.GenericParameter("TKey"), $.GenericParameter("TValue")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.Add", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "Add");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.Contains", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "get_IsReadOnly");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IDictionary$lTKey$cmTValue$g.get_Keys", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), "get_Keys");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IDictionary$lTKey$cmTValue$g.get_Values", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), "get_Values");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.Contains", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.get_Item", 
      new JSIL.MethodSignature($.Object, [$.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "get_Item");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.get_Keys", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.ICollection"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "get_Keys");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IDictionaryEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.Remove", 
      JSIL.MethodSignature.Action($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "Remove");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.set_Item", 
      new JSIL.MethodSignature(null, [$.Object, $.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionary"), "set_Item");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "TryGetValue", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TKey"), $jsilcore.TypeRef("JSIL.Reference", [$.GenericParameter("TValue")])])
    );

    $.Field({Static:false, Public:false}, "keys", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+KeyCollection", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Field({Static:false, Public:false}, "values", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+ValueCollection", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Field({Static:false, Public:false}, "_set", $asm12.TypeRef("System.Collections.Generic.TreeSet`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lSystem.Collections.Generic.KeyValuePair$lTKey$cmTValue$g$g.IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Item", $.GenericParameter("TValue"));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:true }, "Keys", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+KeyCollection", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IDictionary$lTKey$cmTValue$g.Keys", $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]));

    $.Property({Static:false, Public:true }, "Values", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+ValueCollection", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IDictionary$lTKey$cmTValue$g.Values", $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.Keys", $asm0F.TypeRef("System.Collections.ICollection"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionary.Item", $.Object);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), 
      /* 3 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 4 */ $asm0F.TypeRef("System.Collections.IDictionary"), 
      /* 5 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 7 */ $asm0F.TypeRef("System.Collections.Generic.IReadOnlyCollection`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Collections.Generic.SortedDictionary`2+Enumerator */ 

(function Enumerator$Members () {
  var $, $thisType;












  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Collections.Generic.SortedDictionary`2+Enumerator", 
      IsPublic: false, 
      IsReferenceType: false, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 2, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), null)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_NotStartedOrEnded", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "Reset", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.get_Entry", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.DictionaryEntry"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionaryEnumerator"), "get_Entry");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.get_Key", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionaryEnumerator"), "get_Key");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.get_Value", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IDictionaryEnumerator"), "get_Value");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.Field({Static:false, Public:false}, "treeEnum", $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Enumerator", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]));

    $.Field({Static:false, Public:false}, "getEnumeratorRetType", $.Int32);

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:false}, "NotStartedOrEnded", $.Boolean);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.Key", $.Object);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.Value", $.Object);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IDictionaryEnumerator.Entry", $asm0F.TypeRef("System.Collections.DictionaryEntry"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator"), 
      /* 3 */ $asm0F.TypeRef("System.Collections.IDictionaryEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedDictionary`2+KeyCollection */ 

(function KeyCollection$Members () {
  var $, $thisType;












  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+KeyCollection", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.GenericParameter("TKey")]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTKey$g.Add", 
      new JSIL.MethodSignature(null, [$.GenericParameter("TKey")])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]), "Add");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTKey$g.Clear", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]), "Clear");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTKey$g.Contains", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TKey")])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTKey$g.get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]), "get_IsReadOnly");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lTKey$g.GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("TKey")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("TKey")]), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.Field({Static:false, Public:false}, "dictionary", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTKey$g.IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TKey")]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("TKey")]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 3 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 4 */ $asm0F.TypeRef("System.Collections.Generic.IReadOnlyCollection`1", [$.GenericParameter("TKey")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Collections.Generic.SortedDictionary`2+KeyCollection+Enumerator */ 

(function Enumerator$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Collections.Generic.SortedDictionary`2+KeyCollection+Enumerator", 
      IsPublic: false, 
      IsReferenceType: false, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($.GenericParameter("TKey"), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.Field({Static:false, Public:false}, "dictEnum", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+Enumerator", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $.GenericParameter("TKey"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("TKey")]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedDictionary`2+KeyCollection+<>c__DisplayClass5_0 */ 

(function $l$gc__DisplayClass5_0$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+KeyCollection+<>c__DisplayClass5_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lCopyTo$gb__0", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])])
    );

    $.Field({Static:false, Public:true }, "array", $jsilcore.TypeRef("System.Array", [$.GenericParameter("TKey")]));

    $.Field({Static:false, Public:true }, "index", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedDictionary`2+KeyCollection+<>c__DisplayClass6_0 */ 

(function $l$gc__DisplayClass6_0$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+KeyCollection+<>c__DisplayClass6_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lSystem.Collections.ICollection.CopyTo$gb__0", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])])
    );

    $.Field({Static:false, Public:true }, "objects", $jsilcore.TypeRef("System.Array", [$.Object]));

    $.Field({Static:false, Public:true }, "CS$$l$g8__locals1", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+KeyCollection+<>c__DisplayClass6_1", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedDictionary`2+KeyCollection+<>c__DisplayClass6_1 */ 

(function $l$gc__DisplayClass6_1$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+KeyCollection+<>c__DisplayClass6_1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "index", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedDictionary`2+ValueCollection */ 

(function ValueCollection$Members () {
  var $, $thisType;












  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+ValueCollection", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.GenericParameter("TValue")]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTValue$g.Add", 
      new JSIL.MethodSignature(null, [$.GenericParameter("TValue")])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]), "Add");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTValue$g.Clear", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]), "Clear");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTValue$g.Contains", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("TValue")])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTValue$g.get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]), "get_IsReadOnly");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lTValue$g.GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("TValue")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("TValue")]), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.Field({Static:false, Public:false}, "dictionary", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lTValue$g.IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("TValue")]), 
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("TValue")]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 3 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 4 */ $asm0F.TypeRef("System.Collections.Generic.IReadOnlyCollection`1", [$.GenericParameter("TValue")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Collections.Generic.SortedDictionary`2+ValueCollection+Enumerator */ 

(function Enumerator$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Collections.Generic.SortedDictionary`2+ValueCollection+Enumerator", 
      IsPublic: false, 
      IsReferenceType: false, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedDictionary`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($.GenericParameter("TValue"), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.Field({Static:false, Public:false}, "dictEnum", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+Enumerator", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $.GenericParameter("TValue"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("TValue")]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedDictionary`2+ValueCollection+<>c__DisplayClass5_0 */ 

(function $l$gc__DisplayClass5_0$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+ValueCollection+<>c__DisplayClass5_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lCopyTo$gb__0", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])])
    );

    $.Field({Static:false, Public:true }, "array", $jsilcore.TypeRef("System.Array", [$.GenericParameter("TValue")]));

    $.Field({Static:false, Public:true }, "index", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedDictionary`2+ValueCollection+<>c__DisplayClass6_0 */ 

(function $l$gc__DisplayClass6_0$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+ValueCollection+<>c__DisplayClass6_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lSystem.Collections.ICollection.CopyTo$gb__0", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])])
    );

    $.Field({Static:false, Public:true }, "objects", $jsilcore.TypeRef("System.Array", [$.Object]));

    $.Field({Static:false, Public:true }, "CS$$l$g8__locals1", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+ValueCollection+<>c__DisplayClass6_1", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedDictionary`2+ValueCollection+<>c__DisplayClass6_1 */ 

(function $l$gc__DisplayClass6_1$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+ValueCollection+<>c__DisplayClass6_1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "index", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedDictionary`2+KeyValuePairComparer */ 

(function KeyValuePairComparer$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Collections.Generic.Comparer`1", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [new JSIL.GenericParameter("TKey", "System.Collections.Generic.SortedDictionary`2+KeyValuePairComparer"), new JSIL.GenericParameter("TValue", "System.Collections.Generic.SortedDictionary`2+KeyValuePairComparer")])]), 
      Name: "System.Collections.Generic.SortedDictionary`2+KeyValuePairComparer", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("TKey")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Compare", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]), $asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])
    );

    $.Field({Static:false, Public:false}, "keyComparer", $asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("TKey")]));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedDictionary`2+<>c__DisplayClass34_0 */ 

(function $l$gc__DisplayClass34_0$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+<>c__DisplayClass34_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lContainsValue$gb__0", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])])
    );

    $.Field({Static:false, Public:true }, "found", $.Boolean);

    $.Field({Static:false, Public:true }, "value", $.GenericParameter("TValue"));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedDictionary`2+<>c__DisplayClass34_1 */ 

(function $l$gc__DisplayClass34_1$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedDictionary`2+<>c__DisplayClass34_1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["TKey", "TValue"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lContainsValue$gb__1", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$asm0F.TypeRef("System.Collections.Generic.KeyValuePair`2", [$.GenericParameter("TKey"), $.GenericParameter("TValue")])])])
    );

    $.Field({Static:false, Public:true }, "valueComparer", $asm0F.TypeRef("System.Collections.Generic.EqualityComparer`1", [$.GenericParameter("TValue")]));

    $.Field({Static:false, Public:true }, "CS$$l$g8__locals1", $asm12.TypeRef("System.Collections.Generic.SortedDictionary`2+<>c__DisplayClass34_0", [$.GenericParameter("TKey"), $.GenericParameter("TValue")]));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedSet`1 */ 

(function SortedSet$b1$Members () {
  var $, $thisType;














































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedSet`1", 
      IsPublic: true, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Add", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "AddIfNotPresent", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Contains", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "CopyTo", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.GenericParameter("T")]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "CopyTo", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.GenericParameter("T")]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "DoRemove", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "FindNode", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Comparer", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")]), null)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "GetEnumerator", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedSet`1+Enumerator", [$.GenericParameter("T")]), null)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetSibling", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:false}, "InOrderTreeWalk", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.TreeWalkPredicate`1", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "InOrderTreeWalk", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.TreeWalkPredicate`1", [$.GenericParameter("T")]), $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "InsertionBalance", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])]), 
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Is2Node", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "Is4Node", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsBlack", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsNullOrBlack", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsRed", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "IsWithinRange", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:true , Public:false}, "log2", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "Merge2Nodes", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), 
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnDeserialization", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Remove", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReplaceChildOfNodeOrRoot", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), 
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReplaceNode", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), 
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "RotateLeft", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "RotateLeftRight", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "RotateRight", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "RotateRightLeft", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "RotationNeeded", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Collections.Generic.TreeRotation"), [
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]), 
          $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "Split4Node", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lT$g.Add", 
      new JSIL.MethodSignature(null, [$.GenericParameter("T")])
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("T")]), "Add");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lT$g.get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("T")]), "get_IsReadOnly");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.IEnumerable$lT$g.GetEnumerator", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("T")]), null)
    )
      .Overrides($asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("T")]), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerable.GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerable"), "GetEnumerator");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.IDeserializationCallback.OnDeserialization", 
      JSIL.MethodSignature.Action($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.IDeserializationCallback"), "OnDeserialization");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.ISerializable.GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), "GetObjectData");

    $.ExternalMethod({Static:false, Public:false}, "UpdateVersion", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "VersionCheck", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "root", $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:false}, "comparer", $asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:false}, "count", $.Int32);

    $.Field({Static:false, Public:false}, "version", $.Int32);

    $.Field({Static:false, Public:false}, "_syncRoot", $.Object);

    $.Field({Static:false, Public:false}, "siInfo", $asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:true }, "Comparer", $asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")]));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.Generic.ICollection$lT$g.IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.ImplementInterfaces(
      /* 1 */ $asm0F.TypeRef("System.Collections.Generic.ICollection`1", [$.GenericParameter("T")]), 
      /* 2 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerable`1", [$.GenericParameter("T")]), 
      /* 3 */ $asm0F.TypeRef("System.Collections.IEnumerable"), 
      /* 4 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 5 */ $asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), 
      /* 6 */ $asm0F.TypeRef("System.Runtime.Serialization.IDeserializationCallback"), 
      /* 7 */ $asm0F.TypeRef("System.Collections.Generic.IReadOnlyCollection`1", [$.GenericParameter("T")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedSet`1+Node */ 

(function Node$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedSet`1+Node", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.GenericParameter("T")])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.GenericParameter("T"), $.Boolean])
    );

    $.Field({Static:false, Public:true }, "IsRed", $.Boolean);

    $.Field({Static:false, Public:true }, "Item", $.GenericParameter("T"));

    $.Field({Static:false, Public:true }, "Left", $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:true }, "Right", $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Collections.Generic.SortedSet`1+Enumerator */ 

(function Enumerator$Members () {
  var $, $thisType;














  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Collections.Generic.SortedSet`1+Enumerator", 
      IsPublic: false, 
      IsReferenceType: false, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 2, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Current", 
      new JSIL.MethodSignature($.GenericParameter("T"), null)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_NotStartedOrEnded", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    );

    $.ExternalMethod({Static:false, Public:false}, "Intialize", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "MoveNext", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "OnDeserialization", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "Reset", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.get_Current", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "get_Current");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Reset", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.Collections.IEnumerator"), "Reset");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.IDeserializationCallback.OnDeserialization", 
      JSIL.MethodSignature.Action($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.IDeserializationCallback"), "OnDeserialization");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.ISerializable.GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), "GetObjectData");

    $.Field({Static:false, Public:false}, "tree", $asm12.TypeRef("System.Collections.Generic.SortedSet`1", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:false}, "version", $.Int32);

    $.Field({Static:false, Public:false}, "stack", $asm12.TypeRef("System.Collections.Generic.Stack`1", [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])]));

    $.Field({Static:false, Public:false}, "current", $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]));

    $.Field({Static:true , Public:false}, "dummyNode", $asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")]));

    $.Field({Static:false, Public:false}, "reverse", $.Boolean);

    $.Field({Static:false, Public:false}, "siInfo", $asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"));

    $.Property({Static:false, Public:true , Virtual:true }, "Current", $.GenericParameter("T"));

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IEnumerator.Current", $.Object);

    $.Property({Static:false, Public:false}, "NotStartedOrEnded", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IEnumerator`1", [$.GenericParameter("T")]), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerator"), 
      /* 3 */ $asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), 
      /* 4 */ $asm0F.TypeRef("System.Runtime.Serialization.IDeserializationCallback")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Collections.Generic.SortedSet`1+<>c__DisplayClass52_0 */ 

(function $l$gc__DisplayClass52_0$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedSet`1+<>c__DisplayClass52_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lCopyTo$gb__0", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.Field({Static:false, Public:true }, "index", $.Int32);

    $.Field({Static:false, Public:true }, "count", $.Int32);

    $.Field({Static:false, Public:true }, "array", $jsilcore.TypeRef("System.Array", [$.GenericParameter("T")]));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedSet`1+<>c__DisplayClass53_0 */ 

(function $l$gc__DisplayClass53_0$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedSet`1+<>c__DisplayClass53_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lSystem.Collections.ICollection.CopyTo$gb__0", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [$.GenericParameter("T")])])
    );

    $.Field({Static:false, Public:true }, "objects", $jsilcore.TypeRef("System.Array", [$.Object]));

    $.Field({Static:false, Public:true }, "CS$$l$g8__locals1", $asm12.TypeRef("System.Collections.Generic.SortedSet`1+<>c__DisplayClass53_1", [$.GenericParameter("T")]));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.SortedSet`1+<>c__DisplayClass53_1 */ 

(function $l$gc__DisplayClass53_1$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Collections.Generic.SortedSet`1+<>c__DisplayClass53_1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "index", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Collections.Generic.TreeSet`1 */ 

(function TreeSet$b1$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Collections.Generic.SortedSet`1", [new JSIL.GenericParameter("T", "System.Collections.Generic.TreeSet`1")]), 
      Name: "System.Collections.Generic.TreeSet`1", 
      IsPublic: false, 
      IsReferenceType: true, 
      GenericParameters: ["T"], 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$.GenericParameter("T")])])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "AddIfNotPresent", 
      new JSIL.MethodSignature($.Boolean, [$.GenericParameter("T")])
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate System.Collections.Generic.TreeWalkPredicate`1 */ 

JSIL.MakeDelegate("System.Collections.Generic.TreeWalkPredicate`1", false, ["T"], 
  new JSIL.MethodSignature($asm0F.TypeRef("System.Boolean"), [$asm12.TypeRef("System.Collections.Generic.SortedSet`1+Node", [new JSIL.GenericParameter("T", "System.Collections.Generic.TreeWalkPredicate`1")])]));

/* enum System.Collections.Generic.TreeRotation */ 

JSIL.MakeEnum(
  {
    FullName: "System.Collections.Generic.TreeRotation", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    LeftRotation: 1, 
    RightRotation: 2, 
    RightLeftRotation: 3, 
    LeftRightRotation: 4, 
  }
);

JSIL.DeclareNamespace("System.IO");
/* class System.IO.InvalidDataException */ 

(function InvalidDataException$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.SystemException"), 
      Name: "System.IO.InvalidDataException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.IO.Compression");
/* enum System.IO.Compression.BlockType */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.BlockType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Uncompressed: 0, 
    Static: 1, 
    Dynamic: 2, 
  }
);

/* enum System.IO.Compression.CompressionMode */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.CompressionMode", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Decompress: 0, 
    Compress: 1, 
  }
);

/* enum System.IO.Compression.CompressionLevel */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.CompressionLevel", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Optimal: 0, 
    Fastest: 1, 
    NoCompression: 2, 
  }
);

/* class System.IO.Compression.CopyEncoder */ 

(function CopyEncoder$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.CopyEncoder", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "GetBlock", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.IO.Compression.DeflateInput"), $asm12.TypeRef("System.IO.Compression.OutputBuffer"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteLenNLen", 
      new JSIL.MethodSignature(null, [$.UInt16, $asm12.TypeRef("System.IO.Compression.OutputBuffer")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.DeflateInput */ 

(function DeflateInput$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.DeflateInput", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ConsumeBytes", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "DumpState", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.DeflateInput+InputState"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Buffer", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_StartIndex", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "RestoreState", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.DeflateInput+InputState"))
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Buffer", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Count", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_StartIndex", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.Field({Static:false, Public:false}, "buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "count", $.Int32);

    $.Field({Static:false, Public:false}, "startIndex", $.Int32);

    $.Property({Static:false, Public:false}, "Buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Property({Static:false, Public:false}, "Count", $.Int32);

    $.Property({Static:false, Public:false}, "StartIndex", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.IO.Compression.DeflateInput+InputState */ 

(function InputState$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.IO.Compression.DeflateInput+InputState", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "count", $.Int32);

    $.Field({Static:false, Public:false}, "startIndex", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface System.IO.Compression.IDeflater */ 

JSIL.MakeInterface(
  "System.IO.Compression.IDeflater", false, [], function ($) {
    $.Method({}, "NeedsInput", JSIL.MethodSignature.Return($.Boolean));
    $.Method({}, "SetInput", new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ]));
    $.Method({}, "GetDeflateOutput", new JSIL.MethodSignature($.Int32, [$jsilcore.TypeRef("System.Array", [$.Byte])]));
    $.Method({}, "Finish", new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("System.Array", [$.Byte]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])]));
  }, [$asm0F.TypeRef("System.IDisposable")]);

/* interface System.IO.Compression.IInflater */ 

JSIL.MakeInterface(
  "System.IO.Compression.IInflater", false, [], function ($) {
    $.Method({}, "Inflate", new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ]));
    $.Method({}, "Finished", JSIL.MethodSignature.Return($.Boolean));
    $.Method({}, "SetInput", new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ]));
  }, [$asm0F.TypeRef("System.IDisposable")]);

/* class System.IO.Compression.DeflaterManaged */ 

(function DeflaterManaged$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.DeflaterManaged", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "FlushInputWindows", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.IDisposable"), "Dispose");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IO.Compression.IDeflater.Finish", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("System.Array", [$.Byte]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])])
    )
      .Overrides($asm12.TypeRef("System.IO.Compression.IDeflater"), "Finish");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IO.Compression.IDeflater.GetDeflateOutput", 
      new JSIL.MethodSignature($.Int32, [$jsilcore.TypeRef("System.Array", [$.Byte])])
    )
      .Overrides($asm12.TypeRef("System.IO.Compression.IDeflater"), "GetDeflateOutput");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IO.Compression.IDeflater.NeedsInput", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm12.TypeRef("System.IO.Compression.IDeflater"), "NeedsInput");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IO.Compression.IDeflater.SetInput", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    )
      .Overrides($asm12.TypeRef("System.IO.Compression.IDeflater"), "SetInput");

    $.ExternalMethod({Static:false, Public:false}, "UseCompressed", 
      new JSIL.MethodSignature($.Boolean, [$.Double])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteFinal", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "deflateEncoder", $asm12.TypeRef("System.IO.Compression.FastEncoder"));

    $.Field({Static:false, Public:false}, "copyEncoder", $asm12.TypeRef("System.IO.Compression.CopyEncoder"));

    $.Field({Static:false, Public:false}, "input", $asm12.TypeRef("System.IO.Compression.DeflateInput"));

    $.Field({Static:false, Public:false}, "output", $asm12.TypeRef("System.IO.Compression.OutputBuffer"));

    $.Field({Static:false, Public:false}, "processingState", $asm12.TypeRef("System.IO.Compression.DeflaterManaged+DeflaterState"));

    $.Field({Static:false, Public:false}, "inputFromHistory", $asm12.TypeRef("System.IO.Compression.DeflateInput"));

    $.ImplementInterfaces(
      /* 0 */ $asm12.TypeRef("System.IO.Compression.IDeflater"), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.IO.Compression.DeflaterManaged+DeflaterState */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.DeflaterManaged+DeflaterState", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    NotStarted: 0, 
    SlowDownForIncompressible1: 1, 
    SlowDownForIncompressible2: 2, 
    StartingSmallData: 3, 
    CompressThenCheck: 4, 
    CheckingForIncompressible: 5, 
    HandlingSmallData: 6, 
  }
);

/* class System.IO.Compression.DeflaterZLib */ 

(function DeflaterZLib$Members () {
  var $, $thisType;













  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.DeflaterZLib", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.CompressionLevel"))
    );

    $.ExternalMethod({Static:false, Public:false}, "DeallocateInputBufferHandle", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Deflate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$asm12.TypeRef("System.IO.Compression.ZLibNative+FlushCode")])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false}, "DeflateInit", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionLevel"), $.Int32, 
          $.Int32, $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionStrategy")
        ])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false}, "ReadDeflateOutput", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $asm12.TypeRef("System.IO.Compression.ZLibNative+FlushCode"), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.IDisposable"), "Dispose");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IO.Compression.IDeflater.Finish", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("System.Array", [$.Byte]), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])])
    )
      .Overrides($asm12.TypeRef("System.IO.Compression.IDeflater"), "Finish");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IO.Compression.IDeflater.GetDeflateOutput", 
      new JSIL.MethodSignature($.Int32, [$jsilcore.TypeRef("System.Array", [$.Byte])])
    )
      .Overrides($asm12.TypeRef("System.IO.Compression.IDeflater"), "GetDeflateOutput")
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IO.Compression.IDeflater.NeedsInput", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm12.TypeRef("System.IO.Compression.IDeflater"), "NeedsInput")
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IO.Compression.IDeflater.SetInput", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    )
      .Overrides($asm12.TypeRef("System.IO.Compression.IDeflater"), "SetInput")
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.Field({Static:false, Public:false}, "_zlibStream", $asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle"));

    $.Field({Static:false, Public:false}, "_inputBufferHandle", $asm0F.TypeRef("System.Runtime.InteropServices.GCHandle"));

    $.Field({Static:false, Public:false}, "_isDisposed", $.Boolean);

    $.Field({Static:false, Public:false}, "_isValid", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "syncLock", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm12.TypeRef("System.IO.Compression.IDeflater"), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.InflaterZlib */ 

(function InflaterZlib$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.InflaterZlib", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "DeallocateInputBufferHandle", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Finished", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Inflate", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Inflate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$asm12.TypeRef("System.IO.Compression.ZLibNative+FlushCode")])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false}, "InflateInit", 
      JSIL.MethodSignature.Action($.Int32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false}, "ReadInflateOutput", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm12.TypeRef("System.IO.Compression.ZLibNative+FlushCode"), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "SetInput", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.IDisposable"), "Dispose");

    $.Field({Static:false, Public:false}, "_finished", $.Boolean);

    $.Field({Static:false, Public:false}, "_isDisposed", $.Boolean);

    $.Field({Static:false, Public:false}, "_zlibStream", $asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle"));

    $.Field({Static:false, Public:false}, "_inputBufferHandle", $asm0F.TypeRef("System.Runtime.InteropServices.GCHandle"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "_syncLock", $.Object);

    $.Field({Static:false, Public:false}, "_isValid", $.Int32);

    $.ImplementInterfaces(
      /* 0 */ $asm12.TypeRef("System.IO.Compression.IInflater"), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.ZLibNative */ 

(function ZLibNative$Members () {
  var $, $thisType;






  JSIL.MakeStaticClass("System.IO.Compression.ZLibNative", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "CreateZLibStreamForDeflate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle")])])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:true }, "CreateZLibStreamForDeflate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [
          $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle")]), $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionLevel"), 
          $.Int32, $.Int32, 
          $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionStrategy")
        ])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:true }, "CreateZLibStreamForInflate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle")])])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:true }, "CreateZLibStreamForInflate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle")]), $.Int32])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:true }, "ZLibCompileFlags", 
      JSIL.MethodSignature.Return($.Int32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Constant({Static:true , Public:true }, "ZLibNativeDllName", $.String, "clrcompression.dll");

    $.Constant({Static:true , Public:false}, "Kernel32DllName", $.String, "kernel32.dll");

    $.Constant({Static:true , Public:true }, "ZLibVersion", $.String, "1.2.3");

    $.Field({Static:true , Public:false, ReadOnly:true }, "ZNullPtr", $.IntPtr);

    $.Constant({Static:true , Public:true }, "Deflate_DefaultWindowBits", $.Int32, -15);

    $.Constant({Static:true , Public:true }, "Deflate_DefaultMemLevel", $.Int32, 8);


    function ZLibNative__cctor () {
      $thisType.ZNullPtr = new $asm0F.System.IntPtr();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      ZLibNative__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.IO.Compression.ZLibNative+FlushCode */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.ZLibNative+FlushCode", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    NoFlush: 0, 
    PartialFlush: 1, 
    SyncFlush: 2, 
    FullFlush: 3, 
    Finish: 4, 
    Block: 5, 
  }
);

/* enum System.IO.Compression.ZLibNative+ErrorCode */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.ZLibNative+ErrorCode", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    VersionError: -6, 
    BufError: -5, 
    MemError: -4, 
    DataError: -3, 
    StreamError: -2, 
    ErrorNo: -1, 
    Ok: 0, 
    StreamEnd: 1, 
    NeedDictionary: 2, 
  }
);

/* enum System.IO.Compression.ZLibNative+CompressionLevel */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.ZLibNative+CompressionLevel", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    DefaultCompression: -1, 
    NoCompression: 0, 
    BestSpeed: 1, 
    BestCompression: 9, 
  }
);

/* enum System.IO.Compression.ZLibNative+CompressionStrategy */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.ZLibNative+CompressionStrategy", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    DefaultStrategy: 0, 
    Filtered: 1, 
    HuffmanOnly: 2, 
    Rle: 3, 
    Fixed: 4, 
  }
);

/* enum System.IO.Compression.ZLibNative+CompressionMethod */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.ZLibNative+CompressionMethod", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Deflated: 8, 
  }
);

/* struct System.IO.Compression.ZLibNative+ZStream */ 

(function ZStream$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.IO.Compression.ZLibNative+ZStream", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "nextIn", $.IntPtr);

    $.Field({Static:false, Public:false}, "availIn", $.UInt32);

    $.Field({Static:false, Public:false}, "totalIn", $.UInt32);

    $.Field({Static:false, Public:false}, "nextOut", $.IntPtr);

    $.Field({Static:false, Public:false}, "availOut", $.UInt32);

    $.Field({Static:false, Public:false}, "totalOut", $.UInt32);

    $.Field({Static:false, Public:false}, "msg", $.IntPtr);

    $.Field({Static:false, Public:false}, "state", $.IntPtr);

    $.Field({Static:false, Public:false}, "zalloc", $.IntPtr);

    $.Field({Static:false, Public:false}, "zfree", $.IntPtr);

    $.Field({Static:false, Public:false}, "opaque", $.IntPtr);

    $.Field({Static:false, Public:false}, "dataType", $.Int32);

    $.Field({Static:false, Public:false}, "adler", $.UInt32);

    $.Field({Static:false, Public:false}, "reserved", $.UInt32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate System.IO.Compression.ZLibNative+DeflateInit2_Delegate */ 

JSIL.MakeDelegate("System.IO.Compression.ZLibNative+DeflateInit2_Delegate", false, [], 
  new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [
      $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZStream")]), $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionLevel"), 
      $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionMethod"), $asm0F.TypeRef("System.Int32"), 
      $asm0F.TypeRef("System.Int32"), $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionStrategy"), 
      $asm0F.TypeRef("System.String"), $asm0F.TypeRef("System.Int32")
    ]), {
    Parameters: [
      {
        NativeType: "LPStr"
      }, null

    ]
  }
);

/* delegate System.IO.Compression.ZLibNative+DeflateDelegate */ 

JSIL.MakeDelegate("System.IO.Compression.ZLibNative+DeflateDelegate", false, [], 
  new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZStream")]), $asm12.TypeRef("System.IO.Compression.ZLibNative+FlushCode")]));

/* delegate System.IO.Compression.ZLibNative+DeflateEndDelegate */ 

JSIL.MakeDelegate("System.IO.Compression.ZLibNative+DeflateEndDelegate", false, [], 
  new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZStream")])]));

/* delegate System.IO.Compression.ZLibNative+InflateInit2_Delegate */ 

JSIL.MakeDelegate("System.IO.Compression.ZLibNative+InflateInit2_Delegate", false, [], 
  new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [
      $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZStream")]), $asm0F.TypeRef("System.Int32"), 
      $asm0F.TypeRef("System.String"), $asm0F.TypeRef("System.Int32")
    ]), {
    Parameters: [
      {
        NativeType: "LPStr"
      }, null

    ]
  }
);

/* delegate System.IO.Compression.ZLibNative+InflateDelegate */ 

JSIL.MakeDelegate("System.IO.Compression.ZLibNative+InflateDelegate", false, [], 
  new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZStream")]), $asm12.TypeRef("System.IO.Compression.ZLibNative+FlushCode")]));

/* delegate System.IO.Compression.ZLibNative+InflateEndDelegate */ 

JSIL.MakeDelegate("System.IO.Compression.ZLibNative+InflateEndDelegate", false, [], 
  new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.IO.Compression.ZLibNative+ZStream")])]));

/* delegate System.IO.Compression.ZLibNative+ZlibCompileFlagsDelegate */ 

JSIL.MakeDelegate("System.IO.Compression.ZLibNative+ZlibCompileFlagsDelegate", false, [], 
  JSIL.MethodSignature.Return($asm0F.TypeRef("System.Int32")));

/* class System.IO.Compression.ZLibNative+NativeMethods */ 

(function NativeMethods$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.ZLibNative+NativeMethods", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.PInvokeMethod({Static:true , Public:false}, "FreeLibrary", 
      new JSIL.MethodSignature($.Boolean, [$.IntPtr]), 
      {
        Module: "kernel32.dll", 
      }
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.PInvokeMethod({Static:true , Public:false}, "GetProcAddress", 
      new JSIL.MethodSignature($.IntPtr, [$asm12.TypeRef("System.IO.Compression.ZLibNative+SafeLibraryHandle"), $.String]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'ansi',
      }
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.PInvokeMethod({Static:true , Public:false}, "LoadLibrary", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+SafeLibraryHandle"), [$.String]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'unicode',
      }
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.ZLibNative+SafeLibraryHandle */ 

(function SafeLibraryHandle$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "System.IO.Compression.ZLibNative+SafeLibraryHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "ReleaseHandle", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

})();

/* class System.IO.Compression.ZLibNative+ZLibStreamHandle */ 

(function ZLibStreamHandle$Members () {
  var $, $thisType;


























  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid"), 
      Name: "System.IO.Compression.ZLibNative+ZLibStreamHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "Deflate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$asm12.TypeRef("System.IO.Compression.ZLibNative+FlushCode")])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "DeflateEnd", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"))
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "DeflateInit2_", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [
          $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionLevel"), $.Int32, 
          $.Int32, $asm12.TypeRef("System.IO.Compression.ZLibNative+CompressionStrategy")
        ])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false}, "EnsureNotDisposed", 
      JSIL.MethodSignature.Void
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false}, "EnsureState", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle+State"))
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_Adler", 
      JSIL.MethodSignature.Return($.UInt32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_AvailIn", 
      JSIL.MethodSignature.Return($.UInt32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_AvailOut", 
      JSIL.MethodSignature.Return($.UInt32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_DataType", 
      JSIL.MethodSignature.Return($.Int32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_InitializationState", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle+State"))
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_NextIn", 
      JSIL.MethodSignature.Return($.IntPtr)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_NextOut", 
      JSIL.MethodSignature.Return($.IntPtr)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_TotalIn", 
      JSIL.MethodSignature.Return($.UInt32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "get_TotalOut", 
      JSIL.MethodSignature.Return($.UInt32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "GetErrorMessage", 
      JSIL.MethodSignature.Return($.String)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "Inflate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$asm12.TypeRef("System.IO.Compression.ZLibNative+FlushCode")])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "InflateEnd", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"))
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "InflateInit2_", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), [$.Int32])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "ReleaseHandle", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "set_AvailIn", 
      JSIL.MethodSignature.Action($.UInt32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "set_AvailOut", 
      JSIL.MethodSignature.Action($.UInt32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "set_NextIn", 
      JSIL.MethodSignature.Action($.IntPtr)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "set_NextOut", 
      JSIL.MethodSignature.Action($.IntPtr)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "ZLibCompileFlags", 
      JSIL.MethodSignature.Return($.Int32)
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Field({Static:true , Public:false}, "zlibLibraryHandle", $asm12.TypeRef("System.IO.Compression.ZLibNative+SafeLibraryHandle"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Field({Static:false, Public:false}, "zStream", $asm12.TypeRef("System.IO.Compression.ZLibNative+ZStream"));

    $.Field({Static:false, Public:false}, "initializationState", $asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle+State"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Property({Static:false, Public:true }, "InitializationState", $asm12.TypeRef("System.IO.Compression.ZLibNative+ZLibStreamHandle+State"));

    $.Property({Static:false, Public:true }, "NextIn", $.IntPtr);

    $.Property({Static:false, Public:true }, "AvailIn", $.UInt32);

    $.Property({Static:false, Public:true }, "TotalIn", $.UInt32);

    $.Property({Static:false, Public:true }, "NextOut", $.IntPtr);

    $.Property({Static:false, Public:true }, "AvailOut", $.UInt32);

    $.Property({Static:false, Public:true }, "TotalOut", $.UInt32);

    $.Property({Static:false, Public:true }, "DataType", $.Int32);

    $.Property({Static:false, Public:true }, "Adler", $.UInt32);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

})();

/* class System.IO.Compression.ZLibNative+ZLibStreamHandle+NativeZLibDLLStub */ 

(function NativeZLibDLLStub$Members () {
  var $, $thisType;




  JSIL.MakeStaticClass("System.IO.Compression.ZLibNative+ZLibStreamHandle+NativeZLibDLLStub", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CreateDelegate", 
      new JSIL.MethodSignature("!!0", [$.String], ["DT"])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "InitDelegates", 
      JSIL.MethodSignature.Void
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "LoadZLibDLL", 
      JSIL.MethodSignature.Void
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.Field({Static:true , Public:false}, "deflateInit2_Delegate", $asm12.TypeRef("System.IO.Compression.ZLibNative+DeflateInit2_Delegate"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Field({Static:true , Public:false}, "deflateDelegate", $asm12.TypeRef("System.IO.Compression.ZLibNative+DeflateDelegate"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Field({Static:true , Public:false}, "deflateEndDelegate", $asm12.TypeRef("System.IO.Compression.ZLibNative+DeflateEndDelegate"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Field({Static:true , Public:false}, "inflateInit2_Delegate", $asm12.TypeRef("System.IO.Compression.ZLibNative+InflateInit2_Delegate"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Field({Static:true , Public:false}, "inflateDelegate", $asm12.TypeRef("System.IO.Compression.ZLibNative+InflateDelegate"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Field({Static:true , Public:false}, "inflateEndDelegate", $asm12.TypeRef("System.IO.Compression.ZLibNative+InflateEndDelegate"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.Field({Static:true , Public:false}, "zlibCompileFlagsDelegate", $asm12.TypeRef("System.IO.Compression.ZLibNative+ZlibCompileFlagsDelegate"))
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

})();

/* enum System.IO.Compression.ZLibNative+ZLibStreamHandle+State */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.ZLibNative+ZLibStreamHandle+State", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    NotInitialized: 0, 
    InitializedForDeflate: 1, 
    InitializedForInflate: 2, 
    Disposed: 3, 
  }
);

/* class System.IO.Compression.ZLibException */ 

(function ZLibException$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.IO.IOException"), 
      Name: "System.IO.Compression.ZLibException", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.Int32, $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm0F.TypeRef("System.Exception")])
    );

    $.ExternalMethod({Static:false, Public:false}, "Init", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Init", 
      new JSIL.MethodSignature(null, [
          $.String, $asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"), 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.ISerializable.GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), "GetObjectData");

    $.Field({Static:false, Public:false}, "zlibErrorContext", $.String);

    $.Field({Static:false, Public:false}, "zlibErrorMessage", $.String);

    $.Field({Static:false, Public:false}, "zlibErrorCode", $asm12.TypeRef("System.IO.Compression.ZLibNative+ErrorCode"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.DeflateStream */ 

(function DeflateStream$Members () {
  var $, $thisType;









































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.IO.Stream"), 
      Name: "System.IO.Compression.DeflateStream", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.IO.Stream"), $asm12.TypeRef("System.IO.Compression.CompressionMode")])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.IO.Stream"), $.Boolean, 
          $asm12.TypeRef("System.IO.Compression.IFileFormatReader")
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.IO.Stream"), $asm12.TypeRef("System.IO.Compression.CompressionMode"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.IO.Stream"), $asm12.TypeRef("System.IO.Compression.CompressionLevel")])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.IO.Stream"), $asm12.TypeRef("System.IO.Compression.CompressionLevel"), 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AwaitAsyncResultCompletion", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.DeflateStreamAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginRead", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginWrite", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckEndXxxxLegalStateAndParams", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateDeflater", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.IDeflater"), [$asm0F.TypeRef("System.Nullable`1", [$asm12.TypeRef("System.IO.Compression.CompressionLevel")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateInflater", 
      new JSIL.MethodSignature($asm12.TypeRef("System.IO.Compression.IInflater"), [$asm12.TypeRef("System.IO.Compression.IFileFormatReader")])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "DoMaintenance", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "DoWrite", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndRead", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureCompressionMode", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureDecompressionMode", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureNotDisposed", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Flush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_BaseStream", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.IO.Stream"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanRead", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanSeek", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanWrite", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Position", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetDeflaterType", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.DeflateStream+WorkerType"))
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "GetInflaterType", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.DeflateStream+WorkerType"))
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:false}, "InternalWrite", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "PurgeBuffers", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Read", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadCallback", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Seek", 
      new JSIL.MethodSignature($.Int64, [$.Int64, $asm0F.TypeRef("System.IO.SeekOrigin")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Position", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.ExternalMethod({Static:false, Public:false}, "SetFileFormatWriter", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.IFileFormatWriter"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "SetLength", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.ExternalMethod({Static:false, Public:false}, "ValidateParameters", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteCallback", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteDeflaterOutput", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.Constant({Static:true , Public:false}, "DefaultBufferSize", $.Int32, 8192);

    $.Constant({Static:true , Public:false}, "WindowSizeUpperBound", $.Int32, 47);

    $.Field({Static:false, Public:false}, "_stream", $asm0F.TypeRef("System.IO.Stream"));

    $.Field({Static:false, Public:false}, "_mode", $asm12.TypeRef("System.IO.Compression.CompressionMode"));

    $.Field({Static:false, Public:false}, "_leaveOpen", $.Boolean);

    $.Field({Static:false, Public:false}, "inflater", $asm12.TypeRef("System.IO.Compression.IInflater"));

    $.Field({Static:false, Public:false}, "deflater", $asm12.TypeRef("System.IO.Compression.IDeflater"));

    $.Field({Static:false, Public:false}, "buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "asyncOperations", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "m_CallBack", $asm0F.TypeRef("System.AsyncCallback"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "m_AsyncWriterDelegate", $asm12.TypeRef("System.IO.Compression.DeflateStream+AsyncWriteDelegate"));

    $.Field({Static:false, Public:false}, "formatWriter", $asm12.TypeRef("System.IO.Compression.IFileFormatWriter"));

    $.Field({Static:false, Public:false}, "wroteHeader", $.Boolean);

    $.Field({Static:false, Public:false}, "wroteBytes", $.Boolean);

    $.Field({Static:true , Public:false}, "deflaterType", $asm12.TypeRef("System.IO.Compression.DeflateStream+WorkerType"), function ($pi) {
        return $asm12.System.IO.Compression.DeflateStream_WorkerType.Unknown;
      });

    $.Field({Static:true , Public:false}, "inflaterType", $asm12.TypeRef("System.IO.Compression.DeflateStream+WorkerType"), function ($pi) {
        return $asm12.System.IO.Compression.DeflateStream_WorkerType.Unknown;
      });

    $.Property({Static:false, Public:true }, "BaseStream", $asm0F.TypeRef("System.IO.Stream"));

    $.Property({Static:false, Public:true , Virtual:true }, "CanRead", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanWrite", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanSeek", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Length", $.Int64);

    $.Property({Static:false, Public:true , Virtual:true }, "Position", $.Int64);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate System.IO.Compression.DeflateStream+AsyncWriteDelegate */ 

JSIL.MakeDelegate("System.IO.Compression.DeflateStream+AsyncWriteDelegate", false, [], 
  new JSIL.MethodSignature(null, [
      $jsilcore.TypeRef("System.Array", [$asm0F.TypeRef("System.Byte")]), $asm0F.TypeRef("System.Int32"), 
      $asm0F.TypeRef("System.Int32"), $asm0F.TypeRef("System.Boolean")
    ]));

/* enum System.IO.Compression.DeflateStream+WorkerType */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.DeflateStream+WorkerType", 
    BaseType: $asm0F.TypeRef("System.Byte"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Managed: 0, 
    ZLib: 1, 
    Unknown: 2, 
  }
);

/* class System.IO.Compression.DeflateStreamAsyncResult */ 

(function DeflateStreamAsyncResult$Members () {
  var $, $thisType;












  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.DeflateStreamAsyncResult", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 6, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Object, $.Object, 
          $asm0F.TypeRef("System.AsyncCallback"), $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Complete", 
      new JSIL.MethodSignature(null, [$.Boolean, $.Object])
    );

    $.ExternalMethod({Static:false, Public:false}, "Complete", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_AsyncState", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_AsyncWaitHandle", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Threading.WaitHandle"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CompletedSynchronously", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsCompleted", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Result", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "InvokeCallback", 
      new JSIL.MethodSignature(null, [$.Boolean, $.Object])
    );

    $.ExternalMethod({Static:false, Public:false}, "InvokeCallback", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.Field({Static:false, Public:true }, "buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:true }, "offset", $.Int32);

    $.Field({Static:false, Public:true }, "count", $.Int32);

    $.Field({Static:false, Public:true }, "isWrite", $.Boolean);

    $.Field({Static:false, Public:false}, "m_AsyncObject", $.Object);

    $.Field({Static:false, Public:false}, "m_AsyncState", $.Object);

    $.Field({Static:false, Public:false}, "m_AsyncCallback", $asm0F.TypeRef("System.AsyncCallback"));

    $.Field({Static:false, Public:false}, "m_Result", $.Object);

    $.Field({Static:false, Public:false}, "m_CompletedSynchronously", $.Boolean);

    $.Field({Static:false, Public:false}, "m_InvokedCallback", $.Int32);

    $.Field({Static:false, Public:false}, "m_Completed", $.Int32);

    $.Field({Static:false, Public:false}, "m_Event", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "AsyncState", $.Object);

    $.Property({Static:false, Public:true , Virtual:true }, "AsyncWaitHandle", $asm0F.TypeRef("System.Threading.WaitHandle"));

    $.Property({Static:false, Public:true , Virtual:true }, "CompletedSynchronously", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "IsCompleted", $.Boolean);

    $.Property({Static:false, Public:false}, "Result", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IAsyncResult")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.FastEncoder */ 

(function FastEncoder$Members () {
  var $, $thisType;


















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.FastEncoder", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "FlushInput", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_BytesInHistory", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_LastCompressionRatio", 
      JSIL.MethodSignature.Return($.Double)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_UnprocessedInput", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.DeflateInput"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetBlock", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.IO.Compression.DeflateInput"), $asm12.TypeRef("System.IO.Compression.OutputBuffer"), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetBlockFooter", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.OutputBuffer"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetBlockHeader", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.OutputBuffer"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCompressedData", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.IO.Compression.DeflateInput"), $asm12.TypeRef("System.IO.Compression.OutputBuffer")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCompressedOutput", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.IO.Compression.DeflateInput"), $asm12.TypeRef("System.IO.Compression.OutputBuffer"), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCompressedOutput", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.OutputBuffer"))
    );

    $.ExternalMethod({Static:false, Public:false}, "InputAvailable", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.IO.Compression.DeflateInput")])
    );

    $.ExternalMethod({Static:false, Public:false}, "SafeToWriteTo", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.IO.Compression.OutputBuffer")])
    );

    $.ExternalMethod({Static:true , Public:false}, "WriteChar", 
      new JSIL.MethodSignature(null, [$.Byte, $asm12.TypeRef("System.IO.Compression.OutputBuffer")])
    );

    $.ExternalMethod({Static:true , Public:false}, "WriteDeflatePreamble", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.OutputBuffer"))
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteEndOfBlock", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.OutputBuffer"))
    );

    $.ExternalMethod({Static:true , Public:false}, "WriteMatch", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $asm12.TypeRef("System.IO.Compression.OutputBuffer")
        ])
    );

    $.Field({Static:false, Public:false}, "inputWindow", $asm12.TypeRef("System.IO.Compression.FastEncoderWindow"));

    $.Field({Static:false, Public:false}, "currentMatch", $asm12.TypeRef("System.IO.Compression.Match"));

    $.Field({Static:false, Public:false}, "lastCompressionRatio", $.Double);

    $.Property({Static:false, Public:false}, "BytesInHistory", $.Int32);

    $.Property({Static:false, Public:false}, "UnprocessedInput", $asm12.TypeRef("System.IO.Compression.DeflateInput"));

    $.Property({Static:false, Public:false}, "LastCompressionRatio", $.Double);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.FastEncoderStatics */ 

(function FastEncoderStatics$Members () {
  var $, $thisType;



  JSIL.MakeStaticClass("System.IO.Compression.FastEncoderStatics", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "BitReverse", 
      new JSIL.MethodSignature($.UInt32, [$.UInt32, $.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetSlot", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "FastEncoderTreeStructureData", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "BFinalFastEncoderTreeStructureData", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "FastEncoderLiteralCodeInfo", $jsilcore.TypeRef("System.Array", [$.UInt32]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "FastEncoderDistanceCodeInfo", $jsilcore.TypeRef("System.Array", [$.UInt32]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "BitMask", $jsilcore.TypeRef("System.Array", [$.UInt32]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "ExtraLengthBits", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "ExtraDistanceBits", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false}, "distLookup", $jsilcore.TypeRef("System.Array", [$.Byte]), function ($pi) {
        return JSIL.Array.New($asm0F.System.Byte, 512);
      });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.FastEncoderWindow */ 

(function FastEncoderWindow$Members () {
  var $, $thisType;














  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.FastEncoderWindow", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "CopyBytes", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "FindMatch", 
      new JSIL.MethodSignature($.Int32, [
          $.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Int32]), 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "FlushWindow", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_BytesAvailable", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_FreeWindowSpace", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_UnprocessedInput", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.DeflateInput"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetNextSymbolOrMatch", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.IO.Compression.Match")])
    );

    $.ExternalMethod({Static:false, Public:false}, "HashValue", 
      new JSIL.MethodSignature($.UInt32, [$.UInt32, $.Byte])
    );

    $.ExternalMethod({Static:false, Public:false}, "InsertString", 
      new JSIL.MethodSignature($.UInt32, [$jsilcore.TypeRef("JSIL.Reference", [$.UInt32])])
    );

    $.ExternalMethod({Static:false, Public:false}, "InsertStrings", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.UInt32]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "MoveWindows", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ResetWindow", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "window", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "bufPos", $.Int32);

    $.Field({Static:false, Public:false}, "bufEnd", $.Int32);

    $.Field({Static:false, Public:false}, "prev", $jsilcore.TypeRef("System.Array", [$.UInt16]));

    $.Field({Static:false, Public:false}, "lookup", $jsilcore.TypeRef("System.Array", [$.UInt16]));

    $.Property({Static:false, Public:true }, "BytesAvailable", $.Int32);

    $.Property({Static:false, Public:true }, "UnprocessedInput", $asm12.TypeRef("System.IO.Compression.DeflateInput"));

    $.Property({Static:false, Public:true }, "FreeWindowSpace", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface System.IO.Compression.IFileFormatWriter */ 

JSIL.MakeInterface(
  "System.IO.Compression.IFileFormatWriter", false, [], function ($) {
    $.Method({}, "GetHeader", JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte])));
    $.Method({}, "UpdateWithBytesRead", new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ]));
    $.Method({}, "GetFooter", JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte])));
  }, []);

/* interface System.IO.Compression.IFileFormatReader */ 

JSIL.MakeInterface(
  "System.IO.Compression.IFileFormatReader", false, [], function ($) {
    $.Method({}, "ReadHeader", new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.IO.Compression.InputBuffer")]));
    $.Method({}, "ReadFooter", new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.IO.Compression.InputBuffer")]));
    $.Method({}, "UpdateWithBytesRead", new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ]));
    $.Method({}, "Validate", JSIL.MethodSignature.Void);
  }, []);

/* class System.IO.Compression.GZipStream */ 

(function GZipStream$Members () {
  var $, $thisType;
















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.IO.Stream"), 
      Name: "System.IO.Compression.GZipStream", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginRead", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "BeginWrite", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32, $asm0F.TypeRef("System.AsyncCallback"), 
          $.Object
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndRead", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("System.IAsyncResult")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "EndWrite", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.IAsyncResult"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Flush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanRead", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanSeek", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CanWrite", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Position", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Read", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Seek", 
      new JSIL.MethodSignature($.Int64, [$.Int64, $asm0F.TypeRef("System.IO.SeekOrigin")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Position", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.Field({Static:false, Public:false}, "deflateStream", $asm12.TypeRef("System.IO.Compression.DeflateStream"));

    $.Property({Static:false, Public:true , Virtual:true }, "CanRead", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanWrite", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "CanSeek", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Length", $.Int64);

    $.Property({Static:false, Public:true , Virtual:true }, "Position", $.Int64);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.HuffmanTree */ 

(function HuffmanTree$Members () {
  var $, $thisType;









  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.HuffmanTree", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, "CalculateHuffmanCode", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.UInt32]))
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateTable", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:true }, "get_StaticDistanceTree", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_StaticLiteralLengthTree", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:true }, "GetNextSymbol", 
      new JSIL.MethodSignature($.Int32, [$asm12.TypeRef("System.IO.Compression.InputBuffer")])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetStaticDistanceTreeLength", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:true , Public:false}, "GetStaticLiteralTreeLength", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.Field({Static:false, Public:false}, "tableBits", $.Int32);

    $.Field({Static:false, Public:false}, "table", $jsilcore.TypeRef("System.Array", [$.Int16]));

    $.Field({Static:false, Public:false}, "left", $jsilcore.TypeRef("System.Array", [$.Int16]));

    $.Field({Static:false, Public:false}, "right", $jsilcore.TypeRef("System.Array", [$.Int16]));

    $.Field({Static:false, Public:false}, "codeLengthArray", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "tableMask", $.Int32);

    $.Field({Static:true , Public:false}, "staticLiteralLengthTree", $.Type);

    $.Field({Static:true , Public:false}, "staticDistanceTree", $.Type);

    $.Property({Static:true , Public:true }, "StaticLiteralLengthTree", $.Type);

    $.Property({Static:true , Public:true }, "StaticDistanceTree", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.Inflater */ 

(function Inflater$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.Inflater", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.IFileFormatReader"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Decode", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "DecodeBlock", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$.Boolean])])
    );

    $.ExternalMethod({Static:false, Public:false}, "DecodeDynamicBlockHeader", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "DecodeUncompressedBlock", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Reference", [$.Boolean])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Finished", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Inflate", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Reset", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "SetInput", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "extraLengthBits", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "lengthBase", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "distanceBasePosition", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "codeOrder", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "staticDistanceTreeTable", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "output", $asm12.TypeRef("System.IO.Compression.OutputWindow"));

    $.Field({Static:false, Public:false}, "input", $asm12.TypeRef("System.IO.Compression.InputBuffer"));

    $.Field({Static:false, Public:false}, "literalLengthTree", $asm12.TypeRef("System.IO.Compression.HuffmanTree"));

    $.Field({Static:false, Public:false}, "distanceTree", $asm12.TypeRef("System.IO.Compression.HuffmanTree"));

    $.Field({Static:false, Public:false}, "state", $asm12.TypeRef("System.IO.Compression.InflaterState"));

    $.Field({Static:false, Public:false}, "hasFormatReader", $.Boolean);

    $.Field({Static:false, Public:false}, "bfinal", $.Int32);

    $.Field({Static:false, Public:false}, "blockType", $asm12.TypeRef("System.IO.Compression.BlockType"));

    $.Field({Static:false, Public:false}, "blockLengthBuffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "blockLength", $.Int32);

    $.Field({Static:false, Public:false}, "$length", $.Int32);

    $.Field({Static:false, Public:false}, "distanceCode", $.Int32);

    $.Field({Static:false, Public:false}, "extraBits", $.Int32);

    $.Field({Static:false, Public:false}, "loopCounter", $.Int32);

    $.Field({Static:false, Public:false}, "literalLengthCodeCount", $.Int32);

    $.Field({Static:false, Public:false}, "distanceCodeCount", $.Int32);

    $.Field({Static:false, Public:false}, "codeLengthCodeCount", $.Int32);

    $.Field({Static:false, Public:false}, "codeArraySize", $.Int32);

    $.Field({Static:false, Public:false}, "lengthCode", $.Int32);

    $.Field({Static:false, Public:false}, "codeList", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "codeLengthTreeCodeLength", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "codeLengthTree", $asm12.TypeRef("System.IO.Compression.HuffmanTree"));

    $.Field({Static:false, Public:false}, "formatReader", $asm12.TypeRef("System.IO.Compression.IFileFormatReader"));

    $.ImplementInterfaces(
      /* 0 */ $asm12.TypeRef("System.IO.Compression.IInflater"), 
      /* 1 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.IO.Compression.InflaterState */ 

JSIL.MakeEnum(
  {
    FullName: "System.IO.Compression.InflaterState", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    ReadingHeader: 0, 
    ReadingBFinal: 2, 
    ReadingBType: 3, 
    ReadingNumLitCodes: 4, 
    ReadingNumDistCodes: 5, 
    ReadingNumCodeLengthCodes: 6, 
    ReadingCodeLengthCodes: 7, 
    ReadingTreeCodesBefore: 8, 
    ReadingTreeCodesAfter: 9, 
    DecodeTop: 10, 
    HaveInitialLength: 11, 
    HaveFullLength: 12, 
    HaveDistCode: 13, 
    UncompressedAligning: 15, 
    UncompressedByte1: 16, 
    UncompressedByte2: 17, 
    UncompressedByte3: 18, 
    UncompressedByte4: 19, 
    DecodingUncompressed: 20, 
    StartReadingFooter: 21, 
    ReadingFooter: 22, 
    VerifyingFooter: 23, 
    Done: 24, 
  }
);

/* class System.IO.Compression.InputBuffer */ 

(function InputBuffer$Members () {
  var $, $thisType;













  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.InputBuffer", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "CopyTo", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "EnsureBitsAvailable", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AvailableBits", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AvailableBytes", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetBitMask", 
      new JSIL.MethodSignature($.UInt32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "GetBits", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "NeedsInput", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "SetInput", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "SkipBits", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "SkipToByteBoundary", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "TryLoad16Bits", 
      JSIL.MethodSignature.Return($.UInt32)
    );

    $.Field({Static:false, Public:false}, "buffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "start", $.Int32);

    $.Field({Static:false, Public:false}, "end", $.Int32);

    $.Field({Static:false, Public:false}, "bitBuffer", $.UInt32);

    $.Field({Static:false, Public:false}, "bitsInBuffer", $.Int32);

    $.Property({Static:false, Public:true }, "AvailableBits", $.Int32);

    $.Property({Static:false, Public:true }, "AvailableBytes", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.Match */ 

(function Match$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.Match", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Length", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Position", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_State", 
      JSIL.MethodSignature.Return($asm12.TypeRef("MatchState"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Symbol", 
      JSIL.MethodSignature.Return($.Byte)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Length", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Position", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_State", 
      JSIL.MethodSignature.Action($asm12.TypeRef("MatchState"))
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Symbol", 
      JSIL.MethodSignature.Action($.Byte)
    );

    $.Field({Static:false, Public:false}, "state", $asm12.TypeRef("MatchState"));

    $.Field({Static:false, Public:false}, "pos", $.Int32);

    $.Field({Static:false, Public:false}, "len", $.Int32);

    $.Field({Static:false, Public:false}, "symbol", $.Byte);

    $.Property({Static:false, Public:false}, "State", $asm12.TypeRef("MatchState"));

    $.Property({Static:false, Public:false}, "Position", $.Int32);

    $.Property({Static:false, Public:false}, "Length", $.Int32);

    $.Property({Static:false, Public:false}, "Symbol", $.Byte);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.OutputBuffer */ 

(function OutputBuffer$Members () {
  var $, $thisType;














  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.OutputBuffer", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "DumpState", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.IO.Compression.OutputBuffer+BufferState"))
    );

    $.ExternalMethod({Static:false, Public:false}, "FlushBits", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_BitsInBuffer", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_BytesWritten", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_FreeBytes", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "RestoreState", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.IO.Compression.OutputBuffer+BufferState"))
    );

    $.ExternalMethod({Static:false, Public:false}, "UpdateBuffer", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.Byte]))
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteBits", 
      new JSIL.MethodSignature(null, [$.Int32, $.UInt32])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteBytes", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteBytesUnaligned", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteByteUnaligned", 
      JSIL.MethodSignature.Action($.Byte)
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteUInt16", 
      JSIL.MethodSignature.Action($.UInt16)
    );

    $.Field({Static:false, Public:false}, "byteBuffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "pos", $.Int32);

    $.Field({Static:false, Public:false}, "bitBuf", $.UInt32);

    $.Field({Static:false, Public:false}, "bitCount", $.Int32);

    $.Property({Static:false, Public:false}, "BytesWritten", $.Int32);

    $.Property({Static:false, Public:false}, "FreeBytes", $.Int32);

    $.Property({Static:false, Public:false}, "BitsInBuffer", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.IO.Compression.OutputBuffer+BufferState */ 

(function BufferState$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.IO.Compression.OutputBuffer+BufferState", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "pos", $.Int32);

    $.Field({Static:false, Public:false}, "bitBuf", $.UInt32);

    $.Field({Static:false, Public:false}, "bitCount", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.IO.Compression.OutputWindow */ 

(function OutputWindow$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.IO.Compression.OutputWindow", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "CopyFrom", 
      new JSIL.MethodSignature($.Int32, [$asm12.TypeRef("System.IO.Compression.InputBuffer"), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "CopyTo", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AvailableBytes", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_FreeBytes", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "Write", 
      JSIL.MethodSignature.Action($.Byte)
    );

    $.ExternalMethod({Static:false, Public:true }, "WriteLengthDistance", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32])
    );

    $.Field({Static:false, Public:false}, "window", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "end", $.Int32);

    $.Field({Static:false, Public:false}, "bytesUsed", $.Int32);

    $.Property({Static:false, Public:true }, "FreeBytes", $.Int32);

    $.Property({Static:false, Public:true }, "AvailableBytes", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Security");
JSIL.DeclareNamespace("System.Security.Cryptography");
/* class System.Security.Cryptography.SafeCertStoreHandle */ 

(function SafeCertStoreHandle$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid"), 
      Name: "System.Security.Cryptography.SafeCertStoreHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Security.Cryptography.X509Certificates");
/* class System.Security.Cryptography.X509Certificates.X509Store */ 

(function X509Store$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Security.Cryptography.X509Certificates.X509Store", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "m_safeCertStoreHandle", $asm12.TypeRef("System.Security.Cryptography.SafeCertStoreHandle"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Security.Permissions");
/* class System.Security.Permissions.ResourcePermissionBase */ 

(function ResourcePermissionBase$Members () {
  var $, $thisType;



























  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Security.CodeAccessPermission"), 
      Name: "System.Security.Permissions.ResourcePermissionBase", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Security.Permissions.PermissionState"))
    );

    $.ExternalMethod({Static:false, Public:false}, "AddPermissionAccess", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Security.Permissions.ResourcePermissionBaseEntry"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Copy", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.IPermission"))
    );

    $.ExternalMethod({Static:false, Public:false}, "CopyChildren", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Hashtable"), [$.Object, $.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateHashtable", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Hashtable"))
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateInstance", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "FromXml", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Security.SecurityElement"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_ComputerName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsEmpty", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_PermissionAccessType", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Type"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_TagNames", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:false}, "HasContent", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Intersect", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Security.IPermission"), [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:false, Public:false}, "IntersectContents", 
      new JSIL.MethodSignature($.Object, [$.Object, $.Object])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsContentSubset", 
      new JSIL.MethodSignature($.Boolean, [$.Object, $.Object])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IsSubsetOf", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "IsUnrestricted", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "MergeContents", 
      new JSIL.MethodSignature($.Object, [$.Object, $.Object])
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadChildren", 
      new JSIL.MethodSignature($.Object, [$asm0F.TypeRef("System.Security.SecurityElement"), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "set_PermissionAccessType", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Type"))
    );

    $.ExternalMethod({Static:false, Public:false}, "set_TagNames", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ToXml", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.SecurityElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Union", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Security.IPermission"), [$asm0F.TypeRef("System.Security.IPermission")])
    );

    $.ExternalMethod({Static:false, Public:false}, "UnionOfContents", 
      new JSIL.MethodSignature($.Object, [$.Object, $.Object])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteChildren", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.Security.SecurityElement"), $.Object, 
          $.Int32
        ])
    );

    $.Field({Static:false, Public:false}, "tagNames", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "permissionAccessType", $asm0F.TypeRef("System.Type"));

    $.Field({Static:false, Public:false}, "isUnrestricted", $.Boolean);

    $.Field({Static:false, Public:false}, "rootTable", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:false, Public:false}, "ComputerName", $.String);

    $.Property({Static:false, Public:false}, "IsEmpty", $.Boolean);

    $.Property({Static:false, Public:false}, "PermissionAccessType", $asm0F.TypeRef("System.Type"));

    $.Property({Static:false, Public:false}, "TagNames", $jsilcore.TypeRef("System.Array", [$.String]));

    $.ImplementInterfaces(
      /* 3 */ $asm0F.TypeRef("System.Security.Permissions.IUnrestrictedPermission")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Security.Permissions.ResourcePermissionBase+UnsafeNativeMethods */ 

(function UnsafeNativeMethods$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.Security.Permissions.ResourcePermissionBase+UnsafeNativeMethods", false, [], function ($ib) {
    $ = $ib;

    $.PInvokeMethod({Static:true , Public:false}, "GetComputerName", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Text.StringBuilder"), $jsilcore.TypeRef("JSIL.Reference", [$.Int32])]), 
      {
        Module: "kernel32.dll", 
        CharSet: 'auto',
      }
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Security.Permissions.ResourcePermissionBaseEntry */ 

(function ResourcePermissionBaseEntry$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Security.Permissions.ResourcePermissionBaseEntry", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Int32, $jsilcore.TypeRef("System.Array", [$.String])])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_PermissionAccess", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_PermissionAccessPath", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.Field({Static:false, Public:false}, "accessPath", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "permissionAccess", $.Int32);

    $.Property({Static:false, Public:true }, "PermissionAccess", $.Int32);

    $.Property({Static:false, Public:true }, "PermissionAccessPath", $jsilcore.TypeRef("System.Array", [$.String]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.AssertSection */ 

(function AssertSection$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Diagnostics.AssertSection", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AssertUIEnabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_LogFileName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "_properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propAssertUIEnabled", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propLogFile", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "AssertUIEnabled", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["assertuienabled"]; });

    $.Property({Static:false, Public:true }, "LogFileName", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["logfilename"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.AssertWrapper */ 

(function AssertWrapper$Members () {
  var $, $thisType;





  JSIL.MakeStaticClass("System.Diagnostics.AssertWrapper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "get_IsRTLResources", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "ShowAssert", 
      new JSIL.MethodSignature(null, [
          $.String, $asm0F.TypeRef("System.Diagnostics.StackFrame"), 
          $.String, $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ShowMessageBoxAssert", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.ExternalMethod({Static:true , Public:false}, "TruncateMessageToFitScreen", 
      new JSIL.MethodSignature($.String, [$.String])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.Property({Static:true , Public:false}, "IsRTLResources", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.MessageBoxPopup */ 

(function MessageBoxPopup$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm0F.System.Int32)) ();
  };




  function MessageBoxPopup_get_ReturnValue () {
    return this.MessageBoxPopup$ReturnValue$value;
  }; 

  function MessageBoxPopup_set_ReturnValue (value) {
    this.MessageBoxPopup$ReturnValue$value = (value | 0);
  }; 


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.MessageBoxPopup", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.Int32
        ])
    )
      .Attribute($asm0F.TypeRef("System.Security.SecurityCriticalAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "DoPopup", 
      JSIL.MethodSignature.Void
    )
      .Attribute($asm0F.TypeRef("System.Security.SecuritySafeCriticalAttribute"));

    $.Method({Static:false, Public:true }, "get_ReturnValue", 
      JSIL.MethodSignature.Return($.Int32), 
      MessageBoxPopup_get_ReturnValue
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_ReturnValue", 
      JSIL.MethodSignature.Action($.Int32), 
      MessageBoxPopup_set_ReturnValue
    )
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.ExternalMethod({Static:false, Public:true }, "ShowMessageBox", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.Field({Static:false, Public:false}, "MessageBoxPopup$ReturnValue$value", $.Int32)
      .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:false, Public:false}, "m_Event", $asm0F.TypeRef("System.Threading.AutoResetEvent"));

    $.Field({Static:false, Public:false}, "m_Body", $.String);

    $.Field({Static:false, Public:false}, "m_Title", $.String);

    $.Field({Static:false, Public:false}, "m_Flags", $.Int32);

    $.Property({Static:false, Public:true }, "ReturnValue", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.CorrelationManager */ 

(function CorrelationManager$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.CorrelationManager", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ActivityId", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Guid"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_LogicalOperationStack", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Stack"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetLogicalOperationStack", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Stack"))
    );

    $.Property({Static:false, Public:true }, "ActivityId", $asm0F.TypeRef("System.Guid"));

    $.Property({Static:false, Public:true }, "LogicalOperationStack", $asm0F.TypeRef("System.Collections.Stack"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.Debug */ 

(function Debug$Members () {
  var $, $thisType;




  JSIL.MakeStaticClass("System.Diagnostics.Debug", true, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "Assert", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "Assert", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String])
    );

    $.ExternalMethod({Static:true , Public:true }, "WriteLine", 
      JSIL.MethodSignature.Action($.String)
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.TraceListener */ 

(function TraceListener$Members () {
  var $, $thisType;




























  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.MarshalByRefObject"), 
      Name: "System.Diagnostics.TraceListener", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Fail", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Fail", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Flush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Attributes", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Collections.Specialized.StringDictionary"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Filter", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceFilter"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_IsThreadSafe", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_NeedIndent", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_TraceOutputOptions", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceOptions"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetSupportedAttributes", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:false}, "IsEnabled", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Diagnostics.TraceOptions")])
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Filter", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.TraceFilter"))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_IndentLevel", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_IndentSize", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Name", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_NeedIndent", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_TraceOutputOptions", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.TraceOptions"))
    );

    $.ExternalMethod({Static:false, Public:false}, "SetAttributes", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Hashtable"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "TraceEvent", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceEventCache"), $.String, 
          $asm12.TypeRef("System.Diagnostics.TraceEventType"), $.Int32, 
          $.String
        ])
    )
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteFooter", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.TraceEventCache"))
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteHeader", 
      new JSIL.MethodSignature(null, [
          $.String, $asm12.TypeRef("System.Diagnostics.TraceEventType"), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "WriteIndent", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "WriteLine", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:false, Public:false}, "indentLevel", $.Int32);

    $.Field({Static:false, Public:false}, "indentSize", $.Int32);

    $.Field({Static:false, Public:false}, "traceOptions", $asm12.TypeRef("System.Diagnostics.TraceOptions"));

    $.Field({Static:false, Public:false}, "needIndent", $.Boolean);

    $.Field({Static:false, Public:false}, "listenerName", $.String);

    $.Field({Static:false, Public:false}, "filter", $asm12.TypeRef("System.Diagnostics.TraceFilter"));

    $.Field({Static:false, Public:false}, "attributes", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Field({Static:false, Public:false}, "initializeData", $.String);

    $.Property({Static:false, Public:true }, "Attributes", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Property({Static:false, Public:true , Virtual:true }, "Name", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "IsThreadSafe", $.Boolean);

    $.Property({Static:false, Public:true }, "IndentLevel", $.Int32);

    $.Property({Static:false, Public:true }, "IndentSize", $.Int32);

    $.Property({Static:false, Public:true }, "Filter", $asm12.TypeRef("System.Diagnostics.TraceFilter"))
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

    $.Property({Static:false, Public:false}, "NeedIndent", $.Boolean);

    $.Property({Static:false, Public:true }, "TraceOutputOptions", $asm12.TypeRef("System.Diagnostics.TraceOptions"))
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.DefaultTraceListener */ 

(function DefaultTraceListener$Members () {
  var $, $thisType;















  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.TraceListener"), 
      Name: "System.Diagnostics.DefaultTraceListener", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Fail", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Fail", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AssertUiEnabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_LogFileName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_UiPermission", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "InitializeSettings", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "internalWrite", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "Write", 
      new JSIL.MethodSignature(null, [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteAssert", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "WriteLine", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteLine", 
      new JSIL.MethodSignature(null, [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteToLogFile", 
      new JSIL.MethodSignature(null, [$.String, $.Boolean])
    );

    $.Field({Static:false, Public:false}, "assertUIEnabled", $.Boolean);

    $.Field({Static:false, Public:false}, "logFileName", $.String);

    $.Field({Static:false, Public:false}, "settingsInitialized", $.Boolean);

    $.Property({Static:false, Public:true }, "AssertUiEnabled", $.Boolean);

    $.Property({Static:false, Public:true }, "LogFileName", $.String);

    $.Property({Static:true , Public:false}, "UiPermission", $.Boolean);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.TextWriterTraceListener */ 

(function TextWriterTraceListener$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.TraceListener"), 
      Name: "System.Diagnostics.TextWriterTraceListener", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureWriter", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Flush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "GetEncodingWithFallback", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Text.Encoding"), [$asm0F.TypeRef("System.Text.Encoding")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "WriteLine", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:false, Public:false}, "writer", $asm0F.TypeRef("System.IO.TextWriter"));

    $.Field({Static:false, Public:false}, "fileName", $.String);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.DelimitedListTraceListener */ 

(function DelimitedListTraceListener$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.TextWriterTraceListener"), 
      Name: "System.Diagnostics.DelimitedListTraceListener", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_Delimiter", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetSupportedAttributes", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "TraceEvent", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceEventCache"), $.String, 
          $asm12.TypeRef("System.Diagnostics.TraceEventType"), $.Int32, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteEscaped", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteFooter", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.TraceEventCache"))
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteHeader", 
      new JSIL.MethodSignature(null, [
          $.String, $asm12.TypeRef("System.Diagnostics.TraceEventType"), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteStackEscaped", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Collections.Stack"))
    );

    $.Field({Static:false, Public:false}, "delimiter", $.String);

    $.Field({Static:false, Public:false}, "initializedDelim", $.Boolean);

    $.Property({Static:false, Public:true }, "Delimiter", $.String);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.InitState */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.InitState", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    NotInitialized: 0, 
    Initializing: 1, 
    Initialized: 2, 
  }
);

/* class System.Diagnostics.DiagnosticsConfiguration */ 

(function DiagnosticsConfiguration$Members () {
  var $, $thisType;

















  JSIL.MakeStaticClass("System.Diagnostics.DiagnosticsConfiguration", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CanInitialize", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_AssertUIEnabled", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_AutoFlush", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_ConfigFilePath", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_IndentSize", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_LogFileName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_PerfomanceCountersFileMappingSize", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_SharedListeners", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_Sources", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SourceElementsCollection"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_SwitchSettings", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SwitchElementsCollection"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_SystemDiagnosticsSection", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SystemDiagnosticsSection"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_UseGlobalLock", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetConfigSection", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SystemDiagnosticsSection"))
    );

    $.ExternalMethod({Static:true , Public:false}, "Initialize", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "IsInitialized", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "IsInitializing", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:true , Public:false}, "configSection", $asm12.TypeRef("System.Diagnostics.SystemDiagnosticsSection"));

    $.Field({Static:true , Public:false}, "initState", $asm12.TypeRef("System.Diagnostics.InitState"));

    $.Property({Static:true , Public:false}, "SwitchSettings", $asm12.TypeRef("System.Diagnostics.SwitchElementsCollection"));

    $.Property({Static:true , Public:false}, "AssertUIEnabled", $.Boolean);

    $.Property({Static:true , Public:false}, "ConfigFilePath", $.String);

    $.Property({Static:true , Public:false}, "LogFileName", $.String);

    $.Property({Static:true , Public:false}, "AutoFlush", $.Boolean);

    $.Property({Static:true , Public:false}, "UseGlobalLock", $.Boolean);

    $.Property({Static:true , Public:false}, "IndentSize", $.Int32);

    $.Property({Static:true , Public:false}, "PerfomanceCountersFileMappingSize", $.Int32);

    $.Property({Static:true , Public:false}, "SharedListeners", $asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"));

    $.Property({Static:true , Public:false}, "Sources", $asm12.TypeRef("System.Diagnostics.SourceElementsCollection"));

    $.Property({Static:true , Public:false}, "SystemDiagnosticsSection", $asm12.TypeRef("System.Diagnostics.SystemDiagnosticsSection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.TypedElement */ 

(function TypedElement$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Diagnostics.TypedElement", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Type"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BaseGetRuntimeObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_InitData", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_TypeName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_TypeName", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propTypeName", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propInitData", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false}, "_properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:false, Public:false}, "_runtimeObject", $.Object);

    $.Field({Static:false, Public:false}, "_baseType", $asm0F.TypeRef("System.Type"));

    $.Property({Static:false, Public:true }, "InitData", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["initializeData"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true , Virtual:true }, "TypeName", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["type"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.FilterElement */ 

(function FilterElement$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.TypedElement"), 
      Name: "System.Diagnostics.FilterElement", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "GetRuntimeObject", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceFilter"))
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ListenerElementsCollection */ 

(function ListenerElementsCollection$Members () {
  var $, $thisType;










  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElementCollection"), 
      Name: "System.Diagnostics.ListenerElementsCollection", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "BaseAdd", 
      JSIL.MethodSignature.Action($asm14.TypeRef("System.Configuration.ConfigurationElement"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "CreateNewElement", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CollectionType", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.ListenerElement"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetElementKey", 
      new JSIL.MethodSignature($.Object, [$asm14.TypeRef("System.Configuration.ConfigurationElement")])
    );

    $.ExternalMethod({Static:false, Public:true }, "GetRuntimeObject", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceListenerCollection"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "InitializeDefault", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "InitializeDefaultInternal", 
      JSIL.MethodSignature.Void
    );

    $.Property({Static:false, Public:true }, "Item", $asm12.TypeRef("System.Diagnostics.ListenerElement"));

    $.Property({Static:false, Public:true , Virtual:true }, "CollectionType", $asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm14.TypeRef("System.Configuration.ConfigurationCollectionAttribute"), function () { return [$asm12.System.Diagnostics.ListenerElement.__Type__]; });

})();

/* class System.Diagnostics.SharedListenerElementsCollection */ 

(function SharedListenerElementsCollection$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"), 
      Name: "System.Diagnostics.SharedListenerElementsCollection", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "CreateNewElement", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CollectionType", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_ElementName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Property({Static:false, Public:true , Virtual:true }, "CollectionType", $asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"));

    $.Property({Static:false, Public:false, Virtual:true }, "ElementName", $.String);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm14.TypeRef("System.Configuration.ConfigurationCollectionAttribute"), function () { return [$asm12.System.Diagnostics.ListenerElement.__Type__]; });

})();

/* class System.Diagnostics.ListenerElement */ 

(function ListenerElement$Members () {
  var $, $thisType;













  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.TypedElement"), 
      Name: "System.Diagnostics.ListenerElement", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Attributes", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Hashtable"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Filter", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.FilterElement"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_TraceOutputOptions", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceOptions"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_TypeName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "GetRuntimeObject", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceListener"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnDeserializeUnrecognizedAttribute", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Name", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_TypeName", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propFilter", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propName", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propOutputOpts", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false}, "_propListenerTypeName", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false}, "_allowReferences", $.Boolean);

    $.Field({Static:false, Public:false}, "_attributes", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_isAddedByDefault", $.Boolean);

    $.Property({Static:false, Public:true }, "Attributes", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:false, Public:true }, "Filter", $asm12.TypeRef("System.Diagnostics.FilterElement"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["filter"]; });

    $.Property({Static:false, Public:true }, "Name", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["name"]; });

    $.Property({Static:false, Public:true }, "TraceOutputOptions", $asm12.TypeRef("System.Diagnostics.TraceOptions"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["traceOutputOptions"]; });

    $.Property({Static:false, Public:true , Virtual:true }, "TypeName", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["type"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.PerfCounterSection */ 

(function PerfCounterSection$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Diagnostics.PerfCounterSection", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_FileMappingSize", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "_properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propFileMappingSize", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "FileMappingSize", $.Int32)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["filemappingsize"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.SourceElementsCollection */ 

(function SourceElementsCollection$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElementCollection"), 
      Name: "System.Diagnostics.SourceElementsCollection", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "CreateNewElement", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CollectionType", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_ElementName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.SourceElement"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetElementKey", 
      new JSIL.MethodSignature($.Object, [$asm14.TypeRef("System.Configuration.ConfigurationElement")])
    );

    $.Property({Static:false, Public:true }, "Item", $asm12.TypeRef("System.Diagnostics.SourceElement"));

    $.Property({Static:false, Public:false, Virtual:true }, "ElementName", $.String);

    $.Property({Static:false, Public:true , Virtual:true }, "CollectionType", $asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm14.TypeRef("System.Configuration.ConfigurationCollectionAttribute"), function () { return [$asm12.System.Diagnostics.SourceElement.__Type__]; });

})();

/* class System.Diagnostics.SourceElement */ 

(function SourceElement$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Diagnostics.SourceElement", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "DeserializeElement", 
      new JSIL.MethodSignature(null, [$asm24.TypeRef("System.Xml.XmlReader"), $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Attributes", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Hashtable"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Listeners", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SwitchName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SwitchType", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SwitchValue", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnDeserializeUnrecognizedAttribute", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "_properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propName", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propSwitchName", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propSwitchValue", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propSwitchType", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propListeners", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false}, "_attributes", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:false, Public:true }, "Attributes", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:false, Public:true }, "Listeners", $asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["listeners"]; });

    $.Property({Static:false, Public:true }, "Name", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["name"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true }, "SwitchName", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["switchName"]; });

    $.Property({Static:false, Public:true }, "SwitchValue", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["switchValue"]; });

    $.Property({Static:false, Public:true }, "SwitchType", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["switchType"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.SourceLevels */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.SourceLevels", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    All: -1, 
    Off: 0, 
    Critical: 1, 
    Error: 3, 
    Warning: 7, 
    Information: 15, 
    Verbose: 31, 
    ActivityTracing: 65280, 
  }
);

/* class System.Diagnostics.Switch */ 

(function Switch$Members () {
  var $, $thisType;














  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.Switch", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "_pruneCachedSwitches", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_DisplayName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_SwitchSetting", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Value", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetSupportedAttributes", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.String]))
    );

    $.ExternalMethod({Static:false, Public:false}, "Initialize", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "InitializeConfigSettings", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "InitializeWithStatus", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnSwitchSettingChanged", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnValueChanged", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "set_SwitchSetting", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Value", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:false, Public:false}, "switchSettings", $asm12.TypeRef("System.Diagnostics.SwitchElementsCollection"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "description", $.String);

    $.Field({Static:false, Public:false, ReadOnly:true }, "displayName", $.String);

    $.Field({Static:false, Public:false}, "switchSetting", $.Int32);

    $.Field({Static:false, Public:false}, "initialized", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:false, Public:false}, "initializing", $.Boolean);

    $.Field({Static:false, Public:false}, "switchValueString", $asm0F.TypeRef("System.String"));

    $.Field({Static:false, Public:false}, "attributes", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Field({Static:false, Public:false}, "defaultValue", $.String);

    $.Field({Static:true , Public:false}, "switches", $asm0F.TypeRef("System.Collections.Generic.List`1", [$asm0F.TypeRef("System.WeakReference")]));

    $.Field({Static:true , Public:false}, "s_LastCollectionCount", $.Int32);

    $.Property({Static:false, Public:true }, "DisplayName", $.String);

    $.Property({Static:false, Public:false}, "SwitchSetting", $.Int32);

    $.Property({Static:false, Public:false}, "Value", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.SourceSwitch */ 

(function SourceSwitch$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.Switch"), 
      Name: "System.Diagnostics.SourceSwitch", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnValueChanged", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "set_Level", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.SourceLevels"))
    );

    $.ExternalMethod({Static:false, Public:true }, "ShouldTrace", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Diagnostics.TraceEventType")])
    );

    $.Property({Static:false, Public:true }, "Level", $asm12.TypeRef("System.Diagnostics.SourceLevels"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.SwitchElementsCollection */ 

(function SwitchElementsCollection$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElementCollection"), 
      Name: "System.Diagnostics.SwitchElementsCollection", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "CreateNewElement", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElement"))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_CollectionType", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.SwitchElement"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "GetElementKey", 
      new JSIL.MethodSignature($.Object, [$asm14.TypeRef("System.Configuration.ConfigurationElement")])
    );

    $.Property({Static:false, Public:true }, "Item", $asm12.TypeRef("System.Diagnostics.SwitchElement"));

    $.Property({Static:false, Public:true , Virtual:true }, "CollectionType", $asm14.TypeRef("System.Configuration.ConfigurationElementCollectionType"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm14.TypeRef("System.Configuration.ConfigurationCollectionAttribute"), function () { return [$asm12.System.Diagnostics.SwitchElement.__Type__]; });

})();

/* class System.Diagnostics.SwitchElement */ 

(function SwitchElement$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Diagnostics.SwitchElement", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Attributes", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Hashtable"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Name", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Value", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnDeserializeUnrecognizedAttribute", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "_properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propName", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propValue", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:false, Public:false}, "_attributes", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:false, Public:true }, "Attributes", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:false, Public:true }, "Name", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["name"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true }, "Value", $.String)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["value"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.SystemDiagnosticsSection */ 

(function SystemDiagnosticsSection$Members () {
  var $, $thisType;









  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationSection"), 
      Name: "System.Diagnostics.SystemDiagnosticsSection", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_Assert", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.AssertSection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_PerfCounters", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.PerfCounterSection"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SharedListeners", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Sources", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SourceElementsCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Switches", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SwitchElementsCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Trace", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceSection"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "InitializeDefault", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "_properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propAssert", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propPerfCounters", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propSources", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propSharedListeners", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propSwitches", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propTrace", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "Assert", $asm12.TypeRef("System.Diagnostics.AssertSection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["assert"]; });

    $.Property({Static:false, Public:true }, "PerfCounters", $asm12.TypeRef("System.Diagnostics.PerfCounterSection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["performanceCounters"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Property({Static:false, Public:true }, "Sources", $asm12.TypeRef("System.Diagnostics.SourceElementsCollection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["sources"]; });

    $.Property({Static:false, Public:true }, "SharedListeners", $asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["sharedListeners"]; });

    $.Property({Static:false, Public:true }, "Switches", $asm12.TypeRef("System.Diagnostics.SwitchElementsCollection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["switches"]; });

    $.Property({Static:false, Public:true }, "Trace", $asm12.TypeRef("System.Diagnostics.TraceSection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["trace"]; });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.Trace */ 

(function Trace$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.Trace", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "get_AutoFlush", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_CorrelationManager", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.CorrelationManager"))
    );

    $.ExternalMethod({Static:true , Public:true }, "WriteLine", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:true , Public:false}, "correlationManager", $asm12.TypeRef("System.Diagnostics.CorrelationManager"));

    $.Property({Static:true , Public:true }, "AutoFlush", $.Boolean);

    $.Property({Static:true , Public:true }, "CorrelationManager", $asm12.TypeRef("System.Diagnostics.CorrelationManager"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.TraceEventCache */ 

(function TraceEventCache$Members () {
  var $, $thisType;













  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.TraceEventCache", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "get_ActivityId", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Guid"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Callstack", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_DateTime", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.DateTime"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_LogicalOperationStack", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Stack"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ProcessId", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ThreadId", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Timestamp", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetProcessId", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetProcessName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetThreadId", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "InitProcessInfo", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:true , Public:false}, "processId", $asm0F.TypeRef("System.Int32"));

    $.Field({Static:true , Public:false}, "processName", $asm0F.TypeRef("System.String"));

    $.Field({Static:false, Public:false}, "timeStamp", $.Int64);

    $.Field({Static:false, Public:false}, "dateTime", $asm0F.TypeRef("System.DateTime"));

    $.Field({Static:false, Public:false}, "stackTrace", $.String);

    $.Property({Static:false, Public:false}, "ActivityId", $asm0F.TypeRef("System.Guid"));

    $.Property({Static:false, Public:true }, "Callstack", $.String);

    $.Property({Static:false, Public:true }, "LogicalOperationStack", $asm0F.TypeRef("System.Collections.Stack"));

    $.Property({Static:false, Public:true }, "DateTime", $asm0F.TypeRef("System.DateTime"));

    $.Property({Static:false, Public:true }, "ProcessId", $.Int32);

    $.Property({Static:false, Public:true }, "ThreadId", $.String);

    $.Property({Static:false, Public:true }, "Timestamp", $.Int64);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.TraceEventType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.TraceEventType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Critical: 1, 
    Error: 2, 
    Warning: 4, 
    Information: 8, 
    Verbose: 16, 
    Start: 256, 
    Stop: 512, 
    Suspend: 1024, 
    Resume: 2048, 
    Transfer: 4096, 
  }
);

/* class System.Diagnostics.TraceFilter */ 

(function TraceFilter$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.TraceFilter", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "ShouldTrace", 
      new JSIL.MethodSignature($.Boolean, [
          $asm12.TypeRef("System.Diagnostics.TraceEventCache"), $.String, 
          $asm12.TypeRef("System.Diagnostics.TraceEventType"), $.Int32, 
          $.String, $jsilcore.TypeRef("System.Array", [$.Object]), 
          $.Object, $jsilcore.TypeRef("System.Array", [$.Object])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "ShouldTrace", 
      new JSIL.MethodSignature($.Boolean, [
          $asm12.TypeRef("System.Diagnostics.TraceEventCache"), $.String, 
          $asm12.TypeRef("System.Diagnostics.TraceEventType"), $.Int32, 
          $.String
        ])
    );

    $.Field({Static:false, Public:false}, "initializeData", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.TraceInternal */ 

(function TraceInternal$Members () {
  var $, $thisType;












  JSIL.MakeStaticClass("System.Diagnostics.TraceInternal", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "Assert", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "Assert", 
      new JSIL.MethodSignature(null, [$.Boolean, $.String])
    );

    $.ExternalMethod({Static:true , Public:true }, "Fail", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_AutoFlush", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_IndentLevel", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_IndentSize", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_Listeners", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.TraceListenerCollection"))
    );

    $.ExternalMethod({Static:true , Public:true }, "get_UseGlobalLock", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "InitializeSettings", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "SetIndentSize", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:true , Public:true }, "WriteLine", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:true , Public:false}, "appName", $asm0F.TypeRef("System.String"), null);

    $.Field({Static:true , Public:false}, "listeners", $asm12.TypeRef("System.Diagnostics.TraceListenerCollection"));

    $.Field({Static:true , Public:false}, "autoFlush", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "useGlobalLock", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "indentLevel", $.Int32);

    $.Field({Static:true , Public:false}, "indentSize", $asm0F.TypeRef("System.Int32"));

    $.Field({Static:true , Public:false}, "settingsInitialized", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "defaultInitialized", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "critSec", $.Object);

    $.Property({Static:true , Public:true }, "Listeners", $asm12.TypeRef("System.Diagnostics.TraceListenerCollection"));

    $.Property({Static:true , Public:true }, "AutoFlush", $.Boolean);

    $.Property({Static:true , Public:true }, "UseGlobalLock", $.Boolean);

    $.Property({Static:true , Public:true }, "IndentLevel", $.Int32);

    $.Property({Static:true , Public:true }, "IndentSize", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.TraceLevel */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.TraceLevel", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Off: 0, 
    Error: 1, 
    Warning: 2, 
    Info: 3, 
    Verbose: 4, 
  }
);

/* class System.Diagnostics.TraceListenerCollection */ 

(function TraceListenerCollection$Members () {
  var $, $thisType;
















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.TraceListenerCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature($.Int32, [$asm12.TypeRef("System.Diagnostics.TraceListener")])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Clear", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "get_Count", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.TraceListener"), [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetEnumerator", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.IEnumerator"))
    );

    $.ExternalMethod({Static:false, Public:false}, "InitializeListener", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.TraceListener"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.CopyTo", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Array"), $.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "CopyTo");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.get_SyncRoot", 
      JSIL.MethodSignature.Return($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.ICollection"), "get_SyncRoot");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.Add", 
      new JSIL.MethodSignature($.Int32, [$.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "Add");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.Contains", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "Contains");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.get_IsReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "get_IsReadOnly");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.get_Item", 
      new JSIL.MethodSignature($.Object, [$.Int32])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "get_Item");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.Remove", 
      JSIL.MethodSignature.Action($.Object)
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "Remove");

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Collections.IList.set_Item", 
      new JSIL.MethodSignature(null, [$.Int32, $.Object])
    )
      .Overrides($asm0F.TypeRef("System.Collections.IList"), "set_Item");

    $.Field({Static:false, Public:false}, "list", $asm0F.TypeRef("System.Collections.ArrayList"));

    $.Property({Static:false, Public:true }, "Item", $asm12.TypeRef("System.Diagnostics.TraceListener"));

    $.Property({Static:false, Public:true , Virtual:true }, "Count", $.Int32);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IList.Item", $.Object);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.IList.IsReadOnly", $.Boolean);

    $.Property({Static:false, Public:false, Virtual:true }, "System.Collections.ICollection.SyncRoot", $.Object);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.IList"), 
      /* 1 */ $asm0F.TypeRef("System.Collections.ICollection"), 
      /* 2 */ $asm0F.TypeRef("System.Collections.IEnumerable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.TraceOptions */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.TraceOptions", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    None: 0, 
    LogicalOperationStack: 1, 
    DateTime: 2, 
    Timestamp: 4, 
    ProcessId: 8, 
    ThreadId: 16, 
    Callstack: 32, 
  }
);

/* class System.Diagnostics.TraceSection */ 

(function TraceSection$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm14.TypeRef("System.Configuration.ConfigurationElement"), 
      Name: "System.Diagnostics.TraceSection", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "get_AutoFlush", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_IndentSize", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Listeners", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "get_Properties", 
      JSIL.MethodSignature.Return($asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_UseGlobalLock", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "_properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propListeners", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propAutoFlush", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propIndentSize", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propUseGlobalLock", $asm14.TypeRef("System.Configuration.ConfigurationProperty"));

    $.Property({Static:false, Public:true }, "AutoFlush", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["autoflush"]; });

    $.Property({Static:false, Public:true }, "IndentSize", $.Int32)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["indentsize"]; });

    $.Property({Static:false, Public:true }, "Listeners", $asm12.TypeRef("System.Diagnostics.ListenerElementsCollection"))
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["listeners"]; });

    $.Property({Static:false, Public:true }, "UseGlobalLock", $.Boolean)
      .Attribute($asm14.TypeRef("System.Configuration.ConfigurationPropertyAttribute"), function () { return ["useGlobalLock"]; });

    $.Property({Static:false, Public:false, Virtual:true }, "Properties", $asm14.TypeRef("System.Configuration.ConfigurationPropertyCollection"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.TraceSwitch */ 

(function TraceSwitch$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.Switch"), 
      Name: "System.Diagnostics.TraceSwitch", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnSwitchSettingChanged", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "OnValueChanged", 
      JSIL.MethodSignature.Void
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.TraceUtils */ 

(function TraceUtils$Members () {
  var $, $thisType;






  JSIL.MakeStaticClass("System.Diagnostics.TraceUtils", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "ConvertToBaseTypeOrEnum", 
      new JSIL.MethodSignature($.Object, [$.String, $asm0F.TypeRef("System.Type")])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetRuntimeObject", 
      new JSIL.MethodSignature($.Object, [
          $.String, $asm0F.TypeRef("System.Type"), 
          $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsOwnedTextWriterTL", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Type")])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsOwnedTL", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Type")])
    );

    $.ExternalMethod({Static:true , Public:false}, "VerifyAttributes", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.Collections.IDictionary"), $jsilcore.TypeRef("System.Array", [$.String]), 
          $.Object
        ])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.XmlWriterTraceListener */ 

(function XmlWriterTraceListener$Members () {
  var $, $thisType;












  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.TextWriterTraceListener"), 
      Name: "System.Diagnostics.XmlWriterTraceListener", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Fail", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalWrite", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "TraceEvent", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceEventCache"), $.String, 
          $asm12.TypeRef("System.Diagnostics.TraceEventType"), $.Int32, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteEndHeader", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.TraceEventCache"))
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteEscaped", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteFooter", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.TraceEventCache"))
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteHeader", 
      new JSIL.MethodSignature(null, [
          $.String, $asm12.TypeRef("System.Diagnostics.TraceEventType"), 
          $.Int32, $asm12.TypeRef("System.Diagnostics.TraceEventCache")
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "WriteLine", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "WriteStartHeader", 
      new JSIL.MethodSignature(null, [
          $.String, $asm12.TypeRef("System.Diagnostics.TraceEventType"), 
          $.Int32, $asm12.TypeRef("System.Diagnostics.TraceEventCache")
        ])
    );

    $.Field({Static:false, Public:false, ReadOnly:true }, "machineName", $.String);

    $.Field({Static:false, Public:false}, "strBldr", $asm0F.TypeRef("System.Text.StringBuilder"));

    $.Field({Static:false, Public:false}, "xmlBlobWriter", $asm24.TypeRef("System.Xml.XmlTextWriter"));

    $.Field({Static:false, Public:false}, "shouldRespectFilterOnTraceTransfer", $.Boolean);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.AsyncStreamReader */ 

(function AsyncStreamReader$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.AsyncStreamReader", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 5, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.IDisposable.Dispose", 
      JSIL.MethodSignature.Void
    )
      .Overrides($asm0F.TypeRef("System.IDisposable"), "Dispose");

    $.Field({Static:false, Public:false}, "stream", $asm0F.TypeRef("System.IO.Stream"));

    $.Field({Static:false, Public:false}, "encoding", $asm0F.TypeRef("System.Text.Encoding"));

    $.Field({Static:false, Public:false}, "decoder", $asm0F.TypeRef("System.Text.Decoder"));

    $.Field({Static:false, Public:false}, "byteBuffer", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "charBuffer", $jsilcore.TypeRef("System.Array", [$.Char]));

    $.Field({Static:false, Public:false}, "eofEvent", $asm0F.TypeRef("System.Threading.ManualResetEvent"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Diagnostics.CounterSample */ 

(function CounterSample$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Diagnostics.CounterSample", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 8, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int64, $.Int64, 
          $.Int64, $.Int64, 
          $.Int64, $.Int64, 
          $asm12.TypeRef("System.Diagnostics.PerformanceCounterType")
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.Field({Static:false, Public:false}, "rawValue", $.Int64);

    $.Field({Static:false, Public:false}, "baseValue", $.Int64);

    $.Field({Static:false, Public:false}, "timeStamp", $.Int64);

    $.Field({Static:false, Public:false}, "counterFrequency", $.Int64);

    $.Field({Static:false, Public:false}, "counterType", $asm12.TypeRef("System.Diagnostics.PerformanceCounterType"));

    $.Field({Static:false, Public:false}, "timeStamp100nSec", $.Int64);

    $.Field({Static:false, Public:false}, "systemFrequency", $.Int64);

    $.Field({Static:false, Public:false}, "counterTimeStamp", $.Int64);

    $.Field({Static:true , Public:true }, "Empty", $.Type);


    function CounterSample__cctor () {
      $thisType.Empty = new $thisType();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      CounterSample__cctor
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.EntryWrittenEventArgs */ 

(function EntryWrittenEventArgs$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.EventArgs"), 
      Name: "System.Diagnostics.EntryWrittenEventArgs", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.EventLogEntry"))
    );

    $.Field({Static:false, Public:false}, "entry", $asm12.TypeRef("System.Diagnostics.EventLogEntry"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate System.Diagnostics.EntryWrittenEventHandler */ 

JSIL.MakeDelegate("System.Diagnostics.EntryWrittenEventHandler", true, [], 
  new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Object"), $asm12.TypeRef("System.Diagnostics.EntryWrittenEventArgs")]));

/* class System.Diagnostics.EventInstance */ 

(function EventInstance$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.EventInstance", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Int64, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_CategoryId", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_EntryType", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.EventLogEntryType"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_InstanceId", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_CategoryId", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_EntryType", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.EventLogEntryType"))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_InstanceId", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.Field({Static:false, Public:false}, "_categoryNumber", $.Int32);

    $.Field({Static:false, Public:false}, "_entryType", $asm12.TypeRef("System.Diagnostics.EventLogEntryType"));

    $.Field({Static:false, Public:false}, "_instanceId", $.Int64);

    $.Property({Static:false, Public:true }, "CategoryId", $.Int32);

    $.Property({Static:false, Public:true }, "EntryType", $asm12.TypeRef("System.Diagnostics.EventLogEntryType"));

    $.Property({Static:false, Public:true }, "InstanceId", $.Int64);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.EventLog */ 

(function EventLog$Members () {
  var $, $thisType;


























  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.ComponentModel.Component"), 
      Name: "System.Diagnostics.EventLog", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "_InternalLogNameFromSourceName", 
      new JSIL.MethodSignature($.String, [$.String, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "_UnsafeGetAssertPermSet", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Security.PermissionSet"))
    );

    $.ExternalMethod({Static:true , Public:false}, "CharIsPrintable", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ComponentGetService", 
      new JSIL.MethodSignature($.Object, [$asm0F.TypeRef("System.Type")])
    );

    $.ExternalMethod({Static:true , Public:true }, "CreateEventSource", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.EventSourceCreationData"))
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "Exists", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "FindSame8FirstCharsLog", 
      new JSIL.MethodSignature($.String, [$asm0F.TypeRef("Microsoft.Win32.RegistryKey"), $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "FindSourceRegistration", 
      new JSIL.MethodSignature($asm0F.TypeRef("Microsoft.Win32.RegistryKey"), [
          $.String, $.String, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "FindSourceRegistration", 
      new JSIL.MethodSignature($asm0F.TypeRef("Microsoft.Win32.RegistryKey"), [
          $.String, $.String, 
          $.Boolean, $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "FixupPath", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_ComponentDesignMode", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_SkipRegPatch", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetDllPath", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetEventLogRegKey", 
      new JSIL.MethodSignature($asm0F.TypeRef("Microsoft.Win32.RegistryKey"), [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:true }, "LogNameFromSourceName", 
      new JSIL.MethodSignature($.String, [$.String, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "SetSpecialLogRegValues", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("Microsoft.Win32.RegistryKey"), $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "SetSpecialSourceRegValues", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("Microsoft.Win32.RegistryKey"), $asm12.TypeRef("System.Diagnostics.EventSourceCreationData")])
    );

    $.ExternalMethod({Static:true , Public:false}, "SourceExists", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.String, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ValidLogName", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:true }, "WriteEntry", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "WriteEntry", 
      new JSIL.MethodSignature(null, [
          $.String, $asm12.TypeRef("System.Diagnostics.EventLogEntryType"), 
          $.Int32, $.Int16, 
          $jsilcore.TypeRef("System.Array", [$.Byte])
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "WriteEvent", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.EventInstance"), $jsilcore.TypeRef("System.Array", [$.Object])])
    )
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; })
      .Parameter(1, "values", function (_) {
          _.Attribute($asm0F.TypeRef("System.ParamArrayAttribute"))
        });

    $.ExternalMethod({Static:false, Public:true }, "WriteEvent", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.EventInstance"), $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ])
    )
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; })
      .Parameter(2, "values", function (_) {
          _.Attribute($asm0F.TypeRef("System.ParamArrayAttribute"))
        });

    $.Field({Static:false, Public:false}, "m_underlyingEventLog", $asm12.TypeRef("System.Diagnostics.EventLogInternal"));

    $.Field({Static:true , Public:false}, "s_CheckedOsVersion", $asm0F.TypeRef("System.Boolean"));

    $.Field({Static:true , Public:false}, "s_SkipRegPatch", $asm0F.TypeRef("System.Boolean"));

    $.Property({Static:true , Public:false}, "SkipRegPatch", $.Boolean);

    $.Property({Static:false, Public:false}, "ComponentDesignMode", $.Boolean);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.EventLogInternal */ 

(function EventLogInternal$Members () {
  var $, $thisType;









































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.EventLogInternal", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $asm12.TypeRef("System.Diagnostics.EventLog")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "AddListenerComponent", 
      new JSIL.MethodSignature(null, [
          $.Type, $.String, 
          $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "CharIsPrintable", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Close", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "CompletionCallback", 
      JSIL.MethodSignature.Action($.Object)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_EntryCount", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_InstanceLockObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_InternalSyncObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsOpen", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsOpenForRead", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_IsOpenForWrite", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Log", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MachineName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_OldestEntryNumber", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_ReadHandle", 
      JSIL.MethodSignature.Return($asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeEventLogReadHandle"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Source", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SynchronizingObject", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.ComponentModel.ISynchronizeInvoke"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCachedEntryPos", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetEntryWithOldest", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.EventLogEntry"), [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetLogName", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetNextEntryPos", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetPreviousEntryPos", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "InternalWriteEvent", 
      new JSIL.MethodSignature(null, [
          $.UInt32, $.UInt16, 
          $asm12.TypeRef("System.Diagnostics.EventLogEntryType"), $jsilcore.TypeRef("System.Array", [$.String]), 
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "IntFrom", 
      new JSIL.MethodSignature($.Int32, [$jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "OpenForRead", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "OpenForWrite", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "RemoveListenerComponent", 
      new JSIL.MethodSignature(null, [$.Type, $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "Reset", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "StartListening", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "StaticCompletionCallback", 
      new JSIL.MethodSignature(null, [$.Object, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "StopListening", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "StopRaisingEvents", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "ValidLogName", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "VerifyAndCreateSource", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "WriteEntry", 
      new JSIL.MethodSignature(null, [
          $.String, $asm12.TypeRef("System.Diagnostics.EventLogEntryType"), 
          $.Int32, $.Int16, 
          $jsilcore.TypeRef("System.Array", [$.Byte])
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "WriteEvent", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.EventInstance"), $jsilcore.TypeRef("System.Array", [$.Byte]), 
          $jsilcore.TypeRef("System.Array", [$.Object])
        ])
    )
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; })
      .Parameter(2, "values", function (_) {
          _.Attribute($asm0F.TypeRef("System.ParamArrayAttribute"))
        });

    $.Field({Static:false, Public:false}, "logName", $.String);

    $.Field({Static:false, Public:false}, "lastSeenCount", $.Int32);

    $.Field({Static:false, Public:false, ReadOnly:true }, "machineName", $.String);

    $.Field({Static:false, Public:false}, "onEntryWrittenHandler", $asm12.TypeRef("System.Diagnostics.EntryWrittenEventHandler"));

    $.Field({Static:false, Public:false}, "readHandle", $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeEventLogReadHandle"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "sourceName", $.String);

    $.Field({Static:false, Public:false}, "writeHandle", $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeEventLogWriteHandle"));

    $.Field({Static:false, Public:false}, "bytesCached", $.Int32);

    $.Field({Static:false, Public:false}, "cache", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "firstCachedEntry", $.Int32);

    $.Field({Static:false, Public:false}, "lastSeenEntry", $.Int32);

    $.Field({Static:false, Public:false}, "lastSeenPos", $.Int32);

    $.Field({Static:false, Public:false}, "synchronizingObject", $asm12.TypeRef("System.ComponentModel.ISynchronizeInvoke"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "parent", $asm12.TypeRef("System.Diagnostics.EventLog"));

    $.Field({Static:false, Public:false}, "boolFlags", $asm12.TypeRef("System.Collections.Specialized.BitVector32"));

    $.Field({Static:false, Public:false}, "messageLibraries", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "listenerInfos", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "m_InstanceLockObject", $.Object);

    $.Field({Static:true , Public:false}, "s_InternalSyncObject", $.Object);

    $.Property({Static:false, Public:false}, "InstanceLockObject", $.Object);

    $.Property({Static:true , Public:false}, "InternalSyncObject", $.Object);

    $.Property({Static:false, Public:false}, "EntryCount", $.Int32);

    $.Property({Static:false, Public:false}, "IsOpen", $.Boolean);

    $.Property({Static:false, Public:false}, "IsOpenForRead", $.Boolean);

    $.Property({Static:false, Public:false}, "IsOpenForWrite", $.Boolean);

    $.Property({Static:false, Public:true }, "Log", $.String);

    $.Property({Static:false, Public:true }, "MachineName", $.String);

    $.Property({Static:false, Public:false}, "OldestEntryNumber", $.Int32);

    $.Property({Static:false, Public:false}, "ReadHandle", $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeEventLogReadHandle"));

    $.Property({Static:false, Public:true }, "SynchronizingObject", $asm12.TypeRef("System.ComponentModel.ISynchronizeInvoke"));

    $.Property({Static:false, Public:true }, "Source", $.String);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.EventLogInternal+LogListeningInfo */ 

(function LogListeningInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.EventLogInternal+LogListeningInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "handleOwner", $asm12.TypeRef("System.Diagnostics.EventLogInternal"));

    $.Field({Static:false, Public:true }, "registeredWaitHandle", $asm0F.TypeRef("System.Threading.RegisteredWaitHandle"));

    $.Field({Static:false, Public:true }, "waitHandle", $asm0F.TypeRef("System.Threading.WaitHandle"));

    $.Field({Static:false, Public:true }, "listeningComponents", $asm0F.TypeRef("System.Collections.ArrayList"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.EventLogEntry */ 

(function EventLogEntry$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.ComponentModel.Component"), 
      Name: "System.Diagnostics.EventLogEntry", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32, 
          $asm12.TypeRef("System.Diagnostics.EventLogInternal")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "IntFrom", 
      new JSIL.MethodSignature($.Int32, [$jsilcore.TypeRef("System.Array", [$.Byte]), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.ISerializable.GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), "GetObjectData");

    $.Field({Static:false, Public:false}, "dataBuf", $jsilcore.TypeRef("System.Array", [$.Byte]));

    $.Field({Static:false, Public:false}, "bufOffset", $.Int32);

    $.Field({Static:false, Public:false}, "owner", $asm12.TypeRef("System.Diagnostics.EventLogInternal"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "beginningOfTime", $asm0F.TypeRef("System.DateTime"));


    function EventLogEntry__cctor () {
      $thisType.beginningOfTime = new $asm0F.System.DateTime();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      EventLogEntry__cctor
    );

    $.ImplementInterfaces(
      /* 2 */ $asm0F.TypeRef("System.Runtime.Serialization.ISerializable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.EventLogEntryType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.EventLogEntryType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Error: 1, 
    Warning: 2, 
    Information: 4, 
    SuccessAudit: 8, 
    FailureAudit: 16, 
  }
);

/* class System.Diagnostics.EventLogPermission */ 

(function EventLogPermission$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Security.Permissions.ResourcePermissionBase"), 
      Name: "System.Diagnostics.EventLogPermission", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.EventLogPermissionAccess"), $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddPermissionAccess", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.EventLogPermissionEntry"))
    );

    $.ExternalMethod({Static:false, Public:false}, "SetNames", 
      JSIL.MethodSignature.Void
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.EventLogPermissionAccess */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.EventLogPermissionAccess", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    None: 0, 
    Browse: 2, 
    Instrument: 6, 
    Audit: 10, 
    Write: 16, 
    Administer: 48, 
  }
);

/* class System.Diagnostics.EventLogPermissionEntry */ 

(function EventLogPermissionEntry$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.EventLogPermissionEntry", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Diagnostics.EventLogPermissionAccess"), $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MachineName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_PermissionAccess", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.EventLogPermissionAccess"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetBaseEntry", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Security.Permissions.ResourcePermissionBaseEntry"))
    );

    $.Property({Static:false, Public:true }, "MachineName", $.String);

    $.Property({Static:false, Public:true }, "PermissionAccess", $asm12.TypeRef("System.Diagnostics.EventLogPermissionAccess"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.EventLogTraceListener */ 

(function EventLogTraceListener$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Diagnostics.TraceListener"), 
      Name: "System.Diagnostics.EventLogTraceListener", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateEventInstance", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.EventInstance"), [$asm12.TypeRef("System.Diagnostics.TraceEventType"), $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "set_Name", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "TraceEvent", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.TraceEventCache"), $.String, 
          $asm12.TypeRef("System.Diagnostics.TraceEventType"), $.Int32, 
          $.String
        ])
    )
      .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [false]; });

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Write", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "WriteLine", 
      JSIL.MethodSignature.Action($.String)
    );

    $.Field({Static:false, Public:false}, "eventLog", $asm12.TypeRef("System.Diagnostics.EventLog"));

    $.Field({Static:false, Public:false}, "nameSet", $.Boolean);

    $.Property({Static:false, Public:true , Virtual:true }, "Name", $.String);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.EventSourceCreationData */ 

(function EventSourceCreationData$Members () {
  var $, $thisType;









  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.EventSourceCreationData", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 7, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_CategoryCount", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_CategoryResourceFile", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_LogName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MachineName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MessageResourceFile", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ParameterResourceFile", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Source", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "_logName", $.String);

    $.Field({Static:false, Public:false}, "_machineName", $.String);

    $.Field({Static:false, Public:false}, "_source", $.String);

    $.Field({Static:false, Public:false}, "_messageResourceFile", $.String);

    $.Field({Static:false, Public:false}, "_parameterResourceFile", $.String);

    $.Field({Static:false, Public:false}, "_categoryResourceFile", $.String);

    $.Field({Static:false, Public:false}, "_categoryCount", $.Int32);

    $.Property({Static:false, Public:true }, "LogName", $.String);

    $.Property({Static:false, Public:true }, "MachineName", $.String);

    $.Property({Static:false, Public:true }, "Source", $.String);

    $.Property({Static:false, Public:true }, "MessageResourceFile", $.String);

    $.Property({Static:false, Public:true }, "ParameterResourceFile", $.String);

    $.Property({Static:false, Public:true }, "CategoryResourceFile", $.String);

    $.Property({Static:false, Public:true }, "CategoryCount", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.PerformanceCounter */ 

(function PerformanceCounter$Members () {
  var $, $thisType;





















  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.ComponentModel.Component"), 
      Name: "System.Diagnostics.PerformanceCounter", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 5, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_InstanceLifetime", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_InstanceLockObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ReadOnly", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "IncrementBy", 
      new JSIL.MethodSignature($.Int64, [$.Int64])
    );

    $.ExternalMethod({Static:false, Public:false}, "Initialize", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "InitializeImpl", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "RemoveInstance", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "set_CategoryName", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_CounterName", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_InstanceLifetime", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime"))
    );

    $.ExternalMethod({Static:false, Public:true }, "set_InstanceName", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_MachineName", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_RawValue", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_ReadOnly", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "ThrowReadOnly", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "VerifyWriteableCounterAllowed", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "machineName", $.String);

    $.Field({Static:false, Public:false}, "categoryName", $.String);

    $.Field({Static:false, Public:false}, "counterName", $.String);

    $.Field({Static:false, Public:false}, "instanceName", $.String);

    $.Field({Static:false, Public:false}, "instanceLifetime", $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime"));

    $.Field({Static:false, Public:false}, "isReadOnly", $.Boolean);

    $.Field({Static:false, Public:false}, "initialized", $.Boolean);

    $.Field({Static:false, Public:false}, "helpMsg", $.String);

    $.Field({Static:false, Public:false}, "counterType", $.Int32);

    $.Field({Static:false, Public:false}, "oldSample", $asm12.TypeRef("System.Diagnostics.CounterSample"));

    $.Field({Static:false, Public:false}, "sharedCounter", $asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter"));

    $.Field({Static:true , Public:true }, "DefaultFileMappingSize", $.Int32, 524288);

    $.Field({Static:false, Public:false}, "m_InstanceLockObject", $.Object);

    $.Property({Static:false, Public:false}, "InstanceLockObject", $.Object);

    $.Property({Static:false, Public:true }, "CategoryName", $.String);

    $.Property({Static:false, Public:true }, "CounterName", $.String);

    $.Property({Static:false, Public:true }, "InstanceLifetime", $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime"));

    $.Property({Static:false, Public:true }, "InstanceName", $.String);

    $.Property({Static:false, Public:true }, "ReadOnly", $.Boolean);

    $.Property({Static:false, Public:true }, "MachineName", $.String);

    $.Property({Static:false, Public:true }, "RawValue", $.Int64);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.PerformanceCounterCategory */ 

(function PerformanceCounterCategory$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.PerformanceCounterCategory", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "Exists", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:true }, "Exists", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.PerformanceCounterCategoryType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.PerformanceCounterCategoryType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Unknown: -1, 
    SingleInstance: 0, 
    MultiInstance: 1, 
  }
);

/* enum System.Diagnostics.PerformanceCounterInstanceLifetime */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.PerformanceCounterInstanceLifetime", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Global: 0, 
    Process: 1, 
  }
);

/* class System.Diagnostics.PerformanceCounterLib */ 

(function PerformanceCounterLib$Members () {
  var $, $thisType;


















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.PerformanceCounterLib", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "CategoryExists", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "CategoryExists", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "CounterExists", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.String, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CounterExists", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.String, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "FindCustomCategory", 
      new JSIL.MethodSignature($.Boolean, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$asm12.TypeRef("System.Diagnostics.PerformanceCounterCategoryType")])])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_CategoryTable", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Hashtable"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_ComputerName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_InternalSyncObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_NameTable", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Hashtable"))
    );

    $.ExternalMethod({Static:true , Public:false}, "GetCategoryType", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.PerformanceCounterCategoryType"), [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCounterName", 
      new JSIL.MethodSignature($.String, [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetPerformanceCounterLib", 
      new JSIL.MethodSignature($.Type, [$.String, $asm0F.TypeRef("System.Globalization.CultureInfo")])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetPerformanceData", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Byte]), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetStringTable", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Hashtable"), [$.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsCustomCategory", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsCustomCategory", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.Field({Static:true , Public:false}, "computerName", $asm0F.TypeRef("System.String"));

    $.Field({Static:false, Public:false}, "performanceMonitor", $asm12.TypeRef("System.Diagnostics.PerformanceMonitor"));

    $.Field({Static:false, Public:false}, "machineName", $.String);

    $.Field({Static:false, Public:false}, "perfLcid", $.String);

    $.Field({Static:false, Public:false}, "customCategoryTable", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:true , Public:false}, "libraryTable", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "categoryTable", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "nameTable", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false, ReadOnly:true }, "CategoryTableLock", $.Object);

    $.Field({Static:false, Public:false, ReadOnly:true }, "NameTableLock", $.Object);

    $.Field({Static:false, Public:false, ReadOnly:true }, "HelpTableLock", $.Object);

    $.Field({Static:true , Public:false}, "s_InternalSyncObject", $.Object);

    $.Property({Static:true , Public:false}, "InternalSyncObject", $.Object);

    $.Property({Static:true , Public:false}, "ComputerName", $.String);

    $.Property({Static:false, Public:false}, "CategoryTable", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:false, Public:false}, "NameTable", $asm0F.TypeRef("System.Collections.Hashtable"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.PerformanceMonitor */ 

(function PerformanceMonitor$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.PerformanceMonitor", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetData", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Byte]), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "Init", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "perfDataKey", $asm0F.TypeRef("Microsoft.Win32.RegistryKey"));

    $.Field({Static:false, Public:false}, "machineName", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.CategoryEntry */ 

(function CategoryEntry$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.CategoryEntry", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("Microsoft.Win32.NativeMethods+PERF_OBJECT_TYPE"))
    );

    $.Field({Static:false, Public:false}, "NameIndex", $.Int32);

    $.Field({Static:false, Public:false}, "HelpIndex", $.Int32);

    $.Field({Static:false, Public:false}, "CounterIndexes", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "HelpIndexes", $jsilcore.TypeRef("System.Array", [$.Int32]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.PerformanceCounterPermission */ 

(function PerformanceCounterPermission$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Security.Permissions.ResourcePermissionBase"), 
      Name: "System.Diagnostics.PerformanceCounterPermission", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Security.Permissions.PermissionState"))
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.PerformanceCounterPermissionAccess"), $.String, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddPermissionAccess", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.PerformanceCounterPermissionEntry"))
    );

    $.ExternalMethod({Static:false, Public:false}, "SetNames", 
      JSIL.MethodSignature.Void
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.PerformanceCounterPermissionAccess */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.PerformanceCounterPermissionAccess", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    None: 0, 
    Browse: 1, 
    Read: 1, 
    Write: 2, 
    Instrument: 3, 
    Administer: 7, 
  }
);

/* class System.Diagnostics.PerformanceCounterPermissionEntry */ 

(function PerformanceCounterPermissionEntry$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.PerformanceCounterPermissionEntry", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Diagnostics.PerformanceCounterPermissionAccess"), $.String, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_CategoryName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MachineName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_PermissionAccess", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.PerformanceCounterPermissionAccess"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetBaseEntry", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Security.Permissions.ResourcePermissionBaseEntry"))
    );

    $.Field({Static:false, Public:false}, "categoryName", $.String);

    $.Field({Static:false, Public:false}, "machineName", $.String);

    $.Field({Static:false, Public:false}, "permissionAccess", $asm12.TypeRef("System.Diagnostics.PerformanceCounterPermissionAccess"));

    $.Property({Static:false, Public:true }, "CategoryName", $.String);

    $.Property({Static:false, Public:true }, "MachineName", $.String);

    $.Property({Static:false, Public:true }, "PermissionAccess", $asm12.TypeRef("System.Diagnostics.PerformanceCounterPermissionAccess"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.PerformanceCounterType */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.PerformanceCounterType", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    NumberOfItemsHEX32: 0, 
    NumberOfItemsHEX64: 256, 
    NumberOfItems32: 65536, 
    NumberOfItems64: 65792, 
    CounterDelta32: 4195328, 
    CounterDelta64: 4195584, 
    SampleCounter: 4260864, 
    CountPerTimeInterval32: 4523008, 
    CountPerTimeInterval64: 4523264, 
    RateOfCountsPerSecond32: 272696320, 
    RateOfCountsPerSecond64: 272696576, 
    RawFraction: 537003008, 
    CounterTimer: 541132032, 
    Timer100Ns: 542180608, 
    SampleFraction: 549585920, 
    CounterTimerInverse: 557909248, 
    Timer100NsInverse: 558957824, 
    CounterMultiTimer: 574686464, 
    CounterMultiTimer100Ns: 575735040, 
    CounterMultiTimerInverse: 591463680, 
    CounterMultiTimer100NsInverse: 592512256, 
    AverageTimer32: 805438464, 
    ElapsedTime: 807666944, 
    AverageCount64: 1073874176, 
    SampleBase: 1073939457, 
    AverageBase: 1073939458, 
    RawBase: 1073939459, 
    CounterMultiBase: 1107494144, 
  }
);

/* class System.Diagnostics.Process */ 

(function Process$Members () {
  var $, $thisType;






















  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.ComponentModel.Component"), 
      Name: "System.Diagnostics.Process", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.Boolean, 
          $.Int32, $asm12.TypeRef("System.Diagnostics.ProcessInfo")
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "Close", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureState", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.Process+State"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Associated", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_HasExited", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Id", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MainModule", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.ProcessModule"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Modules", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.ProcessModuleCollection"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_OperatingSystem", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.OperatingSystem"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ProcessName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_SynchronizingObject", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.ComponentModel.ISynchronizeInvoke"))
    );

    $.ExternalMethod({Static:true , Public:true }, "GetCurrentProcess", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetProcessHandle", 
      new JSIL.MethodSignature($asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), [$.Int32, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "OnExited", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "RaiseOnExited", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, "Refresh", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ReleaseProcessHandle", 
      JSIL.MethodSignature.Action($asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"))
    );

    $.ExternalMethod({Static:false, Public:false}, "SetProcessId", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "StopWatchingForExit", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "haveProcessId", $.Boolean);

    $.Field({Static:false, Public:false}, "processId", $.Int32);

    $.Field({Static:false, Public:false}, "haveProcessHandle", $.Boolean);

    $.Field({Static:false, Public:false}, "m_processHandle", $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"));

    $.Field({Static:false, Public:false}, "isRemoteMachine", $.Boolean);

    $.Field({Static:false, Public:false}, "machineName", $.String);

    $.Field({Static:false, Public:false}, "processInfo", $asm12.TypeRef("System.Diagnostics.ProcessInfo"));

    $.Field({Static:false, Public:false}, "m_processAccess", $.Int32);

    $.Field({Static:false, Public:false}, "threads", $asm12.TypeRef("System.Diagnostics.ProcessThreadCollection"));

    $.Field({Static:false, Public:false}, "modules", $asm12.TypeRef("System.Diagnostics.ProcessModuleCollection"));

    $.Field({Static:false, Public:false}, "haveMainWindow", $.Boolean);

    $.Field({Static:false, Public:false}, "mainWindowTitle", $.String);

    $.Field({Static:false, Public:false}, "haveWorkingSetLimits", $.Boolean);

    $.Field({Static:false, Public:false}, "haveProcessorAffinity", $.Boolean);

    $.Field({Static:false, Public:false}, "havePriorityClass", $.Boolean);

    $.Field({Static:false, Public:false}, "watchingForExit", $.Boolean);

    $.Field({Static:false, Public:false}, "onExited", $asm0F.TypeRef("System.EventHandler"));

    $.Field({Static:false, Public:false}, "exited", $.Boolean);

    $.Field({Static:false, Public:false}, "exitCode", $.Int32);

    $.Field({Static:false, Public:false}, "signaled", $.Boolean);

    $.Field({Static:false, Public:false}, "haveExitTime", $.Boolean);

    $.Field({Static:false, Public:false}, "haveResponding", $.Boolean);

    $.Field({Static:false, Public:false}, "havePriorityBoostEnabled", $.Boolean);

    $.Field({Static:false, Public:false}, "raisedOnExited", $.Boolean);

    $.Field({Static:false, Public:false}, "registeredWaitHandle", $asm0F.TypeRef("System.Threading.RegisteredWaitHandle"));

    $.Field({Static:false, Public:false}, "waitHandle", $asm0F.TypeRef("System.Threading.WaitHandle"));

    $.Field({Static:false, Public:false}, "synchronizingObject", $asm12.TypeRef("System.ComponentModel.ISynchronizeInvoke"));

    $.Field({Static:false, Public:false}, "standardOutput", $asm0F.TypeRef("System.IO.StreamReader"));

    $.Field({Static:false, Public:false}, "standardInput", $asm0F.TypeRef("System.IO.StreamWriter"));

    $.Field({Static:false, Public:false}, "standardError", $asm0F.TypeRef("System.IO.StreamReader"));

    $.Field({Static:false, Public:false}, "operatingSystem", $asm0F.TypeRef("System.OperatingSystem"));

    $.Field({Static:false, Public:false}, "disposed", $.Boolean);

    $.Field({Static:true , Public:false}, "s_CreateProcessLock", $.Object);

    $.Field({Static:false, Public:false}, "outputStreamReadMode", $asm12.TypeRef("System.Diagnostics.Process+StreamReadMode"));

    $.Field({Static:false, Public:false}, "errorStreamReadMode", $asm12.TypeRef("System.Diagnostics.Process+StreamReadMode"));

    $.Field({Static:false, Public:false}, "output", $asm12.TypeRef("System.Diagnostics.AsyncStreamReader"));

    $.Field({Static:false, Public:false}, "error", $asm12.TypeRef("System.Diagnostics.AsyncStreamReader"));

    $.Field({Static:true , Public:false}, "InvalidPipeHandle", $asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeFileHandle"));

    $.Field({Static:true , Public:false}, "processTracing", $asm12.TypeRef("System.Diagnostics.TraceSwitch"), null);

    $.Property({Static:false, Public:false}, "Associated", $.Boolean);

    $.Property({Static:false, Public:true }, "HasExited", $.Boolean);

    $.Property({Static:false, Public:true }, "Id", $.Int32);

    $.Property({Static:false, Public:true }, "MainModule", $asm12.TypeRef("System.Diagnostics.ProcessModule"));

    $.Property({Static:false, Public:true }, "Modules", $asm12.TypeRef("System.Diagnostics.ProcessModuleCollection"));

    $.Property({Static:false, Public:false}, "OperatingSystem", $asm0F.TypeRef("System.OperatingSystem"));

    $.Property({Static:false, Public:true }, "ProcessName", $.String);

    $.Property({Static:false, Public:true }, "SynchronizingObject", $asm12.TypeRef("System.ComponentModel.ISynchronizeInvoke"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.Process+StreamReadMode */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.Process+StreamReadMode", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    undefined: 0, 
    syncMode: 1, 
    asyncMode: 2, 
  }
);

/* enum System.Diagnostics.Process+State */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.Process+State", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    HaveId: 1, 
    IsLocal: 2, 
    IsNt: 4, 
    HaveProcessInfo: 8, 
    HaveNtProcessInfo: 12, 
    Exited: 16, 
    Associated: 32, 
    IsWin2k: 64, 
  }
);

/* class System.Diagnostics.ProcessInfo */ 

(function ProcessInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.ProcessInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "threadInfoList", $asm0F.TypeRef("System.Collections.ArrayList"));

    $.Field({Static:false, Public:true }, "basePriority", $.Int32);

    $.Field({Static:false, Public:true }, "processName", $.String);

    $.Field({Static:false, Public:true }, "processId", $.Int32);

    $.Field({Static:false, Public:true }, "handleCount", $.Int32);

    $.Field({Static:false, Public:true }, "poolPagedBytes", $.Int64);

    $.Field({Static:false, Public:true }, "poolNonpagedBytes", $.Int64);

    $.Field({Static:false, Public:true }, "virtualBytes", $.Int64);

    $.Field({Static:false, Public:true }, "virtualBytesPeak", $.Int64);

    $.Field({Static:false, Public:true }, "workingSetPeak", $.Int64);

    $.Field({Static:false, Public:true }, "workingSet", $.Int64);

    $.Field({Static:false, Public:true }, "pageFileBytesPeak", $.Int64);

    $.Field({Static:false, Public:true }, "pageFileBytes", $.Int64);

    $.Field({Static:false, Public:true }, "privateBytes", $.Int64);

    $.Field({Static:false, Public:true }, "mainModuleId", $.Int32);

    $.Field({Static:false, Public:true }, "sessionId", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ThreadInfo */ 

(function ThreadInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.ThreadInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "threadId", $.Int32);

    $.Field({Static:false, Public:true }, "processId", $.Int32);

    $.Field({Static:false, Public:true }, "basePriority", $.Int32);

    $.Field({Static:false, Public:true }, "currentPriority", $.Int32);

    $.Field({Static:false, Public:true }, "startAddress", $.IntPtr);

    $.Field({Static:false, Public:true }, "threadState", $asm12.TypeRef("System.Diagnostics.ThreadState"));

    $.Field({Static:false, Public:true }, "threadWaitReason", $asm12.TypeRef("System.Diagnostics.ThreadWaitReason"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ModuleInfo */ 

(function ModuleInfo$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.ModuleInfo", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "baseName", $.String);

    $.Field({Static:false, Public:true }, "fileName", $.String);

    $.Field({Static:false, Public:true }, "baseOfDll", $.IntPtr);

    $.Field({Static:false, Public:true }, "entryPoint", $.IntPtr);

    $.Field({Static:false, Public:true }, "sizeOfImage", $.Int32);

    $.Field({Static:false, Public:true }, "Id", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ProcessManager */ 

(function ProcessManager$Members () {
  var $, $thisType;












  JSIL.MakeStaticClass("System.Diagnostics.ProcessManager", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "get_IsNt", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_IsOSOlderThanXP", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:true }, "GetModuleInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ModuleInfo")]), [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessIdFromHandle", 
      new JSIL.MethodSignature($.Int32, [$asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle")])
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessIds", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Int32]))
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessInfo", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.ProcessInfo"), [$.Int32, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetProcessInfosCore", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ProcessInfo")]), [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:true }, "IsProcessRunning", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsProcessRunning", 
      new JSIL.MethodSignature($.Boolean, [$.Int32, $jsilcore.TypeRef("System.Array", [$.Int32])])
    );

    $.ExternalMethod({Static:true , Public:true }, "IsRemoteMachine", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:true }, "OpenProcess", 
      new JSIL.MethodSignature($asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"), [
          $.Int32, $.Int32, 
          $.Boolean
        ])
    );

    $.Property({Static:true , Public:true }, "IsNt", $.Boolean);

    $.Property({Static:true , Public:true }, "IsOSOlderThanXP", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ProcessManager+<>c__DisplayClass5_0 */ 

(function $l$gc__DisplayClass5_0$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.ProcessManager+<>c__DisplayClass5_0", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "$lGetProcessInfo$gb__0", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.Field({Static:false, Public:true }, "processId", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class System.Diagnostics.WinProcessManager */ 

(function WinProcessManager$Members () {
  var $, $thisType;




  JSIL.MakeStaticClass("System.Diagnostics.WinProcessManager", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "GetModuleInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ModuleInfo")]), [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessIds", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Int32]))
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessInfos", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ProcessInfo")]))
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.NtProcessManager */ 

(function NtProcessManager$Members () {
  var $, $thisType;















  JSIL.MakeStaticClass("System.Diagnostics.NtProcessManager", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "get_SystemProcessID", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:true }, "GetFirstModuleInfo", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.ModuleInfo"), [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:true }, "GetModuleInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ModuleInfo")]), [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetModuleInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ModuleInfo")]), [$.Int32, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessIdFromHandle", 
      new JSIL.MethodSignature($.Int32, [$asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle")])
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessIds", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Int32]))
    );

    $.ExternalMethod({Static:true , Public:false}, "GetProcessInfo", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.ProcessInfo"), [
          $asm12.TypeRef("Microsoft.Win32.NativeMethods+PERF_OBJECT_TYPE"), $.IntPtr, 
          $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("Microsoft.Win32.NativeMethods+PERF_COUNTER_DEFINITION")])
        ])
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ProcessInfo")]), [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetProcessInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ProcessInfo")]), [$asm12.TypeRef("System.Diagnostics.PerformanceCounterLib")])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetProcessInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ProcessInfo")]), [
          $asm12.TypeRef("System.Diagnostics.PerformanceCounterLib"), $.Int32, 
          $.Int32, $jsilcore.TypeRef("System.Array", [$.Byte])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetThreadInfo", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.ThreadInfo"), [
          $asm12.TypeRef("Microsoft.Win32.NativeMethods+PERF_OBJECT_TYPE"), $.IntPtr, 
          $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("Microsoft.Win32.NativeMethods+PERF_COUNTER_DEFINITION")])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetThreadWaitReason", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.ThreadWaitReason"), [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetValueId", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Diagnostics.NtProcessManager+ValueId"), [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "ReadCounterValue", 
      new JSIL.MethodSignature($.Int64, [$.Int32, $.IntPtr])
    );

    $.Field({Static:true , Public:false}, "valueIds", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Property({Static:true , Public:false}, "SystemProcessID", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.NtProcessManager+ValueId */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.NtProcessManager+ValueId", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: false, 
    IsFlags: false, 
  }, 
  {
    Unknown: -1, 
    HandleCount: 0, 
    PoolPagedBytes: 1, 
    PoolNonpagedBytes: 2, 
    ElapsedTime: 3, 
    VirtualBytesPeak: 4, 
    VirtualBytes: 5, 
    PrivateBytes: 6, 
    PageFileBytes: 7, 
    PageFileBytesPeak: 8, 
    WorkingSetPeak: 9, 
    WorkingSet: 10, 
    ThreadId: 11, 
    ProcessId: 12, 
    BasePriority: 13, 
    CurrentPriority: 14, 
    UserTime: 15, 
    PrivilegedTime: 16, 
    StartAddress: 17, 
    ThreadState: 18, 
    ThreadWaitReason: 19, 
  }
);

/* class System.Diagnostics.NtProcessInfoHelper */ 

(function NtProcessInfoHelper$Members () {
  var $, $thisType;





  JSIL.MakeStaticClass("System.Diagnostics.NtProcessInfoHelper", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "GetNewBufferSize", 
      new JSIL.MethodSignature($.Int32, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:true , Public:true }, "GetProcessInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ProcessInfo")]), [$asm0F.TypeRef("System.Predicate`1", [$.Int32])])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetProcessInfos", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ProcessInfo")]), [$.IntPtr, $asm0F.TypeRef("System.Predicate`1", [$.Int32])])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetProcessShortName", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.Field({Static:true , Public:false}, "CachedBuffer", $jsilcore.TypeRef("System.Array", [$.Int64]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.NtProcessInfoHelper+SystemProcessInformation */ 

(function SystemProcessInformation$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.NtProcessInfoHelper+SystemProcessInformation", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "NextEntryOffset", $.UInt32);

    $.Field({Static:false, Public:false}, "NumberOfThreads", $.UInt32);

    $.Field({Static:false, Public:false}, "NameLength", $.UInt16);

    $.Field({Static:false, Public:false}, "NamePtr", $.IntPtr);

    $.Field({Static:false, Public:false}, "BasePriority", $.Int32);

    $.Field({Static:false, Public:false}, "UniqueProcessId", $.IntPtr);

    $.Field({Static:false, Public:false}, "HandleCount", $.UInt32);

    $.Field({Static:false, Public:false}, "SessionId", $.UInt32);

    $.Field({Static:false, Public:false}, "PeakVirtualSize", $.UIntPtr);

    $.Field({Static:false, Public:false}, "VirtualSize", $.UIntPtr);

    $.Field({Static:false, Public:false}, "PeakWorkingSetSize", $.UIntPtr);

    $.Field({Static:false, Public:false}, "WorkingSetSize", $.UIntPtr);

    $.Field({Static:false, Public:false}, "QuotaPagedPoolUsage", $.UIntPtr);

    $.Field({Static:false, Public:false}, "QuotaNonPagedPoolUsage", $.UIntPtr);

    $.Field({Static:false, Public:false}, "PagefileUsage", $.UIntPtr);

    $.Field({Static:false, Public:false}, "PeakPagefileUsage", $.UIntPtr);

    $.Field({Static:false, Public:false}, "PrivatePageCount", $.UIntPtr);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.NtProcessInfoHelper+SystemThreadInformation */ 

(function SystemThreadInformation$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.NtProcessInfoHelper+SystemThreadInformation", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "StartAddress", $.IntPtr);

    $.Field({Static:false, Public:false}, "UniqueProcess", $.IntPtr);

    $.Field({Static:false, Public:false}, "UniqueThread", $.IntPtr);

    $.Field({Static:false, Public:false}, "Priority", $.Int32);

    $.Field({Static:false, Public:false}, "BasePriority", $.Int32);

    $.Field({Static:false, Public:false}, "ThreadState", $.UInt32);

    $.Field({Static:false, Public:false}, "WaitReason", $.UInt32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ProcessModule */ 

(function ProcessModule$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.ComponentModel.Component"), 
      Name: "System.Diagnostics.ProcessModule", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Diagnostics.ModuleInfo"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ModuleName", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "moduleInfo", $asm12.TypeRef("System.Diagnostics.ModuleInfo"));

    $.Property({Static:false, Public:true }, "ModuleName", $.String);

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ProcessModuleCollection */ 

(function ProcessModuleCollection$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Collections.ReadOnlyCollectionBase"), 
      Name: "System.Diagnostics.ProcessModuleCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Diagnostics.ProcessModule")]))
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ProcessStartInfo */ 

(function ProcessStartInfo$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.ProcessStartInfo", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, "get_Environment", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_EnvironmentVariables", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Collections.Specialized.StringDictionary"))
    );

    $.Field({Static:false, Public:false}, "weakParentProcess", $asm0F.TypeRef("System.WeakReference"));

    $.Field({Static:false, Public:false}, "environmentVariables", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Field({Static:false, Public:false}, "environment", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]));

    $.Property({Static:false, Public:true }, "EnvironmentVariables", $asm12.TypeRef("System.Collections.Specialized.StringDictionary"));

    $.Property({Static:false, Public:true }, "Environment", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ProcessThreadCollection */ 

(function ProcessThreadCollection$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Collections.ReadOnlyCollectionBase"), 
      Name: "System.Diagnostics.ProcessThreadCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ProcessWaitHandle */ 

(function ProcessWaitHandle$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Threading.WaitHandle"), 
      Name: "System.Diagnostics.ProcessWaitHandle", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeProcessHandle"))
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.SharedPerformanceCounter */ 

(function SharedPerformanceCounter$Members () {
  var $, $thisType;







































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.SharedPerformanceCounter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $.String, $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "AddToValue", 
      new JSIL.MethodSignature($.Int64, [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CounterEntry")]), $.Int64])
    );

    $.ExternalMethod({Static:false, Public:false}, "CalculateAndAllocateMemory", 
      new JSIL.MethodSignature($.Int32, [$.Int32, $jsilcore.TypeRef("JSIL.Reference", [$.Int32])])
    );

    $.ExternalMethod({Static:false, Public:false}, "CalculateMemory", 
      new JSIL.MethodSignature($.Int32, [
          $.Int32, $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CalculateMemoryNoBoundsCheck", 
      new JSIL.MethodSignature($.Int32, [
          $.Int32, $.Int32, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "ClearCounterValues", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+InstanceEntry")]))
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateCategory", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryEntry")]), $.Int32, 
          $.String, $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateCounter", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CounterEntry")]), $.Int32, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CreateInstance", 
      new JSIL.MethodSignature($.Int32, [
          $jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryEntry")]), $.Int32, 
          $.String, $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ExitCriticalSection", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Pointer", [$.Int32]))
    );

    $.ExternalMethod({Static:false, Public:false}, "FindCategory", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Pointer", [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryEntry")])])])
    );

    $.ExternalMethod({Static:false, Public:false}, "FindCounter", 
      new JSIL.MethodSignature($.Boolean, [
          $.Int32, $.String, 
          $jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+InstanceEntry")]), $jsilcore.TypeRef("JSIL.Pointer", [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CounterEntry")])])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "FindInstance", 
      new JSIL.MethodSignature($.Boolean, [
          $.Int32, $.String, 
          $jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryEntry")]), $jsilcore.TypeRef("JSIL.Pointer", [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+InstanceEntry")])]), 
          $.Boolean, $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime"), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_FileView", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+FileMapping"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_ProcessData", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.ProcessData"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCategoryData", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryData"))
    );

    $.ExternalMethod({Static:false, Public:false}, "GetCounter", 
      new JSIL.MethodSignature($jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CounterEntry")]), [
          $.String, $.String, 
          $.Boolean, $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime")
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetFileMappingSizeFromConfig", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetStringLength", 
      new JSIL.MethodSignature($.Int32, [$jsilcore.TypeRef("JSIL.Pointer", [$.Char])])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetWstrHashCode", 
      new JSIL.MethodSignature($.Int32, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "IncrementBy", 
      new JSIL.MethodSignature($.Int64, [$.Int64])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsMisaligned", 
      new JSIL.MethodSignature($.Boolean, [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CounterEntry")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "PopulateLifetimeEntry", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+ProcessLifetimeEntry")]), $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime")])
    );

    $.ExternalMethod({Static:false, Public:false}, "RemoveInstance", 
      new JSIL.MethodSignature(null, [$.String, $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime")])
    );

    $.ExternalMethod({Static:false, Public:false}, "RemoveOneInstance", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+InstanceEntry")]), $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "ResolveAddress", 
      new JSIL.MethodSignature($.Int32, [$.Int64, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "ResolveOffset", 
      new JSIL.MethodSignature($.Int64, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "SafeMarshalCopy", 
      new JSIL.MethodSignature(null, [$.String, $.IntPtr])
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Value", 
      JSIL.MethodSignature.Action($.Int64)
    );

    $.ExternalMethod({Static:true , Public:false}, "SetValue", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CounterEntry")]), $.Int64])
    );

    $.ExternalMethod({Static:false, Public:false}, "StringEquals", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "TryReuseInstance", 
      new JSIL.MethodSignature($.Boolean, [
          $.Int32, $.String, 
          $jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryEntry")]), $jsilcore.TypeRef("JSIL.Pointer", [$jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+InstanceEntry")])]), 
          $asm12.TypeRef("System.Diagnostics.PerformanceCounterInstanceLifetime"), $jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+InstanceEntry")])
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Verify", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryEntry")]))
    );

    $.ExternalMethod({Static:false, Public:false}, "VerifyCategory", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryEntry")]))
    );

    $.ExternalMethod({Static:false, Public:false}, "VerifyInstance", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+InstanceEntry")]))
    );

    $.ExternalMethod({Static:false, Public:false}, "VerifyLifetime", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+InstanceEntry")]))
    );

    $.ExternalMethod({Static:true , Public:false}, "WaitAndEnterCriticalSection", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Pointer", [$.Int32]), $jsilcore.TypeRef("JSIL.Reference", [$.Boolean])])
    );

    $.ExternalMethod({Static:true , Public:false}, "WaitForCriticalSection", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Pointer", [$.Int32]))
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "SingleInstanceHashCode", $.Int32);

    $.Field({Static:true , Public:false}, "categoryDataTable", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "CategoryEntrySize", $.Int32);

    $.Field({Static:true , Public:false, ReadOnly:true }, "InstanceEntrySize", $.Int32);

    $.Field({Static:true , Public:false, ReadOnly:true }, "CounterEntrySize", $.Int32);

    $.Field({Static:true , Public:false, ReadOnly:true }, "ProcessLifetimeEntrySize", $.Int32);

    $.Field({Static:true , Public:false}, "LastInstanceLifetimeSweepTick", $.Int64);

    $.Field({Static:true , Public:false}, "procData", $asm12.TypeRef("System.Diagnostics.ProcessData"));

    $.Field({Static:false, Public:false}, "InitialOffset", $.Int32);

    $.Field({Static:false, Public:false}, "categoryData", $asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CategoryData"));

    $.Field({Static:false, Public:false}, "baseAddress", $.Int64);

    $.Field({Static:false, Public:false}, "counterEntryPointer", $jsilcore.TypeRef("JSIL.Pointer", [$asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+CounterEntry")]));

    $.Field({Static:false, Public:false}, "categoryName", $.String);

    $.Field({Static:false, Public:false}, "categoryNameHashCode", $.Int32);

    $.Field({Static:false, Public:false}, "thisInstanceOffset", $.Int32);

    $.Property({Static:true , Public:false}, "ProcessData", $asm12.TypeRef("System.Diagnostics.ProcessData"));

    $.Property({Static:false, Public:false}, "FileView", $asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+FileMapping"));

    $.Property({Static:false, Public:false}, "Value", $.Int64);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.SharedPerformanceCounter+FileMapping */ 

(function FileMapping$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.SharedPerformanceCounter+FileMapping", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_FileViewAddress", 
      JSIL.MethodSignature.Return($.IntPtr)
    );

    $.ExternalMethod({Static:false, Public:false}, "Initialize", 
      new JSIL.MethodSignature(null, [
          $.String, $.Int32, 
          $.Int32
        ])
    );

    $.Field({Static:false, Public:false}, "FileMappingSize", $.Int32);

    $.Field({Static:false, Public:false}, "fileViewAddress", $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeFileMapViewHandle"));

    $.Field({Static:false, Public:false}, "fileMappingHandle", $asm12.TypeRef("Microsoft.Win32.SafeHandles.SafeFileMappingHandle"));

    $.Property({Static:false, Public:false}, "FileViewAddress", $.IntPtr);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Diagnostics.SharedPerformanceCounter+CategoryEntry */ 

(function CategoryEntry$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Diagnostics.SharedPerformanceCounter+CategoryEntry", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "SpinLock", $.Int32);

    $.Field({Static:false, Public:true }, "CategoryNameHashCode", $.Int32);

    $.Field({Static:false, Public:true }, "CategoryNameOffset", $.Int32);

    $.Field({Static:false, Public:true }, "FirstInstanceOffset", $.Int32);

    $.Field({Static:false, Public:true }, "NextCategoryOffset", $.Int32);

    $.Field({Static:false, Public:true }, "IsConsistent", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Diagnostics.SharedPerformanceCounter+InstanceEntry */ 

(function InstanceEntry$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Diagnostics.SharedPerformanceCounter+InstanceEntry", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "SpinLock", $.Int32);

    $.Field({Static:false, Public:true }, "InstanceNameHashCode", $.Int32);

    $.Field({Static:false, Public:true }, "InstanceNameOffset", $.Int32);

    $.Field({Static:false, Public:true }, "RefCount", $.Int32);

    $.Field({Static:false, Public:true }, "FirstCounterOffset", $.Int32);

    $.Field({Static:false, Public:true }, "NextInstanceOffset", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Diagnostics.SharedPerformanceCounter+CounterEntry */ 

(function CounterEntry$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Diagnostics.SharedPerformanceCounter+CounterEntry", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "SpinLock", $.Int32);

    $.Field({Static:false, Public:true }, "CounterNameHashCode", $.Int32);

    $.Field({Static:false, Public:true }, "CounterNameOffset", $.Int32);

    $.Field({Static:false, Public:true }, "LifetimeOffset", $.Int32);

    $.Field({Static:false, Public:true }, "Value", $.Int64);

    $.Field({Static:false, Public:true }, "NextCounterOffset", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Diagnostics.SharedPerformanceCounter+CounterEntryMisaligned */ 

(function CounterEntryMisaligned$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Diagnostics.SharedPerformanceCounter+CounterEntryMisaligned", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "Value_lo", $.Int32);

    $.Field({Static:false, Public:true }, "Value_hi", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Diagnostics.SharedPerformanceCounter+ProcessLifetimeEntry */ 

(function ProcessLifetimeEntry$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Diagnostics.SharedPerformanceCounter+ProcessLifetimeEntry", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 0, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:true }, "LifetimeType", $.Int32);

    $.Field({Static:false, Public:true }, "ProcessId", $.Int32);

    $.Field({Static:false, Public:true }, "StartupTime", $.Int64);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.SharedPerformanceCounter+CategoryData */ 

(function CategoryData$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.SharedPerformanceCounter+CategoryData", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:true }, "FileMapping", $asm12.TypeRef("System.Diagnostics.SharedPerformanceCounter+FileMapping"));

    $.Field({Static:false, Public:true }, "EnableReuse", $.Boolean);

    $.Field({Static:false, Public:true }, "UseUniqueSharedMemory", $.Boolean);

    $.Field({Static:false, Public:true }, "FileMappingName", $.String);

    $.Field({Static:false, Public:true }, "MutexName", $.String);

    $.Field({Static:false, Public:true }, "CounterNames", $asm0F.TypeRef("System.Collections.ArrayList"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.ProcessData */ 

(function ProcessData$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.ProcessData", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int64])
    );

    $.Field({Static:false, Public:true }, "ProcessId", $.Int32);

    $.Field({Static:false, Public:true }, "StartupTime", $.Int64);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.SharedUtils */ 

(function SharedUtils$Members () {
  var $, $thisType;















  JSIL.MakeStaticClass("System.Diagnostics.SharedUtils", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CheckEnvironment", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "CheckNtEnvironment", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateSafeWin32Exception", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.ComponentModel.Win32Exception"))
    );

    $.ExternalMethod({Static:true , Public:false}, "CreateSafeWin32Exception", 
      new JSIL.MethodSignature($asm12.TypeRef("System.ComponentModel.Win32Exception"), [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "EnterMutex", 
      new JSIL.MethodSignature(null, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Threading.Mutex")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "EnterMutexWithoutGlobal", 
      new JSIL.MethodSignature(null, [$.String, $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Threading.Mutex")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "get_CurrentEnvironment", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_InternalSyncObject", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:true , Public:false}, "GetLargestBuildNumberFromKey", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("Microsoft.Win32.RegistryKey")])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetLatestBuildDllDirectory", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetLocalBuildDirectory", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:true , Public:false}, "SafeWaitForMutex", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Threading.Mutex"), $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Threading.Mutex")])])
    );

    $.ExternalMethod({Static:true , Public:false}, "SafeWaitForMutexOnce", 
      new JSIL.MethodSignature($.Boolean, [$asm0F.TypeRef("System.Threading.Mutex"), $jsilcore.TypeRef("JSIL.Reference", [$asm0F.TypeRef("System.Threading.Mutex")])])
    );

    $.PInvokeMethod({Static:true , Public:false}, "WaitForSingleObjectDontCallThis", 
      new JSIL.MethodSignature($.Int32, [$asm0F.TypeRef("Microsoft.Win32.SafeHandles.SafeWaitHandle"), $.Int32]), 
      {
        Module: "kernel32.dll", 
        EntryPoint: "WaitForSingleObject", 
      }
    );

    $.Field({Static:true , Public:false}, "environment", $asm0F.TypeRef("System.Int32"));

    $.Field({Static:true , Public:false}, "s_InternalSyncObject", $.Object);

    $.Property({Static:true , Public:false}, "InternalSyncObject", $.Object);

    $.Property({Static:true , Public:false}, "CurrentEnvironment", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Diagnostics.Stopwatch */ 

(function Stopwatch$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Diagnostics.Stopwatch", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "GetTimestamp", 
      JSIL.MethodSignature.Return($.Int64)
    );

    $.Field({Static:true , Public:true , ReadOnly:true }, "Frequency", $.Int64, function ($pi) {
        return $asm0F.System.Int64.FromNumber(10000000);
      });

    $.Field({Static:true , Public:true , ReadOnly:true }, "IsHighResolution", $.Boolean, true);

    $.Field({Static:true , Public:false, ReadOnly:true }, "tickFrequency", $.Double, function ($pi) {
        return +((+$pi.tickFrequency / +$pi.Frequency.ToNumber(-1, false)));
      });


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Diagnostics.ThreadState */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.ThreadState", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Initialized: 0, 
    Ready: 1, 
    Running: 2, 
    Standby: 3, 
    Terminated: 4, 
    Wait: 5, 
    Transition: 6, 
    Unknown: 7, 
  }
);

/* enum System.Diagnostics.ThreadWaitReason */ 

JSIL.MakeEnum(
  {
    FullName: "System.Diagnostics.ThreadWaitReason", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: false, 
  }, 
  {
    Executive: 0, 
    FreePage: 1, 
    PageIn: 2, 
    SystemAllocation: 3, 
    ExecutionDelay: 4, 
    Suspended: 5, 
    UserRequest: 6, 
    EventPairHigh: 7, 
    EventPairLow: 8, 
    LpcReceive: 9, 
    LpcReply: 10, 
    VirtualMemory: 11, 
    PageOut: 12, 
    Unknown: 13, 
  }
);

/* class System.ComponentModel.EventHandlerList */ 

(function EventHandlerList$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.ComponentModel.EventHandlerList", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Dispose", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Find", 
      new JSIL.MethodSignature($asm12.TypeRef("System.ComponentModel.EventHandlerList+ListEntry"), [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Item", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Delegate"), [$.Object])
    );

    $.Field({Static:false, Public:false}, "head", $asm12.TypeRef("System.ComponentModel.EventHandlerList+ListEntry"));

    $.Field({Static:false, Public:false}, "parent", $asm12.TypeRef("System.ComponentModel.Component"));

    $.Property({Static:false, Public:true }, "Item", $asm0F.TypeRef("System.Delegate"));

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.IDisposable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.ComponentModel.EventHandlerList+ListEntry */ 

(function ListEntry$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.ComponentModel.EventHandlerList+ListEntry", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:false, Public:false}, "next", $.Type);

    $.Field({Static:false, Public:false}, "key", $.Object);

    $.Field({Static:false, Public:false}, "handler", $asm0F.TypeRef("System.Delegate"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface System.ComponentModel.IComponent */ 

JSIL.MakeInterface(
  "System.ComponentModel.IComponent", true, [], function ($) {
  }, [$asm0F.TypeRef("System.IDisposable")])
  .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [true]; });

/* interface System.ComponentModel.IContainer */ 

JSIL.MakeInterface(
  "System.ComponentModel.IContainer", true, [], function ($) {
    $.Method({}, "Remove", JSIL.MethodSignature.Action($asm12.TypeRef("System.ComponentModel.IComponent")));
  }, [$asm0F.TypeRef("System.IDisposable")])
  .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [true]; });

/* class System.ComponentModel.InvalidEnumArgumentException */ 

(function InvalidEnumArgumentException$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ArgumentException"), 
      Name: "System.ComponentModel.InvalidEnumArgumentException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.Int32, 
          $asm0F.TypeRef("System.Type")
        ])
    );

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* interface System.ComponentModel.ISite */ 

JSIL.MakeInterface(
  "System.ComponentModel.ISite", true, [], function ($) {
    $.Method({}, "get_Container", JSIL.MethodSignature.Return($asm12.TypeRef("System.ComponentModel.IContainer")));
    $.Method({}, "get_DesignMode", JSIL.MethodSignature.Return($.Boolean));
    $.Method({}, "get_Name", JSIL.MethodSignature.Return($.String));
    $.Property({}, "Container");
    $.Property({}, "DesignMode");
    $.Property({}, "Name");
  }, [$asm0F.TypeRef("System.IServiceProvider")])
  .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [true]; });

/* interface System.ComponentModel.ISynchronizeInvoke */ 

JSIL.MakeInterface(
  "System.ComponentModel.ISynchronizeInvoke", true, [], function ($) {
    $.Method({}, "get_InvokeRequired", JSIL.MethodSignature.Return($.Boolean));
    $.Method({}, "BeginInvoke", new JSIL.MethodSignature($asm0F.TypeRef("System.IAsyncResult"), [$asm0F.TypeRef("System.Delegate"), $jsilcore.TypeRef("System.Array", [$.Object])]));
    $.Property({}, "InvokeRequired");
  }, []);

/* class System.ComponentModel.SyntaxCheck */ 

(function SyntaxCheck$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.ComponentModel.SyntaxCheck", true, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "CheckMachineName", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.ComponentModel.TypeConverter */ 

(function TypeConverter$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.ComponentModel.TypeConverter", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:true , Public:false}, "useCompatibleTypeConversion", $asm0F.TypeRef("System.Boolean"), false);

    $.Field({Static:true , Public:false}, "firstLoadAppSetting", $asm0F.TypeRef("System.Boolean"), true);

    $.Field({Static:true , Public:false}, "loadAppSettingLock", $.Object);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [true]; });

})();

JSIL.DeclareNamespace("System.ComponentModel.Design");
/* interface System.ComponentModel.Design.IDesignerHost */ 

JSIL.MakeInterface(
  "System.ComponentModel.Design.IDesignerHost", true, [], function ($) {
    $.Method({}, "get_RootComponent", JSIL.MethodSignature.Return($asm12.TypeRef("System.ComponentModel.IComponent")));
    $.Property({}, "RootComponent");
  }, [$asm0F.TypeRef("System.IServiceProvider")])
  .Attribute($asm0F.TypeRef("System.Runtime.InteropServices.ComVisibleAttribute"), function () { return [true]; });

/* class System.CodeDom.Compiler.CodeDomCompilationConfiguration */ 

(function CodeDomCompilationConfiguration$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.CodeDom.Compiler.CodeDomCompilationConfiguration", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "AddCompilerInfo", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.CodeDom.Compiler.CompilerInfo"))
    );

    $.ExternalMethod({Static:true , Public:false}, "get_Default", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.Field({Static:true , Public:false, ReadOnly:true }, "s_fieldSeparators", $jsilcore.TypeRef("System.Array", [$.Char]));

    $.Field({Static:false, Public:false}, "_compilerLanguages", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_compilerExtensions", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_allCompilerInfo", $asm0F.TypeRef("System.Collections.ArrayList"));

    $.Field({Static:true , Public:false}, "defaultInstance", $.Type);

    $.Property({Static:true , Public:false}, "Default", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.CodeDom.Compiler.CodeDomCompilationConfiguration+SectionHandler */ 

(function SectionHandler$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.CodeDom.Compiler.CodeDomCompilationConfiguration+SectionHandler", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "GetProviderOptions", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]), [$asm24.TypeRef("System.Xml.XmlNode")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.CodeDom.Compiler.HandlerBase */ 

(function HandlerBase$Members () {
  var $, $thisType;








  JSIL.MakeStaticClass("System.CodeDom.Compiler.HandlerBase", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "CheckForChildNodes", 
      JSIL.MethodSignature.Action($asm24.TypeRef("System.Xml.XmlNode"))
    );

    $.ExternalMethod({Static:true , Public:false}, "CheckForUnrecognizedAttributes", 
      JSIL.MethodSignature.Action($asm24.TypeRef("System.Xml.XmlNode"))
    );

    $.ExternalMethod({Static:true , Public:false}, "GetAndRemoveAttribute", 
      new JSIL.MethodSignature($asm24.TypeRef("System.Xml.XmlNode"), [
          $asm24.TypeRef("System.Xml.XmlNode"), $.String, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetAndRemoveNonEmptyStringAttributeInternal", 
      new JSIL.MethodSignature($asm24.TypeRef("System.Xml.XmlNode"), [
          $asm24.TypeRef("System.Xml.XmlNode"), $.String, 
          $.Boolean, $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetAndRemoveRequiredNonEmptyStringAttribute", 
      new JSIL.MethodSignature($asm24.TypeRef("System.Xml.XmlNode"), [
          $asm24.TypeRef("System.Xml.XmlNode"), $.String, 
          $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetAndRemoveStringAttributeInternal", 
      new JSIL.MethodSignature($asm24.TypeRef("System.Xml.XmlNode"), [
          $asm24.TypeRef("System.Xml.XmlNode"), $.String, 
          $.Boolean, $jsilcore.TypeRef("JSIL.Reference", [$.String])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "ThrowUnrecognizedElement", 
      JSIL.MethodSignature.Action($asm24.TypeRef("System.Xml.XmlNode"))
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.CodeDom.Compiler.CompilerInfo */ 

(function CompilerInfo$Members () {
  var $, $thisType;








  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.CodeDom.Compiler.CompilerInfo", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.CodeDom.Compiler.CompilerParameters"), $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "CreateProvider", 
      new JSIL.MethodSignature($asm12.TypeRef("System.CodeDom.Compiler.CodeDomProvider"), [$asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String])])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_CodeDomProviderType", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Type"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_CompilerParams", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.CodeDom.Compiler.CompilerParameters"))
    );

    $.ExternalMethod({Static:false, Public:false}, "get_ProviderOptions", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]))
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.Field({Static:false, Public:false}, "_codeDomProviderTypeName", $.String);

    $.Field({Static:false, Public:false}, "_compilerParams", $asm12.TypeRef("System.CodeDom.Compiler.CompilerParameters"));

    $.Field({Static:false, Public:false}, "_compilerLanguages", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "_compilerExtensions", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "configFileName", $.String);

    $.Field({Static:false, Public:false}, "_providerOptions", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]));

    $.Field({Static:false, Public:false}, "configFileLineNumber", $.Int32);

    $.Field({Static:false, Public:false}, "type", $asm0F.TypeRef("System.Type"));

    $.Property({Static:false, Public:true }, "CodeDomProviderType", $asm0F.TypeRef("System.Type"));

    $.Property({Static:false, Public:false}, "CompilerParams", $asm12.TypeRef("System.CodeDom.Compiler.CompilerParameters"));

    $.Property({Static:false, Public:false}, "ProviderOptions", $asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.CodeDom.Compiler.CompilerParameters */ 

(function CompilerParameters$Members () {
  var $, $thisType;









  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.CodeDom.Compiler.CompilerParameters", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("System.Array", [$.String]), $.String])
    );

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.String]), $.String, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_CompilerOptions", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_IncludeDebugInformation", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_ReferencedAssemblies", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Collections.Specialized.StringCollection"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_WarningLevel", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "set_WarningLevel", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.Field({Static:false, Public:false}, "coreAssemblyFileName", $.String)
      .Attribute($asm0F.TypeRef("System.Runtime.Serialization.OptionalFieldAttribute"));

    $.Field({Static:false, Public:false}, "assemblyNames", $asm12.TypeRef("System.Collections.Specialized.StringCollection"));

    $.Field({Static:false, Public:false}, "embeddedResources", $asm12.TypeRef("System.Collections.Specialized.StringCollection"))
      .Attribute($asm0F.TypeRef("System.Runtime.Serialization.OptionalFieldAttribute"));

    $.Field({Static:false, Public:false}, "linkedResources", $asm12.TypeRef("System.Collections.Specialized.StringCollection"))
      .Attribute($asm0F.TypeRef("System.Runtime.Serialization.OptionalFieldAttribute"));

    $.Field({Static:false, Public:false}, "outputName", $.String);

    $.Field({Static:false, Public:false}, "includeDebugInformation", $.Boolean);

    $.Field({Static:false, Public:false}, "warningLevel", $.Int32);

    $.Field({Static:false, Public:false}, "compilerOptions", $.String);

    $.Property({Static:false, Public:true }, "ReferencedAssemblies", $asm12.TypeRef("System.Collections.Specialized.StringCollection"));

    $.Property({Static:false, Public:true }, "IncludeDebugInformation", $.Boolean);

    $.Property({Static:false, Public:true }, "WarningLevel", $.Int32);

    $.Property({Static:false, Public:true }, "CompilerOptions", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.CodeDom.Compiler.Executor */ 

(function Executor$Members () {
  var $, $thisType;


  JSIL.MakeStaticClass("System.CodeDom.Compiler.Executor", true, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:false}, "GetRuntimeInstallDirectory", 
      JSIL.MethodSignature.Return($.String)
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.CodeDom.Compiler.RedistVersionInfo */ 

(function RedistVersionInfo$Members () {
  var $, $thisType;



  JSIL.MakeStaticClass("System.CodeDom.Compiler.RedistVersionInfo", false, [], function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:true , Public:true }, "GetCompilerPath", 
      new JSIL.MethodSignature($.String, [$asm0F.TypeRef("System.Collections.Generic.IDictionary`2", [$.String, $.String]), $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "GetCompilerPathFromRegistry", 
      new JSIL.MethodSignature($.String, [$.String])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("System.Text");
JSIL.DeclareNamespace("System.Text.RegularExpressions");
/* class System.Text.RegularExpressions.Regex */ 

(function Regex$Members () {
  var $, $thisType;





















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.Regex", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"), 
          $asm0F.TypeRef("System.TimeSpan"), $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CacheCode", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.CachedCodeEntry"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "Compile", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexRunnerFactory"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexCode"), $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")])
    );

    $.ExternalMethod({Static:true , Public:true }, "Escape", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_MatchTimeout", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.TimeSpan"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Options", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"))
    );

    $.ExternalMethod({Static:false, Public:true }, "get_RightToLeft", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "InitDefaultMatchTimeout", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.TimeSpan"))
    );

    $.ExternalMethod({Static:false, Public:false}, "InitializeReferences", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "LookupCachedAndUpdate", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.CachedCodeEntry"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "Match", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.Match"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:true }, "Match", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.Match"), [$.String, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Run", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.Match"), [
          $.Boolean, $.Int32, 
          $.String, $.Int32, 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.ISerializable.GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), "GetObjectData");

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionC", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionInvariant", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionR", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "ValidateMatchTimeout", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.TimeSpan"))
    );

    $.Field({Static:false, Public:false}, "pattern", $.String);

    $.Field({Static:false, Public:false}, "factory", $asm12.TypeRef("System.Text.RegularExpressions.RegexRunnerFactory"));

    $.Field({Static:false, Public:false}, "roptions", $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "MaximumMatchTimeout", $asm0F.TypeRef("System.TimeSpan"));

    $.Field({Static:true , Public:true , ReadOnly:true }, "InfiniteMatchTimeout", $asm0F.TypeRef("System.TimeSpan"));

    $.Field({Static:false, Public:false}, "internalMatchTimeout", $asm0F.TypeRef("System.TimeSpan"))
      .Attribute($asm0F.TypeRef("System.Runtime.Serialization.OptionalFieldAttribute"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "FallbackDefaultMatchTimeout", $asm0F.TypeRef("System.TimeSpan"));

    $.Field({Static:true , Public:false, ReadOnly:true }, "DefaultMatchTimeout", $asm0F.TypeRef("System.TimeSpan"));

    $.Field({Static:false, Public:false}, "caps", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "capnames", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "capslist", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "capsize", $.Int32);

    $.Field({Static:false, Public:false}, "runnerref", $asm12.TypeRef("System.Text.RegularExpressions.ExclusiveReference"));

    $.Field({Static:false, Public:false}, "replref", $asm12.TypeRef("System.Text.RegularExpressions.SharedReference"));

    $.Field({Static:false, Public:false}, "code", $asm12.TypeRef("System.Text.RegularExpressions.RegexCode"));

    $.Field({Static:false, Public:false}, "refsInitialized", $.Boolean);

    $.Field({Static:true , Public:false}, "livecode", $asm12.TypeRef("System.Collections.Generic.LinkedList`1", [$asm12.TypeRef("System.Text.RegularExpressions.CachedCodeEntry")]));

    $.Field({Static:true , Public:false}, "cacheSize", $.Int32, 15);


    function Regex__cctor () {
      $thisType.MaximumMatchTimeout = new $asm0F.System.TimeSpan();
      $thisType.InfiniteMatchTimeout = new $asm0F.System.TimeSpan();
      $thisType.FallbackDefaultMatchTimeout = new $asm0F.System.TimeSpan();
      $thisType.DefaultMatchTimeout = new $asm0F.System.TimeSpan();
    }; 

    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Regex__cctor
    );

    $.Property({Static:false, Public:true }, "Options", $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"));

    $.Property({Static:false, Public:true }, "MatchTimeout", $asm0F.TypeRef("System.TimeSpan"));

    $.Property({Static:false, Public:true }, "RightToLeft", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Runtime.Serialization.ISerializable")
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.CachedCodeEntry */ 

(function CachedCodeEntry$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.CachedCodeEntry", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 8, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $asm0F.TypeRef("System.Collections.Hashtable"), 
          $jsilcore.TypeRef("System.Array", [$.String]), $asm12.TypeRef("System.Text.RegularExpressions.RegexCode"), 
          $asm0F.TypeRef("System.Collections.Hashtable"), $.Int32, 
          $asm12.TypeRef("System.Text.RegularExpressions.ExclusiveReference"), $asm12.TypeRef("System.Text.RegularExpressions.SharedReference")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddCompiled", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Text.RegularExpressions.RegexRunnerFactory"))
    );

    $.Field({Static:false, Public:false}, "_key", $.String);

    $.Field({Static:false, Public:false}, "_code", $asm12.TypeRef("System.Text.RegularExpressions.RegexCode"));

    $.Field({Static:false, Public:false}, "_caps", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_capnames", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_capslist", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "_capsize", $.Int32);

    $.Field({Static:false, Public:false}, "_factory", $asm12.TypeRef("System.Text.RegularExpressions.RegexRunnerFactory"));

    $.Field({Static:false, Public:false}, "_runnerref", $asm12.TypeRef("System.Text.RegularExpressions.ExclusiveReference"));

    $.Field({Static:false, Public:false}, "_replref", $asm12.TypeRef("System.Text.RegularExpressions.SharedReference"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.ExclusiveReference */ 

(function ExclusiveReference$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.ExclusiveReference", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Get", 
      JSIL.MethodSignature.Return($.Object)
    );

    $.ExternalMethod({Static:false, Public:false}, "Release", 
      JSIL.MethodSignature.Action($.Object)
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.SharedReference */ 

(function SharedReference$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.SharedReference", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.Field({Static:false, Public:false}, "_ref", $asm0F.TypeRef("System.WeakReference"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexBoyerMoore */ 

(function RegexBoyerMoore$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexBoyerMoore", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.Boolean, 
          $.Boolean, $asm0F.TypeRef("System.Globalization.CultureInfo")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsMatch", 
      new JSIL.MethodSignature($.Boolean, [
          $.String, $.Int32, 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "MatchPattern", 
      new JSIL.MethodSignature($.Boolean, [$.String, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Scan", 
      new JSIL.MethodSignature($.Int32, [
          $.String, $.Int32, 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "_positive", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_negativeASCII", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_negativeUnicode", $jsilcore.TypeRef("System.Array", [$jsilcore.TypeRef("System.Array", [$.Int32])]));

    $.Field({Static:false, Public:false}, "_pattern", $.String);

    $.Field({Static:false, Public:false}, "_lowASCII", $.Int32);

    $.Field({Static:false, Public:false}, "_highASCII", $.Int32);

    $.Field({Static:false, Public:false}, "_rightToLeft", $.Boolean);

    $.Field({Static:false, Public:false}, "_caseInsensitive", $.Boolean);

    $.Field({Static:false, Public:false}, "_culture", $asm0F.TypeRef("System.Globalization.CultureInfo"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.Capture */ 

(function Capture$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.Capture", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Index", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:true }, "get_Value", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Property({Static:false, Public:true }, "Index", $.Int32);

    $.Property({Static:false, Public:true }, "Length", $.Int32);

    $.Property({Static:false, Public:true }, "Value", $.String);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexCharClass */ 

(function RegexCharClass$Members () {
  var $, $thisType;







































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexCharClass", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $asm0F.TypeRef("System.Collections.Generic.List`1", [$asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass+SingleRange")]), 
          $asm0F.TypeRef("System.Text.StringBuilder"), $.Type
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddCategory", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddCategoryFromName", 
      new JSIL.MethodSignature(null, [
          $.String, $.Boolean, 
          $.Boolean, $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddChar", 
      JSIL.MethodSignature.Action($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddCharClass", 
      JSIL.MethodSignature.Action($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddDigit", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.Boolean, 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddLowercase", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Globalization.CultureInfo"))
    );

    $.ExternalMethod({Static:false, Public:false}, "AddLowercaseRange", 
      new JSIL.MethodSignature(null, [
          $.Char, $.Char, 
          $asm0F.TypeRef("System.Globalization.CultureInfo")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddRange", 
      new JSIL.MethodSignature(null, [$.Char, $.Char])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddSet", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddSpace", 
      new JSIL.MethodSignature(null, [$.Boolean, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddSubtraction", 
      JSIL.MethodSignature.Action($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddWord", 
      new JSIL.MethodSignature(null, [$.Boolean, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "Canonicalize", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "CharInCategory", 
      new JSIL.MethodSignature($.Boolean, [
          $.Char, $.String, 
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "CharInCategoryGroup", 
      new JSIL.MethodSignature($.Boolean, [
          $.Char, $asm0F.TypeRef("System.Globalization.UnicodeCategory"), 
          $.String, $jsilcore.TypeRef("JSIL.Reference", [$.Int32])
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "CharInClass", 
      new JSIL.MethodSignature($.Boolean, [$.Char, $.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "CharInClassInternal", 
      new JSIL.MethodSignature($.Boolean, [
          $.Char, $.String, 
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "CharInClassRecursive", 
      new JSIL.MethodSignature($.Boolean, [
          $.Char, $.String, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_CanMerge", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "GetRangeAt", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass+SingleRange"), [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsECMAWordChar", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsEmpty", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsMergeable", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsNegated", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsSingleton", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsSingletonInverse", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsSubtraction", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsWordChar", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "NegateCategory", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "Parse", 
      new JSIL.MethodSignature($.Type, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "ParseRecursive", 
      new JSIL.MethodSignature($.Type, [$.String, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "RangeCount", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "set_Negate", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "SetFromProperty", 
      new JSIL.MethodSignature($.String, [
          $.String, $.Boolean, 
          $.String
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "SingletonChar", 
      new JSIL.MethodSignature($.Char, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "ToStringClass", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "_rangelist", $asm0F.TypeRef("System.Collections.Generic.List`1", [$asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass+SingleRange")]));

    $.Field({Static:false, Public:false}, "_categories", $asm0F.TypeRef("System.Text.StringBuilder"));

    $.Field({Static:false, Public:false}, "_canonical", $.Boolean);

    $.Field({Static:false, Public:false}, "_negate", $.Boolean);

    $.Field({Static:false, Public:false}, "_subtractor", $.Type);

    $.Field({Static:true , Public:false, ReadOnly:true }, "InternalRegexIgnoreCase", $.String, "__InternalRegexIgnoreCase__");

    $.Field({Static:true , Public:false, ReadOnly:true }, "Space", $.String, "d");

    $.Field({Static:true , Public:false, ReadOnly:true }, "NotSpace", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "Word", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "NotWord", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "SpaceClass", $.String, function ($pi) {
        return JSIL.ConcatString("\x00\x00\x01", $pi.Space);
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "NotSpaceClass", $.String, function ($pi) {
        return JSIL.ConcatString("\x01\x00\x01", $pi.Space);
      });

    $.Field({Static:true , Public:false, ReadOnly:true }, "WordClass", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "NotWordClass", $.String);

    $.Field({Static:true , Public:false, ReadOnly:true }, "DigitClass", $.String, "\x00\x00\x01\t");

    $.Field({Static:true , Public:false, ReadOnly:true }, "NotDigitClass", $.String, "\x00\x00\x01\ufff7");

    $.Field({Static:true , Public:false}, "_definedCategories", $asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.String]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_propTable", $jsilcore.TypeRef("System.Array", [$.String, JSIL.ArrayDimensionParameter(2)]));

    $.Field({Static:true , Public:false, ReadOnly:true }, "_lcTable", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass+LowerCaseMapping")]));

    $.Property({Static:false, Public:false}, "CanMerge", $.Boolean);

    $.Property({Static:false, Public:false}, "Negate", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct System.Text.RegularExpressions.RegexCharClass+LowerCaseMapping */ 

(function LowerCaseMapping$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.ValueType"), 
      Name: "System.Text.RegularExpressions.RegexCharClass+LowerCaseMapping", 
      IsPublic: false, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
      SequentialLayout: true, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Char, $.Char, 
          $.Int32, $.Int32
        ])
    );

    $.Field({Static:false, Public:false}, "_chMin", $.Char);

    $.Field({Static:false, Public:false}, "_chMax", $.Char);

    $.Field({Static:false, Public:false}, "_lcOp", $.Int32);

    $.Field({Static:false, Public:false}, "_data", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexCharClass+SingleRangeComparer */ 

(function SingleRangeComparer$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexCharClass+SingleRangeComparer", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:true , Virtual:true }, "Compare", 
      new JSIL.MethodSignature($.Int32, [$asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass+SingleRange"), $asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass+SingleRange")])
    );

    $.ImplementInterfaces(
      /* 0 */ $asm0F.TypeRef("System.Collections.Generic.IComparer`1", [$asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass+SingleRange")])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexCharClass+SingleRange */ 

(function SingleRange$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexCharClass+SingleRange", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.Char, $.Char])
    );

    $.Field({Static:false, Public:false}, "_first", $.Char);

    $.Field({Static:false, Public:false}, "_last", $.Char);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexCode */ 

(function RegexCode$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexCode", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 9, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("System.Array", [$.Int32]), $asm0F.TypeRef("System.Collections.Generic.List`1", [$.String]), 
          $.Int32, $asm0F.TypeRef("System.Collections.Hashtable"), 
          $.Int32, $asm12.TypeRef("System.Text.RegularExpressions.RegexBoyerMoore"), 
          $asm12.TypeRef("System.Text.RegularExpressions.RegexPrefix"), $.Int32, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:true , Public:false}, "MakeException", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.ArgumentException"), [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "OpcodeBacktracks", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "OpcodeSize", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.Field({Static:false, Public:false}, "_codes", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_strings", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "_trackcount", $.Int32);

    $.Field({Static:false, Public:false}, "_caps", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_capsize", $.Int32);

    $.Field({Static:false, Public:false}, "_fcPrefix", $asm12.TypeRef("System.Text.RegularExpressions.RegexPrefix"));

    $.Field({Static:false, Public:false}, "_bmPrefix", $asm12.TypeRef("System.Text.RegularExpressions.RegexBoyerMoore"));

    $.Field({Static:false, Public:false}, "_anchors", $.Int32);

    $.Field({Static:false, Public:false}, "_rightToLeft", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexCompiler */ 

(function RegexCompiler$Members () {
  var $, $thisType;



























































































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexCompiler", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Add", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Add", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddBacktrackNote", 
      new JSIL.MethodSignature($.Int32, [
          $.Int32, $asm0F.TypeRef("System.Reflection.Emit.Label"), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddGoto", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddTrack", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddTrack", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddUniqueTrack", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddUniqueTrack", 
      new JSIL.MethodSignature($.Int32, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Advance", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "AdvanceLabel", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Back", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Beq", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BeqFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Bge", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BgeFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Bgt", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BgtFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Bgtun", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Ble", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BleFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Blt", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BltFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Bne", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BneFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Br", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Brfalse", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BrfalseFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BrFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "BrtrueFar", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Call", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.MethodInfo"))
    );

    $.ExternalMethod({Static:false, Public:false}, "CallToLower", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Callvirt", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.MethodInfo"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Code", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "Compile", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexRunnerFactory"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexCode"), $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")])
    );

    $.ExternalMethod({Static:false, Public:false}, "DeclareInt", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"))
    );

    $.ExternalMethod({Static:false, Public:false}, "DeclareIntArray", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"))
    );

    $.ExternalMethod({Static:false, Public:false}, "DeclareString", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"))
    );

    $.ExternalMethod({Static:false, Public:false}, "DefineLabel", 
      JSIL.MethodSignature.Return($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "DoPush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "DoReplace", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Dup", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GenerateBacktrackSection", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GenerateFindFirstChar", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GenerateForwardSection", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GenerateGo", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GenerateInitTrackCount", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GenerateMiddleSection", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "GenerateOneCode", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Goto", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "IsCi", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "IsRtl", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "Ldc", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Ldlen", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Ldloc", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Ldstr", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "Ldthis", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Ldthisfld", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.FieldInfo"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Leftchar", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Leftcharnext", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "MarkLabel", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.Label"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Mvfldloc", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Reflection.FieldInfo"), $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder")])
    );

    $.ExternalMethod({Static:false, Public:false}, "Mvlocfld", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"), $asm0F.TypeRef("System.Reflection.FieldInfo")])
    );

    $.ExternalMethod({Static:false, Public:false}, "NextCodepos", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Operand", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Pop", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "PopDiscardStack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "PopDiscardStack", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "PopStack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "PopTrack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "PushStack", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"))
    );

    $.ExternalMethod({Static:false, Public:false}, "PushTrack", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"))
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadyPushStack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadyPushTrack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ReadyReplaceStack", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "RegexRunnerField", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Reflection.FieldInfo"), [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "RegexRunnerMethod", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Reflection.MethodInfo"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "Ret", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Rightchar", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Rightcharnext", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Stfld", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.FieldInfo"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Stloc", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Sub", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Sub", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "TopStack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "TopTrack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Track", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Trackagain", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackUnique", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackUnique2", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.Field({Static:true , Public:false}, "_textbegF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_textendF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_textstartF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_textposF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_textF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_trackposF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_trackF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_stackposF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_stackF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_trackcountF", $asm0F.TypeRef("System.Reflection.FieldInfo"));

    $.Field({Static:true , Public:false}, "_ensurestorageM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_captureM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_transferM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_uncaptureM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_ismatchedM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_matchlengthM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_matchindexM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_isboundaryM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_isECMABoundaryM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_chartolowerM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_getcharM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_crawlposM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_charInSetM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_getCurrentCulture", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_getInvariantCulture", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:true , Public:false}, "_checkTimeoutM", $asm0F.TypeRef("System.Reflection.MethodInfo"));

    $.Field({Static:false, Public:false}, "_ilg", $asm0F.TypeRef("System.Reflection.Emit.ILGenerator"));

    $.Field({Static:false, Public:false}, "_textstartV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_textbegV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_textendV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_textposV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_textV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_trackposV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_trackV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_stackposV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_stackV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_tempV", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_temp2V", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_temp3V", $asm0F.TypeRef("System.Reflection.Emit.LocalBuilder"));

    $.Field({Static:false, Public:false}, "_code", $asm12.TypeRef("System.Text.RegularExpressions.RegexCode"));

    $.Field({Static:false, Public:false}, "_codes", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_strings", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "_fcPrefix", $asm12.TypeRef("System.Text.RegularExpressions.RegexPrefix"));

    $.Field({Static:false, Public:false}, "_bmPrefix", $asm12.TypeRef("System.Text.RegularExpressions.RegexBoyerMoore"));

    $.Field({Static:false, Public:false}, "_anchors", $.Int32);

    $.Field({Static:false, Public:false}, "_labels", $jsilcore.TypeRef("System.Array", [$asm0F.TypeRef("System.Reflection.Emit.Label")]));

    $.Field({Static:false, Public:false}, "_notes", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Text.RegularExpressions.RegexCompiler+BacktrackNote")]));

    $.Field({Static:false, Public:false}, "_notecount", $.Int32);

    $.Field({Static:false, Public:false}, "_trackcount", $.Int32);

    $.Field({Static:false, Public:false}, "_backtrack", $asm0F.TypeRef("System.Reflection.Emit.Label"));

    $.Field({Static:false, Public:false}, "_regexopcode", $.Int32);

    $.Field({Static:false, Public:false}, "_codepos", $.Int32);

    $.Field({Static:false, Public:false}, "_backpos", $.Int32);

    $.Field({Static:false, Public:false}, "_options", $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"));

    $.Field({Static:false, Public:false}, "_uniquenote", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_goto", $jsilcore.TypeRef("System.Array", [$.Int32]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexCompiler+BacktrackNote */ 

(function BacktrackNote$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexCompiler+BacktrackNote", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm0F.TypeRef("System.Reflection.Emit.Label"), 
          $.Int32
        ])
    );

    $.Field({Static:false, Public:false}, "_codepos", $.Int32);

    $.Field({Static:false, Public:false}, "_flags", $.Int32);

    $.Field({Static:false, Public:false}, "_label", $asm0F.TypeRef("System.Reflection.Emit.Label"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexLWCGCompiler */ 

(function RegexLWCGCompiler$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Text.RegularExpressions.RegexCompiler"), 
      Name: "System.Text.RegularExpressions.RegexLWCGCompiler", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "DefineDynamicMethod", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.Reflection.Emit.DynamicMethod"), [
          $.String, $asm0F.TypeRef("System.Type"), 
          $asm0F.TypeRef("System.Type")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "FactoryInstanceFromCode", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexRunnerFactory"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexCode"), $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")])
    );

    $.Field({Static:true , Public:false}, "_regexCount", $.Int32, 0);

    $.Field({Static:true , Public:false}, "_paramTypes", $jsilcore.TypeRef("System.Array", [$asm0F.TypeRef("System.Type")]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexFCD */ 

(function RegexFCD$Members () {
  var $, $thisType;
















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexFCD", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:true , Public:false}, "AnchorFromType", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "Anchors", 
      new JSIL.MethodSignature($.Int32, [$asm12.TypeRef("System.Text.RegularExpressions.RegexTree")])
    );

    $.ExternalMethod({Static:false, Public:false}, "CalculateFC", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "FCIsEmpty", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "FirstChars", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexPrefix"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexTree")])
    );

    $.ExternalMethod({Static:false, Public:false}, "IntIsEmpty", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "PopFC", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexFC"))
    );

    $.ExternalMethod({Static:false, Public:false}, "PopInt", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:true , Public:false}, "Prefix", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexPrefix"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexTree")])
    );

    $.ExternalMethod({Static:false, Public:false}, "PushFC", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Text.RegularExpressions.RegexFC"))
    );

    $.ExternalMethod({Static:false, Public:false}, "PushInt", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "RegexFCFromRegexTree", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexFC"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexTree")])
    );

    $.ExternalMethod({Static:false, Public:false}, "SkipChild", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "TopFC", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexFC"))
    );

    $.Field({Static:false, Public:false}, "_intStack", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_intDepth", $.Int32);

    $.Field({Static:false, Public:false}, "_fcStack", $jsilcore.TypeRef("System.Array", [$asm12.TypeRef("System.Text.RegularExpressions.RegexFC")]));

    $.Field({Static:false, Public:false}, "_fcDepth", $.Int32);

    $.Field({Static:false, Public:false}, "_skipAllChildren", $.Boolean);

    $.Field({Static:false, Public:false}, "_skipchild", $.Boolean);

    $.Field({Static:false, Public:false}, "_failed", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexFC */ 

(function RegexFC$Members () {
  var $, $thisType;







  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexFC", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Char, $.Boolean, 
          $.Boolean, $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.Boolean, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddFC", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "GetFirstChars", 
      new JSIL.MethodSignature($.String, [$asm0F.TypeRef("System.Globalization.CultureInfo")])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsCaseInsensitive", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:false, Public:false}, "_cc", $asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass"));

    $.Field({Static:false, Public:false}, "_nullable", $.Boolean);

    $.Field({Static:false, Public:false}, "_caseInsensitive", $.Boolean);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexPrefix */ 

(function RegexPrefix$Members () {
  var $, $thisType;





  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexPrefix", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.String, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "get_CaseInsensitive", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "get_Empty", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "get_Prefix", 
      JSIL.MethodSignature.Return($.String)
    );

    $.Field({Static:false, Public:false}, "_prefix", $.String);

    $.Field({Static:false, Public:false}, "_caseInsensitive", $.Boolean);

    $.Field({Static:true , Public:false}, "_empty", $.Type);

    $.Property({Static:false, Public:false}, "Prefix", $.String);

    $.Property({Static:false, Public:false}, "CaseInsensitive", $.Boolean);

    $.Property({Static:true , Public:false}, "Empty", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.Group */ 

(function Group$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Text.RegularExpressions.Capture"), 
      Name: "System.Text.RegularExpressions.Group", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $jsilcore.TypeRef("System.Array", [$.Int32]), 
          $.Int32, $.String
        ])
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexRunner */ 

(function RegexRunner$Members () {
  var $, $thisType;


























  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexRunner", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Capture", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "CheckTimeout", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Crawl", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Crawlpos", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "DoCheckTimeout", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "DoubleCrawl", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "DoubleStack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "DoubleTrack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "EnsureStorage", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "FindFirstChar", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Go", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "InitMatch", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "InitTrackCount", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "IsBoundary", 
      new JSIL.MethodSignature($.Boolean, [
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsECMABoundary", 
      new JSIL.MethodSignature($.Boolean, [
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsMatched", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "MatchIndex", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "MatchLength", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Popcrawl", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Scan", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.Match"), [
          $asm12.TypeRef("System.Text.RegularExpressions.Regex"), $.String, 
          $.Int32, $.Int32, 
          $.Int32, $.Int32, 
          $.Boolean, $asm0F.TypeRef("System.TimeSpan")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "StartTimeoutWatch", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "TidyMatch", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.Match"), [$.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "TransferCapture", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Uncapture", 
      JSIL.MethodSignature.Void
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexInterpreter */ 

(function RegexInterpreter$Members () {
  var $, $thisType;










































  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Text.RegularExpressions.RegexRunner"), 
      Name: "System.Text.RegularExpressions.RegexInterpreter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 2, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$asm12.TypeRef("System.Text.RegularExpressions.RegexCode"), $asm0F.TypeRef("System.Globalization.CultureInfo")])
    );

    $.ExternalMethod({Static:false, Public:false}, "Advance", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Advance", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Backtrack", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Backwardnext", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Bump", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "CharAt", 
      new JSIL.MethodSignature($.Char, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "FindFirstChar", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "Forwardcharnext", 
      JSIL.MethodSignature.Return($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "Forwardchars", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Go", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Goto", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "InitTrackCount", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Leftchars", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Operand", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Operator", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Refmatch", 
      new JSIL.MethodSignature($.Boolean, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Rightchars", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "SetOperator", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "StackPeek", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "StackPeek", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "StackPop", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "StackPop", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "StackPush", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "StackPush", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Stringmatch", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "Textpos", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Textstart", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Textto", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPeek", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPeek", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPop", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPop", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Trackpos", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPush", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPush", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPush", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPush", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPush2", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "TrackPush2", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Trackto", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.Field({Static:false, Public:false}, "runoperator", $.Int32);

    $.Field({Static:false, Public:false}, "runcodes", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "runcodepos", $.Int32);

    $.Field({Static:false, Public:false}, "runstrings", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "runcode", $asm12.TypeRef("System.Text.RegularExpressions.RegexCode"));

    $.Field({Static:false, Public:false}, "runfcPrefix", $asm12.TypeRef("System.Text.RegularExpressions.RegexPrefix"));

    $.Field({Static:false, Public:false}, "runbmPrefix", $asm12.TypeRef("System.Text.RegularExpressions.RegexBoyerMoore"));

    $.Field({Static:false, Public:false}, "runanchors", $.Int32);

    $.Field({Static:false, Public:false}, "runrtl", $.Boolean);

    $.Field({Static:false, Public:false}, "runci", $.Boolean);

    $.Field({Static:false, Public:false}, "runculture", $asm0F.TypeRef("System.Globalization.CultureInfo"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.Match */ 

(function Match$Members () {
  var $, $thisType;











  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Text.RegularExpressions.Group"), 
      Name: "System.Text.RegularExpressions.Match", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 6, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Text.RegularExpressions.Regex"), $.Int32, 
          $.String, $.Int32, 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "AddMatch", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "BalanceMatch", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:true , Public:true }, "get_Empty", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "IsMatched", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "MatchIndex", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "MatchLength", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "RemoveMatch", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Reset", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Text.RegularExpressions.Regex"), $.String, 
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Tidy", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.Property({Static:true , Public:true }, "Empty", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.MatchSparse */ 

(function MatchSparse$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Text.RegularExpressions.Match"), 
      Name: "System.Text.RegularExpressions.MatchSparse", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 7, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Text.RegularExpressions.Regex"), $asm0F.TypeRef("System.Collections.Hashtable"), 
          $.Int32, $.String, 
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.Field({Static:false, Public:false}, "_caps", $asm0F.TypeRef("System.Collections.Hashtable"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexMatchTimeoutException */ 

(function RegexMatchTimeoutException$Members () {
  var $, $thisType;




  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.TimeoutException"), 
      Name: "System.Text.RegularExpressions.RegexMatchTimeoutException", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $asm0F.TypeRef("System.TimeSpan")
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Init", 
      new JSIL.MethodSignature(null, [
          $.String, $.String, 
          $asm0F.TypeRef("System.TimeSpan")
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "System.Runtime.Serialization.ISerializable.GetObjectData", 
      new JSIL.MethodSignature(null, [$asm0F.TypeRef("System.Runtime.Serialization.SerializationInfo"), $asm0F.TypeRef("System.Runtime.Serialization.StreamingContext")])
    )
      .Overrides($asm0F.TypeRef("System.Runtime.Serialization.ISerializable"), "GetObjectData");

    $.Field({Static:false, Public:false}, "regexInput", $.String);

    $.Field({Static:false, Public:false}, "regexPattern", $.String);

    $.Field({Static:false, Public:false}, "matchTimeout", $asm0F.TypeRef("System.TimeSpan"));

    $.ImplementInterfaces(
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexNode */ 

(function RegexNode$Members () {
  var $, $thisType;





















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexNode", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 4, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [$.Int32, $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"), 
          $.Char
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"), 
          $.String
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"), 
          $.Int32, $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddChild", 
      JSIL.MethodSignature.Action($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "Child", 
      new JSIL.MethodSignature($.Type, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "ChildCount", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "MakeQuantifier", 
      new JSIL.MethodSignature($.Type, [
          $.Boolean, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "MakeRep", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "Reduce", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReduceAlternation", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReduceConcatenation", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReduceGroup", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReduceRep", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReduceSet", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "ReverseLeft", 
      JSIL.MethodSignature.Return($.Type)
    );

    $.ExternalMethod({Static:false, Public:false}, "StripEnation", 
      new JSIL.MethodSignature($.Type, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Type", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionR", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:false, Public:false}, "_type", $.Int32);

    $.Field({Static:false, Public:false}, "_children", $asm0F.TypeRef("System.Collections.Generic.List`1", [$.Type]));

    $.Field({Static:false, Public:false}, "_str", $.String);

    $.Field({Static:false, Public:false}, "_ch", $.Char);

    $.Field({Static:false, Public:false}, "_m", $.Int32);

    $.Field({Static:false, Public:false}, "_n", $.Int32);

    $.Field({Static:false, Public:false}, "_options", $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"));

    $.Field({Static:false, Public:false}, "_next", $.Type);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* enum System.Text.RegularExpressions.RegexOptions */ 

JSIL.MakeEnum(
  {
    FullName: "System.Text.RegularExpressions.RegexOptions", 
    BaseType: $asm0F.TypeRef("System.Int32"), 
    IsPublic: true, 
    IsFlags: true, 
  }, 
  {
    None: 0, 
    IgnoreCase: 1, 
    Multiline: 2, 
    ExplicitCapture: 4, 
    Compiled: 8, 
    Singleline: 16, 
    IgnorePatternWhitespace: 32, 
    RightToLeft: 64, 
    ECMAScript: 256, 
    CultureInvariant: 512, 
  }
);

/* class System.Text.RegularExpressions.RegexParser */ 

(function RegexParser$Members () {
  var $, $thisType;










































































  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexParser", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm0F.TypeRef("System.Globalization.CultureInfo"))
    );

    $.ExternalMethod({Static:false, Public:false}, "AddAlternate", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "AddConcatenate", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Boolean
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddConcatenate", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "AddConcatenate", 
      new JSIL.MethodSignature(null, [
          $.Boolean, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "AddGroup", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "AddUnitNode", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Text.RegularExpressions.RegexNode"))
    );

    $.ExternalMethod({Static:false, Public:false}, "AddUnitNotone", 
      JSIL.MethodSignature.Action($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddUnitOne", 
      JSIL.MethodSignature.Action($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddUnitSet", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "AddUnitType", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "AssignNameSlots", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "CaptureSlotFromName", 
      new JSIL.MethodSignature($.Int32, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "CharAt", 
      new JSIL.MethodSignature($.Char, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "CharsRight", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "CountCaptures", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "EmptyOptionsStack", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "EmptyStack", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:true , Public:false}, "Escape", 
      new JSIL.MethodSignature($.String, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "HexDigit", 
      new JSIL.MethodSignature($.Int32, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsCaptureName", 
      new JSIL.MethodSignature($.Boolean, [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsCaptureSlot", 
      new JSIL.MethodSignature($.Boolean, [$.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsMetachar", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsOnlyTopOption", 
      new JSIL.MethodSignature($.Boolean, [$asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsQuantifier", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsSpace", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsSpecial", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "IsStopperX", 
      new JSIL.MethodSignature($.Boolean, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:false}, "IsTrueQuantifier", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "MakeException", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.ArgumentException"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "MoveLeft", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "MoveRight", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "MoveRight", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "MoveRightGetChar", 
      JSIL.MethodSignature.Return($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "NoteCaptureName", 
      new JSIL.MethodSignature(null, [$.String, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "NoteCaptureSlot", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:true , Public:false}, "OptionFromCode", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"), [$.Char])
    );

    $.ExternalMethod({Static:true , Public:false}, "Parse", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexTree"), [$.String, $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")])
    );

    $.ExternalMethod({Static:false, Public:false}, "ParseProperty", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "PopGroup", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "PopKeepOptions", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "PopOptions", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "PushGroup", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "PushOptions", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "Reset", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"))
    );

    $.ExternalMethod({Static:false, Public:false}, "RightChar", 
      JSIL.MethodSignature.Return($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "RightChar", 
      new JSIL.MethodSignature($.Char, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanBackslash", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexNode"))
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanBasicBackslash", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexNode"))
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanBlank", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanCapname", 
      JSIL.MethodSignature.Return($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanCharClass", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass"), [$.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanCharClass", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexCharClass"), [$.Boolean, $.Boolean])
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanCharEscape", 
      JSIL.MethodSignature.Return($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanControl", 
      JSIL.MethodSignature.Return($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanDecimal", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanGroupOpen", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexNode"))
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanHex", 
      new JSIL.MethodSignature($.Char, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanOctal", 
      JSIL.MethodSignature.Return($.Char)
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanOptions", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "ScanRegex", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexNode"))
    );

    $.ExternalMethod({Static:false, Public:false}, "SetPattern", 
      JSIL.MethodSignature.Action($.String)
    );

    $.ExternalMethod({Static:false, Public:false}, "StartGroup", 
      JSIL.MethodSignature.Action($asm12.TypeRef("System.Text.RegularExpressions.RegexNode"))
    );

    $.ExternalMethod({Static:false, Public:false}, "Textpos", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Textto", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "TypeFromCode", 
      new JSIL.MethodSignature($.Int32, [$.Char])
    );

    $.ExternalMethod({Static:false, Public:false}, "Unit", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexNode"))
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionE", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionI", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionM", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionN", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionS", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "UseOptionX", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.Field({Static:false, Public:false}, "_stack", $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"));

    $.Field({Static:false, Public:false}, "_group", $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"));

    $.Field({Static:false, Public:false}, "_alternation", $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"));

    $.Field({Static:false, Public:false}, "_concatenation", $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"));

    $.Field({Static:false, Public:false}, "_unit", $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"));

    $.Field({Static:false, Public:false}, "_pattern", $.String);

    $.Field({Static:false, Public:false}, "_currentPos", $.Int32);

    $.Field({Static:false, Public:false}, "_culture", $asm0F.TypeRef("System.Globalization.CultureInfo"));

    $.Field({Static:false, Public:false}, "_autocap", $.Int32);

    $.Field({Static:false, Public:false}, "_capcount", $.Int32);

    $.Field({Static:false, Public:false}, "_captop", $.Int32);

    $.Field({Static:false, Public:false}, "_capsize", $.Int32);

    $.Field({Static:false, Public:false}, "_caps", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_capnames", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_capnumlist", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_capnamelist", $asm0F.TypeRef("System.Collections.Generic.List`1", [$.String]));

    $.Field({Static:false, Public:false}, "_options", $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"));

    $.Field({Static:false, Public:false}, "_optionsStack", $asm0F.TypeRef("System.Collections.Generic.List`1", [$asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")]));

    $.Field({Static:false, Public:false}, "_ignoreNextParen", $.Boolean);

    $.Field({Static:true , Public:false, ReadOnly:true }, "_category", $jsilcore.TypeRef("System.Array", [$.Byte]));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexRunnerFactory */ 

(function RegexRunnerFactory$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexRunnerFactory", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "CreateInstance", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexRunner"))
    );


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexTree */ 

(function RegexTree$Members () {
  var $, $thisType;


  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexTree", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 7, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"), $asm0F.TypeRef("System.Collections.Hashtable"), 
          $jsilcore.TypeRef("System.Array", [$.Int32]), $.Int32, 
          $asm0F.TypeRef("System.Collections.Hashtable"), $jsilcore.TypeRef("System.Array", [$.String]), 
          $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions")
        ])
    );

    $.Field({Static:false, Public:false}, "_root", $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"));

    $.Field({Static:false, Public:false}, "_caps", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_capnumlist", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_capnames", $asm0F.TypeRef("System.Collections.Hashtable"));

    $.Field({Static:false, Public:false}, "_capslist", $jsilcore.TypeRef("System.Array", [$.String]));

    $.Field({Static:false, Public:false}, "_options", $asm12.TypeRef("System.Text.RegularExpressions.RegexOptions"));

    $.Field({Static:false, Public:false}, "_captop", $.Int32);


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.RegexWriter */ 

(function RegexWriter$Members () {
  var $, $thisType;
















  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "System.Text.RegularExpressions.RegexWriter", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "CurPos", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Emit", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "Emit", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "Emit", 
      new JSIL.MethodSignature(null, [
          $.Int32, $.Int32, 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "EmitFragment", 
      new JSIL.MethodSignature(null, [
          $.Int32, $asm12.TypeRef("System.Text.RegularExpressions.RegexNode"), 
          $.Int32
        ])
    );

    $.ExternalMethod({Static:false, Public:false}, "EmptyStack", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false}, "MakeException", 
      new JSIL.MethodSignature($asm0F.TypeRef("System.ArgumentException"), [$.String])
    );

    $.ExternalMethod({Static:false, Public:false}, "MapCapnum", 
      new JSIL.MethodSignature($.Int32, [$.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "PatchJump", 
      new JSIL.MethodSignature(null, [$.Int32, $.Int32])
    );

    $.ExternalMethod({Static:false, Public:false}, "PopInt", 
      JSIL.MethodSignature.Return($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "PushInt", 
      JSIL.MethodSignature.Action($.Int32)
    );

    $.ExternalMethod({Static:false, Public:false}, "RegexCodeFromRegexTree", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexCode"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexTree")])
    );

    $.ExternalMethod({Static:false, Public:false}, "StringCode", 
      new JSIL.MethodSignature($.Int32, [$.String])
    );

    $.ExternalMethod({Static:true , Public:false}, "Write", 
      new JSIL.MethodSignature($asm12.TypeRef("System.Text.RegularExpressions.RegexCode"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexTree")])
    );

    $.Field({Static:false, Public:false}, "_intStack", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_depth", $.Int32);

    $.Field({Static:false, Public:false}, "_emitted", $jsilcore.TypeRef("System.Array", [$.Int32]));

    $.Field({Static:false, Public:false}, "_curpos", $.Int32);

    $.Field({Static:false, Public:false}, "_stringhash", $asm0F.TypeRef("System.Collections.Generic.Dictionary`2", [$.String, $.Int32]));

    $.Field({Static:false, Public:false}, "_stringtable", $asm0F.TypeRef("System.Collections.Generic.List`1", [$.String]));

    $.Field({Static:false, Public:false}, "_counting", $.Boolean);

    $.Field({Static:false, Public:false}, "_count", $.Int32);

    $.Field({Static:false, Public:false}, "_trackcount", $.Int32);

    $.Field({Static:false, Public:false}, "_caps", $asm0F.TypeRef("System.Collections.Hashtable"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class System.Text.RegularExpressions.CompiledRegexRunner */ 

(function CompiledRegexRunner$Members () {
  var $, $thisType;






  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Text.RegularExpressions.RegexRunner"), 
      Name: "System.Text.RegularExpressions.CompiledRegexRunner", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "FindFirstChar", 
      JSIL.MethodSignature.Return($.Boolean)
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "Go", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "InitTrackCount", 
      JSIL.MethodSignature.Void
    );

    $.ExternalMethod({Static:false, Public:false}, "SetDelegates", 
      new JSIL.MethodSignature(null, [
          $asm12.TypeRef("System.Text.RegularExpressions.NoParamDelegate"), $asm12.TypeRef("System.Text.RegularExpressions.FindFirstCharDelegate"), 
          $asm12.TypeRef("System.Text.RegularExpressions.NoParamDelegate")
        ])
    );

    $.Field({Static:false, Public:false}, "goMethod", $asm12.TypeRef("System.Text.RegularExpressions.NoParamDelegate"));

    $.Field({Static:false, Public:false}, "findFirstCharMethod", $asm12.TypeRef("System.Text.RegularExpressions.FindFirstCharDelegate"));

    $.Field({Static:false, Public:false}, "initTrackCountMethod", $asm12.TypeRef("System.Text.RegularExpressions.NoParamDelegate"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* delegate System.Text.RegularExpressions.NoParamDelegate */ 

JSIL.MakeDelegate("System.Text.RegularExpressions.NoParamDelegate", false, [], 
  JSIL.MethodSignature.Action($asm12.TypeRef("System.Text.RegularExpressions.RegexRunner")));

/* delegate System.Text.RegularExpressions.FindFirstCharDelegate */ 

JSIL.MakeDelegate("System.Text.RegularExpressions.FindFirstCharDelegate", false, [], 
  new JSIL.MethodSignature($asm0F.TypeRef("System.Boolean"), [$asm12.TypeRef("System.Text.RegularExpressions.RegexRunner")]));

/* class System.Text.RegularExpressions.CompiledRegexRunnerFactory */ 

(function CompiledRegexRunnerFactory$Members () {
  var $, $thisType;



  JSIL.MakeType({
      BaseType: $asm12.TypeRef("System.Text.RegularExpressions.RegexRunnerFactory"), 
      Name: "System.Text.RegularExpressions.CompiledRegexRunnerFactory", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($ib) {
    $ = $ib;

    $.ExternalMethod({Static:false, Public:false}, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm0F.TypeRef("System.Reflection.Emit.DynamicMethod"), $asm0F.TypeRef("System.Reflection.Emit.DynamicMethod"), 
          $asm0F.TypeRef("System.Reflection.Emit.DynamicMethod")
        ])
    );

    $.ExternalMethod({Static:false, Public:false, Virtual:true }, "CreateInstance", 
      JSIL.MethodSignature.Return($asm12.TypeRef("System.Text.RegularExpressions.RegexRunner"))
    );

    $.Field({Static:false, Public:false}, "goMethod", $asm0F.TypeRef("System.Reflection.Emit.DynamicMethod"));

    $.Field({Static:false, Public:false}, "findFirstCharMethod", $asm0F.TypeRef("System.Reflection.Emit.DynamicMethod"));

    $.Field({Static:false, Public:false}, "initTrackCountMethod", $asm0F.TypeRef("System.Reflection.Emit.DynamicMethod"));


    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class <PrivateImplementationDetails> */ 

(function $lPrivateImplementationDetails$g$Members () {
  var $, $thisType;

  JSIL.MakeType({
      BaseType: $asm0F.TypeRef("System.Object"), 
      Name: "<PrivateImplementationDetails>", 
      IsPublic: false, 
      IsReferenceType: true, 
    }, function ($ib) {
    $ = $ib;

    $.Field({Static:true , Public:false, ReadOnly:true }, "03F4297FCC30D0FD5E420E5D26E7FA711167C7EF", $.Int64);

    $.Field({Static:true , Public:false, ReadOnly:true }, "E5BC1BAFADE1862DD6E0B9FB632BFAA6C3873A78", $.Int64);


    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm0F.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

